{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>ArchGeo is a Python-based geometry processing library equipped with integrated visualization and optimization capabilities.  It is designed to facilitate efficient design and construction by leveraging the knowledge of Discrete Differential Geometry (DDG).  Utilizing a half-edge data structure, ArchGeo adeptly handles a variety of meshes. The library not only provides visualization and rendering for geometric objects such as point clouds and curves but also excels in mesh optimization design.  For visualization tasks, it employs the powerful Mayavi3D library, while its optimization processes, particularly for quadrilateral meshes, are driven by a Gauss-Newton algorithm coupled with an efficient solver.</p> <p>To gain a clear understanding of how ArchGeo operates, we recommend exploring the DOS project, which is closely related to the published research paper \"Discrete Orthogonal Structures\" [1]. This project delves into the comprehensive implementations and showcases the capabilities of ArchGeo. It covers the relevant theory within DDG and optimized implementations, including discrete developable surfaces, discrete minimal surfaces, discrete constant mean curvature surfaces, principal meshes, and principal stress meshes, all based on the analysis and construction of discrete orthogonal quad meshes.</p> <p>Additional features of ArchGeo will be open-sourced in the near future. If you utilize this library in your projects, please cite the paper [1].</p> <p>ArchGeo offers four core features:</p> <ol> <li> <p>Comprehensive Visualization: ArchGeo provides detailed and intuitive visualizations of various geometric objects, including point clouds, curves, surfaces, meshes, and vector fields.</p> </li> <li> <p>Advanced Geometric Processing: ArchGeo processes manifold and orientable meshes, with specialized tools for analyzing and manipulating quad meshes.</p> </li> <li> <p>Powerful Optimization Solutions: ArchGeo leverages Discrete Differential Geometry (DDG) to solve geometric optimization problems for quad meshes, delivering efficient and effective solutions to complex geometric challenges.</p> </li> <li> <p>Rapid Interactive Design: ArchGeo supports real-time editing and interactive design, allowing for immediate adjustments and instant visual feedback to enhance the creative process.</p> </li> </ol>"},{"location":"#triangular-meshes","title":"Triangular meshes","text":"<p>Triangular meshes are the most commonly used meshes in geometry processing and computer graphics, since they can explicitly represent the model shape. Other good properties include representing flat surfaces efficiently, allocating more faces to the areas with fine detail, easily attaching data (e.g. RGB colors, texture coordinates, normal vectors, etc.) on vertices and interpolating over the whole surface, and simplier way to store triangular faces in data structure compared with other polygon faces. </p> <p>Regular triangular mesh has all the vertices of valence 6. Three angles of 60 degrees corresponds to equilateral triangles, which are the most visually preferred but very limited ones in freeform shape.  Skinny triangles with more extreme angles are not ideal in both geometry processing and industrial applications.</p>"},{"location":"#why-quad-meshes","title":"Why quad meshes?","text":"<p>Quad meshes are extensively used in animation, architectural designs, and industrial analysis. TThey are also a major focus in Discrete Differential Geometry (DDG), where they have given rise to a wealth of discrete theories [2].</p> <p>Each vertex of a regular quad mesh has valence 4.</p> <p>Compared with triangular meshes, quad meshes have the following good features:</p> <ul> <li>(usually) small number of valence at vertex star, which leads to less supporting weight in structural application</li> <li>can have torsion-free structure</li> <li>have nice geometry theory in discretization of (smooth) differential geometry</li> </ul>"},{"location":"#half-edge-data-structure","title":"Half-edge data structure","text":"<p>ArchGeo processes manifold and orientable meshes, with a particular focus on quad meshes, utilizing the half-edge data structure to represent the geometric relationships between vertices. This structure enables efficient traversal and manipulation of mesh elements, facilitating a wide range of geometry processing tasks.</p>"},{"location":"#architectural-geometry","title":"Architectural Geometry","text":"<p>The research area of Architectural Geometry originated from the 2006 paper \"Geometric modeling with conical meshes and developable surfaces\" [3] by Prof. Helmut Pottmann and colleagues. </p> <p>In 2007, the book \"Architectural geometry\" [4] was published, and since then, numerous high-quality research papers have been presented in top conferences such as ACM SIGGRAPH (Asia) and AAD, as well as in leading journals like ACM TOG, CAD, and CAGD.</p> <p>In 2008, the first Advances in Architectural Gometry (AAG) conference was launched in Vienna, followed by many follow-up application papers in architecture, structure, CAD and CAM.</p> <p>In 2015, a survey paper titled \"Architectural geometry\" [5] presented the fruitful achievements of this research area and also listed some promising research directions. </p> <p>This area, which combines theory and application, remains active with many researchers dedicated to advancing its development.</p> <p>[1] Felix Dellinger, Xinye Li, Hui Wang. 2023. Discrete orthogonal structures. Computers &amp; Graphics. 114, 126-137.</p> <p>[2] Alexander Bobenko, Suris Yuri. 2008. Discrete differential geometry: Integrable structure. Vol. 98. American Mathematical Soc.</p> <p>[3] Yang Liu, Helmut Pottmann, Johannes Wallner, Yongliang Yang, Wenping Wang. 2006. Geometric modeling with conical meshes and developable surfaces. ACM Trans. Graphics 25, 3, 681-689.</p> <p>[4] Helmut Pottmann, Andreas Asperl, Axel Kililan. 2007. Architectural geometry. Bentley Institute Press.</p> <p>[5] Helmut Pottmann, Michael Eigensatz, Amir Vaxman, Johannes Wallner. 2015. Architectural geometry. Computers &amp; Graphics. 47, 145-164.</p>"},{"location":"2.about/","title":"About","text":"<p>ArchGeo was developed by Hui Wang, building on the initial research and development by Davide Pellis, and has its roots in TU Wien's Architectural Geometry research. It has since evolved through projects at KAUST and Xi'an Jiaotong University, resulting in around 20 high-quality academic publications.  The codebase has been utilized in all of Hui Wang's research projects. </p> <p>For more context in Chinese, you can refer to the PhD thesis \u300a\u5efa\u7b51\u51e0\u4f55\u4e2d\u7684\u7f51\u683c\u4e0e\u5149\u6ed1\u66f2\u9762\u6784\u9020\u300b.</p> <p>ArchGeo is still under development. </p>"},{"location":"2.about/#rease-history","title":"Rease history","text":"<p>First released version was on Oct. 2023 for the published paper \"Discrete Orthogonal Structures\".</p>"},{"location":"2.about/#license","title":"License","text":"<p>ArchGeo is released and used under an MIT license</p>"},{"location":"2.about/#acknowledgements","title":"Acknowledgements","text":"<p>If you find this library helpful in your research, welcome to give a  in Github :octocat: and share it in Twitter . Thank you!</p> <p>Please cite this paper if you use this code in your research paper.</p> <pre><code>@Article{DOS2023,\n      author       = {Dellinger, Felix and Li, Xinye and Wang, Hui},\n      title        = {Discrete Orthogonal Structures},\n      journal      = {Computers &amp; Graphics},\n      volume       = {114},\n      pages        = {126--137},\n      month        = {June},\n      year         = {2023},\n      doi          = {10.1016/j.cag.2023.05.024},\n      note          = {https://github.com/WWmore/DOS}\n}\n</code></pre> <p>This documentation is run based on Material for Mkdocs. The webpage structure refers to some great geometry processing tools, like libigl, libhedra, Polyscope, Gptoolbox and Open3D.</p>"},{"location":"2.about/#contribution","title":"Contribution","text":"<p>ArchGeo remains under active development. It is a user-friendly, Python-based geometry processing tool with an intuitive GUI for efficient geometric design, making it an excellent entry point for research in DDG, CAD, and CG.  Looking ahead, ArchGeo aims to expand its industrial software applications, particularly in education and research. It also seeks to deepen its integration with industrial tools like Rhino3D and support geometric optimization across various applications.</p> <p>Please feel free to push issues or submit requests to contribute to our codebase. Welcome to enrich the library and work together to other tool formats, like a Grasshopper plugin. For any commercial uses, please contact us. Hoping this codebase is helpful for your research work .  Welcome to the research collaborations .</p> <p>If you have any suggestions for further topics, would like to collaborate in implementation, report bugs, or ask any questions, please directly contact Hui Wang.  Alternatively, you can open an issue in the repository and we will get back to you as soon as possible.</p>"},{"location":"2.about/#contributors","title":"Contributors","text":"<p>to be added ......</p>"},{"location":"3.installation/","title":"Installation","text":"<p>Using Anaconda to install every package.</p>"},{"location":"3.installation/#windows","title":"Windows","text":"<pre><code>1. Download Anaconda\n\n2. Open Anaconda Prompt\n\n&gt; conda create -n geo \n&gt; conda activate geo\n&gt; conda install mayavi traits traitsui qt pyqt vtk scipy spyder \n&gt; conda install -c haasad pypardiso\n\n3. Open Anaconda, under \"geo\" environment open Spyder\n</code></pre> <p>Once above installation failed because of versions conflict, then try below installations:</p> <pre><code>&gt; conda create -n geo python=3.6\n&gt; conda activate geo\n&gt; pip install numpy scipy\n&gt; pip install python-vtk\n&gt; pip install mayavi --no-cache\n&gt; conda install -c haasad pypardiso\n&gt; conda install pyface\n</code></pre> <p>Or use the exported files within <code>./conda/</code> to set your environment</p> <pre><code>&gt; conda env create -f environment.yml\n</code></pre>"},{"location":"3.installation/#macos","title":"MacOS","text":"<p>Same as the way in Windows.</p>"},{"location":"3.installation/#file-structure","title":"File Structure","text":""},{"location":"3.installation/#quickstart","title":"Quickstart","text":"<p>Just run the file <code>dos_1_readfile.py</code> to open an integrated GUI window. </p>"},{"location":"filestructure/","title":"File Structure","text":"<pre><code>.\n\u251c\u2500 geometrylab/\n\u2502  \u251c\u2500 geometry/\n\u2502  \u2502  \u251c\u2500 meshpy.py\n\u2502  \u2502  \u251c\u2500 meshprimitives.py\n\u2502  \u2502  \u251c\u2500 meshutilities.py\n\u2502  \u2502  \u251c\u2500 frame.py\n\u2502  \u2502  \u251c\u2500 polyline.py\n\u2502  \u2502  \u251c\u2500 circle.py\n\u2502  \u2502  \u2514\u2500bspline.py\n\u2502  \u251c\u2500 gui/\n\u2502  \u2502  \u251c\u2500 geolabcomponent.py\n\u2502  \u2502  \u251c\u2500 geolabgui.py\n\u2502  \u2502  \u251c\u2500 geolabmesh.py\n\u2502  \u2502  \u251c\u2500 geolabpoints.py\n\u2502  \u2502  \u251c\u2500 geolabscene.py\n\u2502  \u2502  \u251c\u2500 handler.py\n\u2502  \u2502  \u251c\u2500 multiscenemanager.py\n\u2502  \u2502  \u251c\u2500 scenemanager.py\n\u2502  \u2502  \u2514\u2500 tools.py\n\u2502  \u251c\u2500 optimization/\n\u2502  \u2502  \u251c\u2500 gridshell.py\n\u2502  \u2502  \u251c\u2500 guidedprojection.py\n\u2502  \u2502  \u251c\u2500 guidedprojectionbase.py\n\u2502  \u2502  \u2514\u2500 combnormals.py\n\u2502  \u251c\u2500 vtkplot/\n\u2502  \u2502  \u251c\u2500 scenemanager.py\n\u2502  \u2502  \u251c\u2500 plotmanager.py\n\u2502  \u2502  \u251c\u2500 meshplotmanager.py\n\u2502  \u2502  \u251c\u2500 plotutilities.py\n\u2502  \u2502  \u251c\u2500 glyphs.py\n\u2502  \u2502  \u251c\u2500 glyphsource.py\n\u2502  \u2502  \u251c\u2500 pointsource.py\n\u2502  \u2502  \u251c\u2500 pointsplotmanager.py\n\u2502  \u2502  \u251c\u2500 edgesource.py\n\u2502  \u2502  \u251c\u2500 polylinesource.py\n\u2502  \u2502  \u251c\u2500 bsplineplotmanager.py\n\u2502  \u2502  \u251c\u2500 vectorsource.py\n\u2502  \u2502  \u251c\u2500 vector3dsource.py\n\u2502  \u2502  \u251c\u2500 meshvectorsource.py\n\u2502  \u2502  \u251c\u2500 facesource.py\n\u2502  \u2502  \u251c\u2500 toolbar.py\n\u2502  \u2502  \u251c\u2500 selector.py\n\u2502  \u2502  \u251c\u2500 viewer.py\n\u2502  \u2502  \u2514\u2500 check.py\n\u2502  \u251c\u2500 utilities/\n\u2502  \u2502  \u2514\u2500 utilities.py\n\u2502  \u251c\u2500 fitting/\n\u2502  \u2502  \u251c\u2500 jetfitting.py\n\u2502  \u2502  \u251c\u2500 linearregression.py\n\u2502  \u2502  \u251c\u2500 cluster.py\n\u2502  \u2502  \u2514\u2500 bspline.py\n\u2502  \u2514\u2500 test/\n\u2502     \u2514\u2500 paneling.py\n\u251c\u2500 archgeolab/\n\u2502  \u251c\u2500 readfile_orthonet.py\n\u2502  \u251c\u2500 guidedprojection_orthonet.py\n\u2502  \u251c\u2500 opt_gui_orthonet.py\n\u2502  \u251c\u2500 archgeometry/\n\u2502  \u2502  \u251c\u2500 quadrings.py\n\u2502  \u2502  \u251c\u2500 gui_basis.py\n\u2502  \u2502  \u251c\u2500 gridshell_new.py\n\u2502  \u2502  \u251c\u2500 orient.py\n\u2502  \u2502  \u251c\u2500 orthogonalVectors.py\n\u2502  \u2502  \u251c\u2500 curves.py\n\u2502  \u2502  \u2514\u2500 conicSection.py\n\u2502  \u2514\u2500 constraints/\n\u2502  \u2502  \u251c\u2500 constraints_basis.py\n\u2502  \u2502  \u251c\u2500 constraints_net.py\n\u2502  \u2502  \u251c\u2500 constraints_fairness.py\n\u2502  \u2502  \u251c\u2500 constraints_glide.py\n      \u2514\u2500 constraints_equilibrium.py\n</code></pre>"},{"location":"filestructure/archgeolab/","title":"archgeolab","text":"<pre><code>.\n\u251c\u2500 geometrylab/\n\u251c\u2500 archgeolab/\n\u2502  \u251c\u2500 readfile_orthonet.py\n\u2502  \u251c\u2500 guidedprojection_orthonet.py\n\u2502  \u251c\u2500 opt_gui_orthonet.py\n\u2502  \u251c\u2500 archgeometry/\n\u2502  \u2502  \u251c\u2500 quadrings.py\n\u2502  \u2502  \u251c\u2500 gui_basis.py\n\u2502  \u2502  \u251c\u2500 gridshell_new.py\n\u2502  \u2502  \u251c\u2500 orient.py\n\u2502  \u2502  \u251c\u2500 orthogonalVectors.py\n\u2502  \u2502  \u251c\u2500 curves.py\n\u2502  \u2502  \u2514\u2500 conicSection.py\n\u2502  \u2514\u2500 constraints/\n\u2502  \u2502  \u251c\u2500 constraints_basis.py\n\u2502  \u2502  \u251c\u2500 constraints_net.py\n\u2502  \u2502  \u251c\u2500 constraints_fairness.py\n\u2502  \u2502  \u251c\u2500 constraints_glide.py\n      \u2514\u2500 constraints_equilibrium.py\n</code></pre> Files Functions <code>dos_1_readfile.py</code> read .obj files and open GUI window <code>dos_2_gui.py</code> plottings and algorithms settings between GUI window and optimization <code>dos_3_opt.py</code> Guided Projection algorithm settings"},{"location":"filestructure/archgeolab/#archgeometry","title":"archgeometry","text":"Files Functions <code>quadrings.py</code> superclass on meshpy.py for quad meshes <code>gui_basis.py</code> superclass on gui.py <code>gridshell_new.py</code> superclass on gridshell.py <code>orient.py</code> extract oriented vertex-stars on quadmeshes with even singularities <code>orthogonalVectors.py</code> frame structures \\((e_1, e_2, e_3)\\) <code>curves.py</code> extract mesh polylines <code>conicSection.py</code> sphere interpolations and packings"},{"location":"filestructure/archgeolab/#constraints","title":"constraints","text":"Files Functions <code>constraints_basis.py</code> commonly used basic constraints <code>constraints_net.py</code> commonly used nets constraints <code>constraints_fairness.py</code> several ways of fairness constraints <code>constraints_glide.py</code> points gliding andfixing <code>constraints_equilibrium.py</code> constraints for equilibrium shellstructures"},{"location":"filestructure/geometrylab/","title":"geometrylab","text":"<pre><code>.\n\u251c\u2500 geometrylab/\n\u2502  \u251c\u2500 geometry/\n\u2502  \u2502  \u251c\u2500 meshpy.py\n\u2502  \u2502  \u251c\u2500 meshprimitives.py\n\u2502  \u2502  \u251c\u2500 meshutilities.py\n\u2502  \u2502  \u251c\u2500 frame.py\n\u2502  \u2502  \u251c\u2500 polyline.py\n\u2502  \u2502  \u251c\u2500 circle.py\n\u2502  \u2502  \u2514\u2500bspline.py\n\u2502  \u251c\u2500 gui/\n\u2502  \u2502  \u251c\u2500 geolabcomponent.py\n\u2502  \u2502  \u251c\u2500 geolabgui.py\n\u2502  \u2502  \u251c\u2500 geolabmesh.py\n\u2502  \u2502  \u251c\u2500 geolabpoints.py\n\u2502  \u2502  \u251c\u2500 geolabscene.py\n\u2502  \u2502  \u251c\u2500 handler.py\n\u2502  \u2502  \u251c\u2500 multiscenemanager.py\n\u2502  \u2502  \u251c\u2500 scenemanager.py\n\u2502  \u2502  \u2514\u2500 tools.py\n\u2502  \u251c\u2500 optimization/\n\u2502  \u2502  \u251c\u2500 gridshell.py\n\u2502  \u2502  \u251c\u2500 guidedprojection.py\n\u2502  \u2502  \u251c\u2500 guidedprojectionbase.py\n\u2502  \u2502  \u2514\u2500 combnormals.py\n\u2502  \u251c\u2500 vtkplot/\n\u2502  \u2502  \u251c\u2500 scenemanager.py\n\u2502  \u2502  \u251c\u2500 plotmanager.py\n\u2502  \u2502  \u251c\u2500 meshplotmanager.py\n\u2502  \u2502  \u251c\u2500 plotutilities.py\n\u2502  \u2502  \u251c\u2500 glyphs.py\n\u2502  \u2502  \u251c\u2500 glyphsource.py\n\u2502  \u2502  \u251c\u2500 pointsource.py\n\u2502  \u2502  \u251c\u2500 pointsplotmanager.py\n\u2502  \u2502  \u251c\u2500 edgesource.py\n\u2502  \u2502  \u251c\u2500 polylinesource.py\n\u2502  \u2502  \u251c\u2500 bsplineplotmanager.py\n\u2502  \u2502  \u251c\u2500 vectorsource.py\n\u2502  \u2502  \u251c\u2500 vector3dsource.py\n\u2502  \u2502  \u251c\u2500 meshvectorsource.py\n\u2502  \u2502  \u251c\u2500 facesource.py\n\u2502  \u2502  \u251c\u2500 toolbar.py\n\u2502  \u2502  \u251c\u2500 selector.py\n\u2502  \u2502  \u251c\u2500 viewer.py\n\u2502  \u2502  \u2514\u2500 check.py\n\u2502  \u251c\u2500 utilities/\n\u2502  \u2502  \u2514\u2500 utilities.py\n\u2502  \u251c\u2500 fitting/\n\u2502  \u2502  \u251c\u2500 jetfitting.py\n\u2502  \u2502  \u251c\u2500 linearregression.py\n\u2502  \u2502  \u251c\u2500 cluster.py\n\u2502  \u2502  \u2514\u2500 bspline.py\n\u2502  \u2514\u2500 test/\n\u2502     \u2514\u2500 paneling.py\n\u2514\u2500 archgeolab/\n</code></pre>"},{"location":"filestructure/geometrylab/#geometry","title":"geometry","text":"Files Functions <code>meshpy.py</code> very basic mesh connection by half-edges <code>meshprimitives.py</code> plane, cylinder, sphere, torus, arrows <code>meshutilities.py</code> clean boundary, add noise <code>frame.py</code> frame vectors \\((origin,e_1,e_2,e_3)\\) <code>polyline.py</code> construction of polyline <code>circle.py</code> construction of circles <code>bspline.py</code> construction of B-spline"},{"location":"filestructure/geometrylab/#gui","title":"gui","text":"Files Functions <code>geolabcomponent.py</code> GeolabComponent <code>geolabgui.py</code> Toolbar button settings <code>geolabpoints.py</code> points plotting settings <code>geolabscene.py</code> basic Mayavi GUI viewer setting <code>handler.py</code> Handler <code>multiscenemanager.py</code> multi-scenes settings <code>scenemanager.py</code> callbacks of selection, hide, adding, removing <code>tools.py</code> loads, remesh, corner tolerance, save mesh in Toolbar"},{"location":"filestructure/geometrylab/#optimization","title":"optimization","text":"Files Functions <code>gridshell.py</code> basic geometric constraints settings <code>guidedprojection.py</code> Guided Projection algorithm settings <code>guidedprojectionbase.py</code> basice algorithm settings <code>combnormals.py</code> constraints for equilibrium shellstructure"},{"location":"filestructure/geometrylab/#vtkplot","title":"vtkplot","text":"Files Functions <code>scenemanager.py</code> scene manager class <code>plotmanager.py</code> plot manager class <code>meshplotmanager.py</code> mesh plottint manager class <code>plotutilities.py</code> plotting attributes <code>glyphs.py</code> plot arrows, spheres, pipes, discs, cones, rings <code>glyphsource.py</code> Glyph3D <code>pointsource.py</code> Points <code>pointsplotmanager.py</code> plot points <code>edgesource.py</code> plot edge plot <code>polylinesource.py</code> plot polylines <code>bsplineplotmanager.py</code> plot B-spline curves <code>vectorsource.py</code> vector settings <code>vector3dsource.py</code> plot vectors <code>meshvectorsource.py</code> plot vectors as meshes <code>facesource.py</code> plot faces <code>toolbar.py</code> Toolbar settings <code>selector.py</code> interactive selections <code>viewer.py</code> GUI viewer layout <code>check.py</code> check the changes of mesh connectivity"},{"location":"filestructure/geometrylab/#utilities","title":"utilities","text":"Files Functions <code>utilities.py</code> array data structure"},{"location":"filestructure/geometrylab/#fitting","title":"fitting","text":"Files Functions <code>jetfitting.py</code> quadratic fitting to get principal curvatures <code>linearregression.py</code> linear regression, sphere fitting <code>cluster.py</code> K-means cluster of given points <code>bspline.py</code> construction of B-spline curves"},{"location":"filestructure/geometrylab/#test","title":"test","text":"Files Functions <code>paneling.py</code> basic frame integrated with algorithm and GUI Run paneling.py file"},{"location":"functions/","title":"Python Functions","text":"<p>Please refer to the original code to use. </p> <p>Core files <code>meshpy.py</code> and generalized <code>quadring.py</code> include very basic mesh connectivity functions built by half-edge data structures.</p>"},{"location":"functions/meshpy/","title":"Meshpy","text":"<p>meshpy.py: The half-edge mesh data structure</p>"},{"location":"functions/meshpy/#meshpy.area","title":"<code>area(self)</code>","text":"<p>Computes the total surface area of the mesh.</p> <p>This function calculates the total surface area by summing the areas of all faces in the mesh.</p> <p>The main logic involves:</p> <ol> <li> <p>Calling <code>face_areas</code> to compute the area of each face.</p> </li> <li> <p>Summing the face areas to obtain the total surface area.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>total_area</code> <code>float</code> <p>The total surface area of the mesh.</p> Note <p>This function assumes that the mesh is manifold and orientable. The total area is computed based on the current face areas.</p> See Also <p>face_areas : Computes the areas of individual faces.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def area(self):\n    \"\"\"\n    Computes the total surface area of the mesh.\n\n    This function calculates the total surface area by summing the areas\n    of all faces in the mesh.\n\n    The main logic involves:\n\n    1. Calling `face_areas` to compute the area of each face.\n\n    2. Summing the face areas to obtain the total surface area.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    total_area : float\n        The total surface area of the mesh.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The total area is computed based on the current face areas.\n\n    See Also\n    --------\n    face_areas : Computes the areas of individual faces.\n    \"\"\"\n    A = self.face_areas()\n    A = np.sum(A)\n    return A\n</code></pre>"},{"location":"functions/meshpy/#meshpy.are_boundary_edges","title":"<code>are_boundary_edges(self)</code>","text":"<p>Checks if edges are on the boundary of the mesh.</p> <p>This function returns a boolean array indicating whether each edge is on the boundary.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>is_boundary</code> <code>numpy array (bool)</code> <p>A boolean array where True indicates that the edge is on the boundary.</p> Note <p>This function assumes that the mesh is manifold and orientable. The boundary edges are useful for mesh analysis and processing.</p> See Also <p>boundary_edges : Retrieves the indices of boundary edges.</p> <p>are_boundary_faces : Checks if faces are on the boundary.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def are_boundary_edges(self):\n    \"\"\"\n    Checks if edges are on the boundary of the mesh.\n\n    This function returns a boolean array indicating whether each edge is on the boundary.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    is_boundary : numpy array (bool)\n        A boolean array where True indicates that the edge is on the boundary.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The boundary edges are useful for mesh analysis and processing.\n\n    See Also\n    --------\n    boundary_edges : Retrieves the indices of boundary edges.\n\n    are_boundary_faces : Checks if faces are on the boundary.\n    \"\"\"\n    H = self.halfedges\n    B = H[np.argsort(H[:,5])]\n    B = B[:,1] == -1\n    bound = np.logical_or(B[0::2], B[1::2])\n    return bound\n</code></pre>"},{"location":"functions/meshpy/#meshpy.are_boundary_faces","title":"<code>are_boundary_faces(self)</code>","text":"<p>Checks if faces are on the boundary of the mesh.</p> <p>This function returns a boolean array indicating whether each face is on the boundary.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>is_boundary</code> <code>numpy array (bool)</code> <p>A boolean array where True indicates that the face is on the boundary.</p> Note <p>This function assumes that the mesh is manifold and orientable. The boundary faces are useful for mesh analysis and processing.</p> See Also <p>boundary_faces : Retrieves the indices of boundary faces.</p> <p>are_boundary_edges : Checks if edges are on the boundary.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def are_boundary_faces(self):\n    \"\"\"\n    Checks if faces are on the boundary of the mesh.\n\n    This function returns a boolean array indicating whether each face is on the boundary.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    is_boundary : numpy array (bool)\n        A boolean array where True indicates that the face is on the boundary.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The boundary faces are useful for mesh analysis and processing.\n\n    See Also\n    --------\n    boundary_faces : Retrieves the indices of boundary faces.\n\n    are_boundary_edges : Checks if edges are on the boundary.\n    \"\"\"\n    H = self.halfedges\n    f = np.where(H[:,1] != -1)[0]\n    B = H[H[f,4],1] == -1\n    i = np.argsort(H[f,1])\n    bound = utilities.sum_repeated(B[i], H[f,1])\n    return bound\n</code></pre>"},{"location":"functions/meshpy/#meshpy.boundary_curves","title":"<code>boundary_curves(self, corner_split=False)</code>","text":"<p>Retrieves the boundary curves of the mesh.</p> <p>This function identifies and returns the boundary curves of the mesh,  optionally splitting at corners.</p> <p>Parameters:</p> Name Type Description Default <code>corner_split</code> <code>(bool, optional(default=False))</code> <p>Whether to split boundary curves at corners.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>boundary_curves</code> <code>list of numpy arrays</code> <p>A list of boundary curves, where each curve is an array of vertex indices.</p> Note <p>This function assumes that the mesh is manifold and orientable. The boundary curves are useful for mesh analysis and visualization.</p> See Also <p>boundary_vertices : Retrieves the indices of boundary vertices.</p> <p>boundary_edges : Retrieves the indices of boundary edges.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def boundary_curves(self, corner_split=False):\n    \"\"\"\n    Retrieves the boundary curves of the mesh.\n\n    This function identifies and returns the boundary curves of the mesh, \n    optionally splitting at corners.\n\n    Parameters\n    ----------\n    corner_split : bool, optional (default=False)\n        Whether to split boundary curves at corners.\n\n    Returns\n    -------\n    boundary_curves : list of numpy arrays\n        A list of boundary curves, where each curve is an array of vertex indices.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The boundary curves are useful for mesh analysis and visualization.\n\n    See Also\n    --------\n    boundary_vertices : Retrieves the indices of boundary vertices.\n\n    boundary_edges : Retrieves the indices of boundary edges.\n    \"\"\"\n    H = self.halfedges\n    boundaries = []\n    boundary_halfedges = []\n    for h in range(H.shape[0]):\n        if H[h,1] == -1 and h not in boundary_halfedges:\n            boundary = []\n            h_he = h\n            boundary_halfedges.append(h_he)\n            boundary.append(H[h_he,0])\n            h_he = H[h_he,2]\n            while h_he != h:\n                boundary_halfedges.append(h_he)\n                boundary.append(H[h_he,0])\n                h_he = H[h_he,2]\n            boundaries.append(np.array(boundary))\n    if corner_split:\n        corner_boundaries = []\n        corners = self.mesh_corners()\n        for boundary in boundaries:\n            indices = np.arange(len(boundary))\n            c = indices[np.in1d(boundary, corners)]\n            boundary = np.split(boundary, c)\n            for i in range(len(boundary) - 1):\n                a = boundary[i]\n                boundary[i] = np.insert(a, a.shape ,boundary[i+1][0])\n            if len(boundary) &gt; 1:\n                boundary[0] = np.hstack((boundary[-1], boundary[0]))\n                del boundary[-1]\n            corner_boundaries.extend(boundary)\n        boundaries = corner_boundaries\n    return boundaries\n</code></pre>"},{"location":"functions/meshpy/#meshpy.boundary_curves_halfedges","title":"<code>boundary_curves_halfedges(self, corner_split=False)</code>","text":"<p>Retrieves the boundary curves of the mesh in terms of half-edges.</p> <p>This function identifies and returns the boundary curves of the mesh,  optionally splitting at corners, represented by half-edges.</p> <p>Parameters:</p> Name Type Description Default <code>corner_split</code> <code>(bool, optional(default=False))</code> <p>Whether to split boundary curves at corners.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>boundary_curves</code> <code>list of numpy arrays</code> <p>A list of boundary curves, where each curve is an array of half-edge indices.</p> Note <p>This function assumes that the mesh is manifold and orientable. The boundary curves are useful for mesh analysis and processing.</p> See Also <p>boundary_curves : Retrieves the boundary curves in terms of vertices.</p> <p>boundary_halfedges : Retrieves the indices of boundary half-edges.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def boundary_curves_halfedges(self, corner_split=False):\n    \"\"\"\n    Retrieves the boundary curves of the mesh in terms of half-edges.\n\n    This function identifies and returns the boundary curves of the mesh, \n    optionally splitting at corners, represented by half-edges.\n\n    Parameters\n    ----------\n    corner_split : bool, optional (default=False)\n        Whether to split boundary curves at corners.\n\n    Returns\n    -------\n    boundary_curves : list of numpy arrays\n        A list of boundary curves, where each curve is an array of half-edge indices.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The boundary curves are useful for mesh analysis and processing.\n\n    See Also\n    --------\n    boundary_curves : Retrieves the boundary curves in terms of vertices.\n\n    boundary_halfedges : Retrieves the indices of boundary half-edges.\n    \"\"\"\n    H = self.halfedges\n    boundaries = []\n    visited = []\n    for h in range(H.shape[0]):\n        if H[h,1] == -1 and h not in visited:\n            boundary = []\n            h_he = h\n            boundary.append(h_he)\n            h_he = H[h_he,2]\n            while h_he != h:\n                boundary.append(h_he)\n                h_he = H[h_he,2]\n            boundaries.append(np.array(boundary))\n            visited.extend(boundary)\n    if corner_split:\n        corner_boundaries = []\n        corners = self.mesh_corners()\n        for boundary in boundaries:\n            indices = np.arange(len(boundary))\n            c = indices[np.in1d(H[boundary,0], corners)]\n            boundary = np.split(boundary, c)\n            if len(boundary) &gt; 1:\n                boundary[0] = np.hstack((boundary[-1], boundary[0]))\n                del boundary[-1]\n            corner_boundaries.extend(boundary)\n        boundaries = corner_boundaries\n    return boundaries\n</code></pre>"},{"location":"functions/meshpy/#meshpy.boundary_edges","title":"<code>boundary_edges(self)</code>","text":"<p>Retrieves the indices of boundary edges in the mesh.</p> <p>This function identifies and returns the edges that lie on the boundary of the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>boundary_edges</code> <code>numpy array</code> <p>The indices of edges on the boundary.</p> Note <p>This function assumes that the mesh is manifold and orientable. The boundary edges are useful for mesh analysis and processing.</p> See Also <p>boundary_vertices : Retrieves the indices of boundary vertices.</p> <p>boundary_faces : Retrieves the indices of boundary faces.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def boundary_edges(self):\n    \"\"\"\n    Retrieves the indices of boundary edges in the mesh.\n\n    This function identifies and returns the edges that lie on the boundary of the mesh.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    boundary_edges : numpy array\n        The indices of edges on the boundary.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The boundary edges are useful for mesh analysis and processing.\n\n    See Also\n    --------\n    boundary_vertices : Retrieves the indices of boundary vertices.\n\n    boundary_faces : Retrieves the indices of boundary faces.\n    \"\"\"\n    H = self.halfedges\n    ind = np.where(H[:,1] == -1)\n    e = H[ind,5]\n    e = np.unique(e)\n    return e\n</code></pre>"},{"location":"functions/meshpy/#meshpy.boundary_faces","title":"<code>boundary_faces(self)</code>","text":"<p>Retrieves the indices of boundary faces in the mesh.</p> <p>This function identifies and returns the faces that lie on the boundary of the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>boundary_faces</code> <code>numpy array</code> <p>The indices of faces on the boundary.</p> Note <p>This function assumes that the mesh is manifold and orientable. The boundary faces are useful for mesh analysis and processing.</p> See Also <p>boundary_vertices : Retrieves the indices of boundary vertices.</p> <p>boundary_edges : Retrieves the indices of boundary edges.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def boundary_faces(self):\n    \"\"\"\n    Retrieves the indices of boundary faces in the mesh.\n\n    This function identifies and returns the faces that lie on the boundary of the mesh.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    boundary_faces : numpy array\n        The indices of faces on the boundary.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The boundary faces are useful for mesh analysis and processing.\n\n    See Also\n    --------\n    boundary_vertices : Retrieves the indices of boundary vertices.\n\n    boundary_edges : Retrieves the indices of boundary edges.\n    \"\"\"\n    H = self.halfedges\n    b = self.boundary_halfedges()\n    e = H[H[b,4],1]\n    return e\n</code></pre>"},{"location":"functions/meshpy/#meshpy.boundary_halfedges","title":"<code>boundary_halfedges(self)</code>","text":"<p>Retrieves the indices of boundary half-edges in the mesh.</p> <p>This function identifies and returns the half-edges that lie on the boundary.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>boundary_halfedges</code> <code>numpy array</code> <p>The indices of boundary half-edges.</p> Note <p>This function assumes that the mesh is manifold and orientable. The boundary half-edges are useful for mesh analysis and processing.</p> See Also <p>inner_halfedges : Retrieves the indices of inner half-edges.</p> <p>boundary_edges : Retrieves the indices of boundary edges.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def boundary_halfedges(self):\n    \"\"\"\n    Retrieves the indices of boundary half-edges in the mesh.\n\n    This function identifies and returns the half-edges that lie on the boundary.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    boundary_halfedges : numpy array\n        The indices of boundary half-edges.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The boundary half-edges are useful for mesh analysis and processing.\n\n    See Also\n    --------\n    inner_halfedges : Retrieves the indices of inner half-edges.\n\n    boundary_edges : Retrieves the indices of boundary edges.\n    \"\"\"\n    H = self.halfedges\n    b = np.where(H[:,1] == -1)[0]\n    return b\n</code></pre>"},{"location":"functions/meshpy/#meshpy.boundary_normals","title":"<code>boundary_normals(self)</code>","text":"<p>Computes the normal vectors for boundary edges in the mesh.</p> <p>This function calculates the boundary normals by considering the adjacent faces and edges. For each boundary edge, it computes a normal vector that is perpendicular to the edge and lies in the plane of the adjacent face.</p> <p>The main logic involves:</p> <ol> <li> <p>Identifying boundary edges and their adjacent faces.</p> </li> <li> <p>Computing the cross product of edge vectors and face normals.</p> </li> <li> <p>Normalizing the resulting vectors to obtain unit normals.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>normals</code> <code>numpy array</code> <p>An array of boundary normals, where each normal is a unit vector [nx, ny, nz].</p> Note <p>This function assumes that the mesh is manifold and orientable. The boundary normals are computed based on the current mesh topology and geometry.</p> See Also <p>boundary_edges : Retrieves the indices of boundary edges.</p> <p>edge_normals : Computes the normal vectors for each edge.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def boundary_normals(self):\n    \"\"\"\n    Computes the normal vectors for boundary edges in the mesh.\n\n    This function calculates the boundary normals by considering the adjacent\n    faces and edges. For each boundary edge, it computes a normal vector that\n    is perpendicular to the edge and lies in the plane of the adjacent face.\n\n    The main logic involves:\n\n    1. Identifying boundary edges and their adjacent faces.\n\n    2. Computing the cross product of edge vectors and face normals.\n\n    3. Normalizing the resulting vectors to obtain unit normals.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    normals : numpy array\n        An array of boundary normals, where each normal is a unit vector [nx, ny, nz].\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The boundary normals are computed based on the current mesh topology and geometry.\n\n    See Also\n    --------\n    boundary_edges : Retrieves the indices of boundary edges.\n\n    edge_normals : Computes the normal vectors for each edge.\n    \"\"\"\n    H = self.halfedges\n    b = np.where(H[:,1] == -1)[0]\n    face_normals = self.face_normals()\n    N1 = face_normals[H[H[b,4],1]]\n    N2 = face_normals[H[H[H[b,3],4],1]]\n    normals = np.zeros((self.V, 3))\n    E1 = self.vertices[H[H[b,2],0]] - self.vertices[H[b,0]]\n    E2 = self.vertices[H[b,0]] - self.vertices[H[H[b,3],0]]\n    N = np.cross(N1,E1) + np.cross(N2,E2)\n    N = N / np.linalg.norm(N, axis=1, keepdims=True)\n    normals[H[b,0],:] = N\n    return normals\n</code></pre>"},{"location":"functions/meshpy/#meshpy.boundary_polylines","title":"<code>boundary_polylines(self)</code>","text":"<p>Converts the boundary curves of the mesh to polyline objects.</p> <p>This function creates polyline objects from the boundary curves of the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>polylines</code> <code>list of Polyline objects</code> <p>A list of polyline objects representing the boundary curves.</p> Note <p>This function assumes that the mesh is manifold and orientable. The polylines are useful for visualization and further processing.</p> See Also <p>boundary_curves : Retrieves the boundary curves in terms of vertices.</p> <p>Polyline : A class representing a polyline object.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def boundary_polylines(self):\n    \"\"\"\n    Converts the boundary curves of the mesh to polyline objects.\n\n    This function creates polyline objects from the boundary curves of the mesh.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    polylines : list of Polyline objects\n        A list of polyline objects representing the boundary curves.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The polylines are useful for visualization and further processing.\n\n    See Also\n    --------\n    boundary_curves : Retrieves the boundary curves in terms of vertices.\n\n    Polyline : A class representing a polyline object.\n    \"\"\"\n    polylines = []\n    curves = self.boundary_curves(corner_split=False)\n    for curve in curves:\n        polyline = Polyline(self.vertices[curve,:], closed=True)\n        polyline.corner_tolerance = self.corner_tolerance\n        polylines.append(polyline)\n    return polylines\n</code></pre>"},{"location":"functions/meshpy/#meshpy.boundary_tangents","title":"<code>boundary_tangents(self, normalize=True)</code>","text":"<p>Computes the tangent vectors for boundary edges in the mesh.</p> <p>This function calculates the tangent vectors along the boundary edges. The tangents are computed as the direction vectors of the boundary edges.</p> <p>The main logic involves:</p> <ol> <li> <p>Identifying boundary edges.</p> </li> <li> <p>Computing the direction vectors of these edges.</p> </li> <li> <p>Optionally normalizing the tangent vectors.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>normalize</code> <code>(bool, optional(default=True))</code> <p>Whether to normalize the tangent vectors to unit length.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>tangents</code> <code>numpy array</code> <p>An array of boundary tangents, where each tangent is a vector [tx, ty, tz].</p> Note <p>This function assumes that the mesh is manifold and orientable. The boundary tangents are computed based on the current mesh topology and geometry.</p> See Also <p>boundary_edges : Retrieves the indices of boundary edges.</p> <p>boundary_normals : Computes the normal vectors for boundary edges.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def boundary_tangents(self, normalize=True):\n    \"\"\"\n    Computes the tangent vectors for boundary edges in the mesh.\n\n    This function calculates the tangent vectors along the boundary edges.\n    The tangents are computed as the direction vectors of the boundary edges.\n\n    The main logic involves:\n\n    1. Identifying boundary edges.\n\n    2. Computing the direction vectors of these edges.\n\n    3. Optionally normalizing the tangent vectors.\n\n    Parameters\n    ----------\n    normalize : bool, optional (default=True)\n        Whether to normalize the tangent vectors to unit length.\n\n    Returns\n    -------\n    tangents : numpy array\n        An array of boundary tangents, where each tangent is a vector [tx, ty, tz].\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The boundary tangents are computed based on the current mesh topology and geometry.\n\n    See Also\n    --------\n    boundary_edges : Retrieves the indices of boundary edges.\n\n    boundary_normals : Computes the normal vectors for boundary edges.\n    \"\"\"\n    H = self.halfedges\n    b = np.where(H[:,1] == -1)[0]\n    V1 = self.vertices[H[H[b,3],0]]\n    V2 = self.vertices[H[H[b,2],0]]\n    T = (V2 - V1)\n    if normalize:\n        T = T / np.linalg.norm(T, keepdims=True)\n    else:\n        T = T/2\n    tangents = np.zeros((self.V, 3))\n    tangents[H[b,0],:] = T\n    return tangents\n</code></pre>"},{"location":"functions/meshpy/#meshpy.boundary_vertices","title":"<code>boundary_vertices(self)</code>","text":"<p>Retrieves the indices of boundary vertices in the mesh.</p> <p>This function identifies and returns the vertices that lie on the boundary of the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>boundary_vertices</code> <code>numpy array</code> <p>The indices of vertices on the boundary.</p> Note <p>This function assumes that the mesh is manifold and orientable. The boundary vertices are useful for mesh analysis and processing.</p> See Also <p>boundary_edges : Retrieves the indices of boundary edges.</p> <p>boundary_faces : Retrieves the indices of boundary faces.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def boundary_vertices(self):\n    \"\"\"\n    Retrieves the indices of boundary vertices in the mesh.\n\n    This function identifies and returns the vertices that lie on the boundary of the mesh.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    boundary_vertices : numpy array\n        The indices of vertices on the boundary.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The boundary vertices are useful for mesh analysis and processing.\n\n    See Also\n    --------\n    boundary_edges : Retrieves the indices of boundary edges.\n\n    boundary_faces : Retrieves the indices of boundary faces.\n    \"\"\"\n    H = self.halfedges\n    b = np.where(H[:,1] == -1)[0]\n    v = H[b,0]\n    return v\n</code></pre>"},{"location":"functions/meshpy/#meshpy.bounding_box","title":"<code>bounding_box(self)</code>","text":"<p>Computes the axis-aligned bounding box of the mesh.</p> <p>This function calculates the minimum and maximum coordinates of the mesh along each axis (x, y, z).</p> <p>The main logic involves:</p> <ol> <li> <p>Finding the minimum and maximum x, y, and z coordinates of all vertices.</p> </li> <li> <p>Returning the bounding box as a list of ranges for each axis.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>bbox</code> <code>list of tuples</code> <p>The bounding box, represented as [(xmin, xmax), (ymin, ymax), (zmin, zmax)].</p> Note <p>This function assumes that the mesh vertices are valid and non-empty. The bounding box is computed based on the current vertex positions.</p> See Also <p>mesh_center : Computes the geometric center of the mesh.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def bounding_box(self):\n    \"\"\"\n    Computes the axis-aligned bounding box of the mesh.\n\n    This function calculates the minimum and maximum coordinates of the mesh\n    along each axis (x, y, z).\n\n    The main logic involves:\n\n    1. Finding the minimum and maximum x, y, and z coordinates of all vertices.\n\n    2. Returning the bounding box as a list of ranges for each axis.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    bbox : list of tuples\n        The bounding box, represented as [(xmin, xmax), (ymin, ymax), (zmin, zmax)].\n\n    Note\n    ----\n    This function assumes that the mesh vertices are valid and non-empty.\n    The bounding box is computed based on the current vertex positions.\n\n    See Also\n    --------\n    mesh_center : Computes the geometric center of the mesh.\n    \"\"\"\n    Xmin = np.min(self.vertices[:,0])\n    Xmax = np.max(self.vertices[:,0])\n    Ymin = np.min(self.vertices[:,1])\n    Ymax = np.max(self.vertices[:,1])\n    Zmin = np.min(self.vertices[:,2])\n    Zmax = np.max(self.vertices[:,2])\n    return ([Xmin, Xmax], [Ymin, Ymax], [Zmin, Zmax])\n</code></pre>"},{"location":"functions/meshpy/#meshpy.cell_arrays","title":"<code>cell_arrays(self)</code>","text":"<p>Converts the mesh faces to a cell array format.</p> <p>This function returns the faces in a cell array format, where each face is  represented by its vertices and a length indicator.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>cells</code> <code>numpy array</code> <p>The cell array representation of the mesh faces.</p> <code>cell_types</code> <code>numpy array</code> <p>The types of cells (e.g., triangles, quads).</p> Note <p>This function assumes that the mesh is manifold and orientable. The cell arrays are useful for visualization and further processing.</p> See Also <p>faces_list : Retrieves the list of faces.</p> <p>face_lengths : Computes the number of edges for each face.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def cell_arrays(self):\n    \"\"\"\n    Converts the mesh faces to a cell array format.\n\n    This function returns the faces in a cell array format, where each face is \n    represented by its vertices and a length indicator.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    cells : numpy array\n        The cell array representation of the mesh faces.\n    cell_types : numpy array\n        The types of cells (e.g., triangles, quads).\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The cell arrays are useful for visualization and further processing.\n\n    See Also\n    --------\n    faces_list : Retrieves the list of faces.\n\n    face_lengths : Computes the number of edges for each face.\n    \"\"\"\n    H = self.halfedges\n    i  = self.face_ordered_halfedges()\n    vi = H[i,0]\n    f  = H[i,1]\n    i = np.ones((f.shape[0]), 'i')\n    j = np.arange(f.shape[0])\n    _, k = np.unique(f, True)\n    lengths = utilities.sum_repeated(i, f)\n    index = j[k]\n    cells = np.insert(vi, index, lengths)\n    cell_types = lengths - 3\n    cell_types[np.where(cell_types[:] &gt; 2)[0]] = 2\n    return cells, cell_types\n</code></pre>"},{"location":"functions/meshpy/#meshpy.closest_vertices","title":"<code>closest_vertices(self, points, make_tree=False)</code>","text":"<p>Finds the closest vertices in the mesh to a set of query points.</p> <p>This function uses a k-d tree to efficiently find the closest vertices  in the mesh to the given points. If the k-d tree does not exist, it will  be constructed automatically.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>numpy array</code> <p>An array of query points [x, y, z].</p> required <code>make_tree</code> <code>(bool, optional(default=False))</code> <p>Whether to force the reconstruction of the k-d tree.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>closest</code> <code>numpy array</code> <p>The indices of the closest vertices in the mesh.</p> Note <p>This function assumes that the mesh vertices are valid and non-empty. The k-d tree is used to accelerate nearest-neighbor queries.</p> See Also <p>make_kdtree : Constructs a k-d tree from the mesh vertices.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def closest_vertices(self, points, make_tree=False):\n    \"\"\"\n    Finds the closest vertices in the mesh to a set of query points.\n\n    This function uses a k-d tree to efficiently find the closest vertices \n    in the mesh to the given points. If the k-d tree does not exist, it will \n    be constructed automatically.\n\n    Parameters\n    ----------\n    points : numpy array\n        An array of query points [x, y, z].\n    make_tree : bool, optional (default=False)\n        Whether to force the reconstruction of the k-d tree.\n\n    Returns\n    -------\n    closest : numpy array\n        The indices of the closest vertices in the mesh.\n\n    Note\n    ----\n    This function assumes that the mesh vertices are valid and non-empty.\n    The k-d tree is used to accelerate nearest-neighbor queries.\n\n    See Also\n    --------\n    make_kdtree : Constructs a k-d tree from the mesh vertices.\n    \"\"\"\n    if self._kdtree is None:\n        self.make_kdtree()\n    elif make_tree:\n        self.make_kdtree()\n    closest = self._kdtree.query(points)[1]\n    return closest\n</code></pre>"},{"location":"functions/meshpy/#meshpy.collapse_edge","title":"<code>collapse_edge(self, edge_index)</code>","text":"<p>Collapses the specified edge into a single vertex.</p> <p>This function merges the two vertices of the specified edge into a single vertex. The resulting vertex replaces the original vertices in the mesh topology.</p> <p>The main logic involves:</p> <ol> <li> <p>Identifying the half-edges associated with the edge.</p> </li> <li> <p>Merging the two vertices of the edge into a single vertex.</p> </li> <li> <p>Updating the half-edge structure to maintain mesh consistency.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>edge_index</code> <code>int</code> <p>The index of the edge to be collapsed.</p> required <p>Returns:</p> Name Type Description <code>success</code> <code>bool</code> <p>Whether the edge collapse was successful.</p> Note <p>This function assumes that the specified edge exists in the mesh. The edge collapse is only performed if it results in a valid mesh topology.</p> See Also <p>split_edge : Splits an edge into two edges.</p> <p>flip_edge : Flips an edge by swapping its adjacent faces.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def collapse_edge(self, edge_index):\n    \"\"\"\n    Collapses the specified edge into a single vertex.\n\n    This function merges the two vertices of the specified edge into a single vertex.\n    The resulting vertex replaces the original vertices in the mesh topology.\n\n    The main logic involves:\n\n    1. Identifying the half-edges associated with the edge.\n\n    2. Merging the two vertices of the edge into a single vertex.\n\n    3. Updating the half-edge structure to maintain mesh consistency.\n\n    Parameters\n    ----------\n    edge_index : int\n        The index of the edge to be collapsed.\n\n    Returns\n    -------\n    success : bool\n        Whether the edge collapse was successful.\n\n    Note\n    ----\n    This function assumes that the specified edge exists in the mesh.\n    The edge collapse is only performed if it results in a valid mesh topology.\n\n    See Also\n    --------\n    split_edge : Splits an edge into two edges.\n\n    flip_edge : Flips an edge by swapping its adjacent faces.\n    \"\"\"\n    h = self.edge_halfedge(edge_index)\n    if not self.is_halfedge_bounding_tri_faces(h):\n        return False\n    self._open_trash()\n    self._collapse_halfedge(h)\n    self._clean()\n</code></pre>"},{"location":"functions/meshpy/#meshpy.collapse_edges","title":"<code>collapse_edges(self, min_length)</code>","text":"<p>Collapses edges in the mesh that are shorter than a specified minimum length.</p> <p>This function iterates over all edges and collapses those that are shorter than  the specified minimum length. The two vertices of each collapsed edge are merged  into a single vertex, and the mesh topology is updated accordingly.</p> <p>The main logic involves:</p> <ol> <li> <p>Iterating over all edges and checking their lengths.</p> </li> <li> <p>Collapsing edges that are shorter than the minimum length.</p> </li> <li> <p>Updating the mesh topology with merged vertices.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>min_length</code> <code>float</code> <p>The minimum allowed length for edges.</p> required <p>Returns:</p> Name Type Description <code>success</code> <code>bool</code> <p>Whether the edge collapse was successful.</p> Note <p>This function assumes that the mesh is a triangular mesh. The mesh topology is updated to ensure all edges are longer than the specified length.</p> See Also <p>split_edges : Splits edges that exceed a specified maximum length.</p> <p>equalize_valences : Balances vertex valences in the mesh.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def collapse_edges(self, min_length):\n    \"\"\"\n    Collapses edges in the mesh that are shorter than a specified minimum length.\n\n    This function iterates over all edges and collapses those that are shorter than \n    the specified minimum length. The two vertices of each collapsed edge are merged \n    into a single vertex, and the mesh topology is updated accordingly.\n\n    The main logic involves:\n\n    1. Iterating over all edges and checking their lengths.\n\n    2. Collapsing edges that are shorter than the minimum length.\n\n    3. Updating the mesh topology with merged vertices.\n\n    Parameters\n    ----------\n    min_length : float\n        The minimum allowed length for edges.\n\n    Returns\n    -------\n    success : bool\n        Whether the edge collapse was successful.\n\n    Note\n    ----\n    This function assumes that the mesh is a triangular mesh.\n    The mesh topology is updated to ensure all edges are longer than the specified length.\n\n    See Also\n    --------\n    split_edges : Splits edges that exceed a specified maximum length.\n\n    equalize_valences : Balances vertex valences in the mesh.\n    \"\"\"\n    if not self.is_triangular_mesh():\n        return False\n    H = self.halfedges\n    _, he = np.unique(H[:,5], return_index=True)\n    self._open_trash()\n    for h in he:\n        if self._is_culled_halfedge(h):\n            h = H[h,4]\n        if self.halfedge_length(h) &lt; min_length:\n            self._collapse_halfedge(h)\n    self._clean()\n    return True\n</code></pre>"},{"location":"functions/meshpy/#meshpy.catmull_clark","title":"<code>catmull_clark(self, steps=1)</code>","text":"<p>Applies the Catmull-Clark subdivision algorithm to the mesh.</p> <p>This function refines the mesh by subdividing each face into smaller faces  using the Catmull-Clark rules. It works for both triangular and quadrilateral meshes.</p> <p>The main logic involves:</p> <ol> <li> <p>Iterating over each face and its vertices.</p> </li> <li> <p>Computing new vertex positions using the Catmull-Clark weights.</p> </li> <li> <p>Creating new faces and updating the mesh topology.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>steps</code> <code>(int, optional(default=1))</code> <p>The number of subdivision steps to apply.</p> <code>1</code> <p>Returns:</p> Type Description <code>None</code> <p>The mesh is updated within the class instance.</p> Note <p>This function assumes that the mesh is manifold and orientable. The Catmull-Clark algorithm is applicable to both triangular and quadrilateral meshes.</p> See Also <p>loop : Applies the Loop subdivision algorithm (for triangular meshes).</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def catmull_clark(self, steps=1):\n    \"\"\"\n    Applies the Catmull-Clark subdivision algorithm to the mesh.\n\n    This function refines the mesh by subdividing each face into smaller faces \n    using the Catmull-Clark rules. It works for both triangular and quadrilateral meshes.\n\n    The main logic involves:\n\n    1. Iterating over each face and its vertices.\n\n    2. Computing new vertex positions using the Catmull-Clark weights.\n\n    3. Creating new faces and updating the mesh topology.\n\n    Parameters\n    ----------\n    steps : int, optional (default=1)\n        The number of subdivision steps to apply.\n\n    Returns\n    -------\n    None\n        The mesh is updated within the class instance.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The Catmull-Clark algorithm is applicable to both triangular and quadrilateral meshes.\n\n    See Also\n    --------\n    loop : Applies the Loop subdivision algorithm (for triangular meshes).\n    \"\"\"\n    def _catmull_clark(self):\n        V = self.V\n        E = self.E\n        H = self.halfedges\n        h = self.inner_halfedges()\n        v1 = H[h,0]\n        v2 = H[h,5] + V\n        v3 = H[h,1] + V + E\n        v4 = H[H[h,3],5] + V\n        new_faces = (np.array([v1, v2, v3, v4]).T).tolist()\n        v  = H[:,0]\n        i  = np.argsort(v)\n        v  = v[i]\n        v1 = H[H[:,4],0][i]\n        v2 = H[H[H[:,2],4],0][i]\n        s = np.ones(len(v))\n        l = utilities.sum_repeated(s,v)\n        d = 1. / (4*l**2)\n        c = 3. / (2*l**2)\n        e = 1 - 7./(4*l)\n        c = np.array([c,c,c]).T\n        d = np.array([d,d,d]).T\n        e = np.array([e,e,e]).T\n        v1 = utilities.sum_repeated(self.vertices[v1], v)\n        v2 = utilities.sum_repeated(self.vertices[v2], v)\n        old_vertices = c*v1 + d*v2 + e*self.vertices\n        _, e = np.unique(H[:,5], True)\n        v1 = self.vertices[H[e,0]]\n        v2 = self.vertices[H[H[e,4],0]]\n        v3 = self.vertices[H[H[e,3],0]]\n        v4 = self.vertices[H[H[H[e,4],3],0]]\n        v5 = self.vertices[H[H[H[e,2],2],0]]\n        v6 = self.vertices[H[H[H[H[e,4],2],2],0]]\n        be = self.boundary_edges()\n        v3[be] = v5[be] = v1[be]\n        v4[be] = v6[be] = v2[be]\n        mid_points = 3./8*(v1 + v2) + 1./16*(v3 + v4 + v5 + v6)\n        bh = np.where(H[:,1] == -1)[0]\n        v0 = self.vertices[H[bh,0]]\n        v5 = self.vertices[H[H[bh,3],0]]\n        v6 = self.vertices[H[H[bh,2],0]]\n        old_vertices[H[bh,0]] = 1./8*v6 + 1./8*v5 + 3./4*v0\n        barycenters = self.face_barycenters()\n        new_vertices = np.vstack((old_vertices, mid_points, barycenters))\n        self.make_mesh(new_vertices, new_faces)\n    for i in range(steps):\n        self._catmull_clark()\n</code></pre>"},{"location":"functions/meshpy/#meshpy.cut","title":"<code>cut(self, vertex_index)</code>","text":"<p>Cuts the mesh along a boundary edge starting from a specified vertex.</p> <p>This function modifies the mesh topology by splitting a boundary edge and creating new vertices and half-edges. The cut is performed along the boundary until another boundary vertex is reached.</p> <p>The main logic involves:</p> <ol> <li> <p>Identifying the boundary edge starting from the specified vertex.</p> </li> <li> <p>Iteratively splitting the boundary edge and updating the half-edge structure.</p> </li> <li> <p>Creating new vertices and half-edges to maintain mesh consistency.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>vertex_index</code> <code>int</code> <p>The index of the vertex where the cut starts.</p> required <p>Returns:</p> Name Type Description <code>Hcouple</code> <code>numpy array</code> <p>An array of half-edge pairs representing the cut edges.</p> Note <p>This function assumes that the specified vertex is on the boundary of the mesh. The mesh must be manifold and orientable for the cut operation to be valid.</p> See Also <p>make_simply_connected : Simplifies the mesh topology by making it simply connected.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def cut(self, vertex_index):\n    \"\"\"\n    Cuts the mesh along a boundary edge starting from a specified vertex.\n\n    This function modifies the mesh topology by splitting a boundary edge and\n    creating new vertices and half-edges. The cut is performed along the boundary\n    until another boundary vertex is reached.\n\n    The main logic involves:\n\n    1. Identifying the boundary edge starting from the specified vertex.\n\n    2. Iteratively splitting the boundary edge and updating the half-edge structure.\n\n    3. Creating new vertices and half-edges to maintain mesh consistency.\n\n    Parameters\n    ----------\n    vertex_index : int\n        The index of the vertex where the cut starts.\n\n    Returns\n    -------\n    Hcouple : numpy array\n        An array of half-edge pairs representing the cut edges.\n\n    Note\n    ----\n    This function assumes that the specified vertex is on the boundary of the mesh.\n    The mesh must be manifold and orientable for the cut operation to be valid.\n\n    See Also\n    --------\n    make_simply_connected : Simplifies the mesh topology by making it simply connected.\n    \"\"\"\n    boundary = self.boundary_vertices()\n    hc1 = []\n    hc2 = []\n    if not np.in1d(vertex_index, boundary)[0]:\n        return False\n    V = self.V\n    E = self.E\n    W = 2*E\n    H = self.halfedges\n    v, vj, l = self.vertex_ring_vertices_iterators(return_lengths=True)\n    v0 = vertex_index\n    vvv = [v0]\n    if l[v0] &lt; 3:\n        return False\n    h = np.where(H[:,0] == v0)[0]\n    h = h[np.where(H[h,1] == -1)[0]]\n    h0 = copy.copy(h)\n    H[h0,0] = V\n    n_v1 = np.copy(self.vertices[v0])\n    for i in range(l[v0]//2):\n        h = H[H[h,4],2]\n        H[h,0] = V\n    hc1.append(h); hc2.append(H[h,4])\n    v1 = H[H[h,4],0][0]\n    n_h1 = np.array([[V+1, -1, h0, W+2, h, E]], 'i')\n    n_h2 = np.array([[v0, -1, W+3, H[h0,3], H[h,4], H[h,5]]], 'i')\n    H[H[h,4],4] = W+1\n    H[h,0] = V\n    H[h,4] = W\n    H[h,5] = E\n    H[H[h0,3],2] = W+1\n    H[h0,3] = W\n    H = np.vstack((H, n_h1, n_h2))\n    self._vertices = np.vstack((self.vertices, n_v1))\n    W += 2\n    E += 1\n    V += 1\n    while not np.in1d(v1, boundary)[0]:\n        v0 = v1\n        h = H[h,2]\n        H[h,0] = V\n        n_v1 = np.copy(self.vertices[v0])\n        for i in range(int(l[v0]//2 - 1)):\n            h = H[H[h,4],2]\n            H[h,0] = V\n        hc1.append(h); hc2.append(H[h,4])\n        v1 = H[H[h,4],0][0]\n        vvv.append(v0)\n        n_h1 = np.array([[V+1, -1, W-2, W+2, h, E]], 'i')\n        n_h2 = np.array([[v0, -1, W+3, W-1, H[h,4], H[h,5]]], 'i')\n        H[H[h,4],4] = W+1\n        H[h,0] = V\n        H[h,4] = W\n        H[h,5] = E\n        H = np.vstack((H, n_h1, n_h2))\n        self._vertices = np.vstack((self.vertices, n_v1))\n        W += 2\n        E += 1\n        V += 1\n    W -= 2\n    n_v1 = np.copy(self.vertices[v0])\n    while H[h,1] != -1:\n        h = H[H[h,2],4]\n        H[H[h,4],0] = V\n    H[W+1,2] = copy.copy(H[h,2])\n    H[H[h,2],3] = W+1\n    H[h,2] = W\n    H[W,3] = h\n    self._halfedges = H\n    n_v1 = np.copy(self.vertices[v1])\n    self._vertices = np.vstack((self.vertices, n_v1))\n    self.topology_update()\n    Hcouple = np.array(hc2)\n    '''\n    from geometrylab import vtkplot\n    pl_m = vtkplot.Edges(self)\n    pl_p = vtkplot.Points(self.vertices[vvv])\n    vtkplot.view([pl_m,pl_p])\n    vtkplot.check(self)\n    '''\n    return Hcouple\n</code></pre>"},{"location":"functions/meshpy/#meshpy.delete_edge","title":"<code>delete_edge(self, edge_index)</code>","text":"<p>Deletes a specified edge from the mesh.</p> <p>This function removes the specified edge and updates the mesh topology. It also removes any half-edges and vertices that are no longer connected.</p> <p>The main logic involves:</p> <ol> <li> <p>Identifying the half-edges associated with the edge to be deleted.</p> </li> <li> <p>Removing the edge and updating the half-edge structure.</p> </li> <li> <p>Cleaning up any unconnected vertices and edges.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>edge_index</code> <code>int</code> <p>The index of the edge to be deleted.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The mesh is updated within the class instance.</p> Note <p>This function assumes that the specified edge exists in the mesh. The mesh topology is updated to maintain consistency after deletion.</p> See Also <p>delete_faces : Deletes specified faces from the mesh.</p> <p>delete_unconnected_vertices : Removes unconnected vertices from the mesh.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def delete_edge(self, edge_index):\n    \"\"\"\n    Deletes a specified edge from the mesh.\n\n    This function removes the specified edge and updates the mesh topology.\n    It also removes any half-edges and vertices that are no longer connected.\n\n    The main logic involves:\n\n    1. Identifying the half-edges associated with the edge to be deleted.\n\n    2. Removing the edge and updating the half-edge structure.\n\n    3. Cleaning up any unconnected vertices and edges.\n\n    Parameters\n    ----------\n    edge_index : int\n        The index of the edge to be deleted.\n\n    Returns\n    -------\n    None\n        The mesh is updated within the class instance.\n\n    Note\n    ----\n    This function assumes that the specified edge exists in the mesh.\n    The mesh topology is updated to maintain consistency after deletion.\n\n    See Also\n    --------\n    delete_faces : Deletes specified faces from the mesh.\n\n    delete_unconnected_vertices : Removes unconnected vertices from the mesh.\n    \"\"\"\n    h = self.edge_halfedge(edge_index)\n    self._open_trash()\n    self._delete_halfedge(h)\n    self._clean()\n</code></pre>"},{"location":"functions/meshpy/#meshpy.delete_faces","title":"<code>delete_faces(self, faces)</code>","text":"<p>Deletes specified faces from the mesh.</p> <p>This function removes the specified faces and updates the mesh topology. It also removes any half-edges and vertices that are no longer connected.</p> <p>The main logic involves:</p> <ol> <li> <p>Identifying the half-edges and vertices associated with the faces to be deleted.</p> </li> <li> <p>Removing the faces and updating the half-edge structure.</p> </li> <li> <p>Cleaning up any unconnected vertices and edges.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>faces</code> <code>int or list of int</code> <p>The indices of the faces to be deleted.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The mesh is updated within the class instance.</p> Note <p>This function assumes that the specified faces exist in the mesh. The mesh topology is updated to maintain consistency after deletion.</p> See Also <p>delete_unconnected_vertices : Removes unconnected vertices from the mesh.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def delete_faces(self, faces):\n    \"\"\"\n    Deletes specified faces from the mesh.\n\n    This function removes the specified faces and updates the mesh topology.\n    It also removes any half-edges and vertices that are no longer connected.\n\n    The main logic involves:\n\n    1. Identifying the half-edges and vertices associated with the faces to be deleted.\n\n    2. Removing the faces and updating the half-edge structure.\n\n    3. Cleaning up any unconnected vertices and edges.\n\n    Parameters\n    ----------\n    faces : int or list of int\n        The indices of the faces to be deleted.\n\n    Returns\n    -------\n    None\n        The mesh is updated within the class instance.\n\n    Note\n    ----\n    This function assumes that the specified faces exist in the mesh.\n    The mesh topology is updated to maintain consistency after deletion.\n\n    See Also\n    --------\n    delete_unconnected_vertices : Removes unconnected vertices from the mesh.\n    \"\"\"\n    if type(faces) is int:\n        faces = [faces]\n    H = self.halfedges\n    self._open_trash()\n    self._cull_faces(faces)\n    hf = np.arange(H.shape[0])[np.in1d(H[:,1], faces)]\n    bh = hf[H[H[hf,4],1] == -1]\n    self._cull_halfedges(bh)\n    self._cull_halfedges(H[bh,4])\n    self._cull_edges(H[bh,5])\n    dh = hf[np.in1d(H[hf,4], hf)]\n    self._cull_halfedges(dh)\n    self._cull_halfedges(H[dh,4])\n    self._cull_edges(H[dh,5])\n    H[hf,1] = -1\n    self._clean()\n    self.delete_unconnected_vertices()\n</code></pre>"},{"location":"functions/meshpy/#meshpy.delete_unconnected_vertices","title":"<code>delete_unconnected_vertices(self)</code>","text":"<p>Removes unconnected vertices from the mesh.</p> <p>This function identifies and deletes vertices that are not part of any face. It updates the mesh topology accordingly.</p> <p>The main logic involves:</p> <ol> <li> <p>Identifying vertices that are not referenced by any half-edge.</p> </li> <li> <p>Removing these vertices from the mesh.</p> </li> <li> <p>Updating the vertex indices in the half-edge structure.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The mesh is updated within the class instance.</p> Note <p>This function assumes that the mesh is manifold and orientable. The mesh topology is updated to maintain consistency after deletion.</p> See Also <p>delete_faces : Deletes specified faces from the mesh.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def delete_unconnected_vertices(self):\n    \"\"\"\n    Removes unconnected vertices from the mesh.\n\n    This function identifies and deletes vertices that are not part of any face.\n    It updates the mesh topology accordingly.\n\n    The main logic involves:\n\n    1. Identifying vertices that are not referenced by any half-edge.\n\n    2. Removing these vertices from the mesh.\n\n    3. Updating the vertex indices in the half-edge structure.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    None\n        The mesh is updated within the class instance.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The mesh topology is updated to maintain consistency after deletion.\n\n    See Also\n    --------\n    delete_faces : Deletes specified faces from the mesh.\n    \"\"\"\n    H = self.halfedges\n    v = np.arange(len(self.vertices))\n    cull = np.invert(np.in1d(v, H[:,0]))\n    self._open_trash()\n    self._cull_vertices(v[cull])\n    self._clean()\n</code></pre>"},{"location":"functions/meshpy/#meshpy.dual_mesh","title":"<code>dual_mesh(self, make_boundary=True)</code>","text":"<p>Constructs the dual mesh of the current mesh.</p> <p>This function creates a new mesh where each face in the original mesh corresponds to a vertex in the dual mesh, and each vertex in the original mesh corresponds to a face in the dual mesh.</p> <p>The main logic involves:</p> <ol> <li> <p>Computing the barycenters of the original faces to define the dual vertices.</p> </li> <li> <p>Creating new faces in the dual mesh based on the original vertex connectivity.</p> </li> <li> <p>Handling boundary cases if <code>make_boundary</code> is True.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>make_boundary</code> <code>(bool, optional(default=True))</code> <p>Whether to create boundary faces in the dual mesh.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dual_mesh</code> <code>Mesh</code> <p>The dual mesh instance.</p> Note <p>This function assumes that the input mesh is manifold and orientable. The dual mesh is constructed based on the current mesh topology and geometry.</p> See Also <p>exploded_mesh : Creates an exploded version of the mesh.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def dual_mesh(self, make_boundary=True):\n    \"\"\"\n    Constructs the dual mesh of the current mesh.\n\n    This function creates a new mesh where each face in the original mesh corresponds\n    to a vertex in the dual mesh, and each vertex in the original mesh corresponds\n    to a face in the dual mesh.\n\n    The main logic involves:\n\n    1. Computing the barycenters of the original faces to define the dual vertices.\n\n    2. Creating new faces in the dual mesh based on the original vertex connectivity.\n\n    3. Handling boundary cases if `make_boundary` is True.\n\n    Parameters\n    ----------\n    make_boundary : bool, optional (default=True)\n        Whether to create boundary faces in the dual mesh.\n\n    Returns\n    -------\n    dual_mesh : Mesh\n        The dual mesh instance.\n\n    Note\n    ----\n    This function assumes that the input mesh is manifold and orientable.\n    The dual mesh is constructed based on the current mesh topology and geometry.\n\n    See Also\n    --------\n    exploded_mesh : Creates an exploded version of the mesh.\n    \"\"\"\n    H = self.halfedges\n    HD = np.copy(H)\n    b = np.where(H[:,1] == -1)[0]\n    B = b.shape[0]\n    fb = np.arange(B) + self.F\n    hb1 = np.arange(B) + 2*self.E\n    hb2 = np.arange(B) + B + 2*self.E\n    eb = np.arange(B) + self.E\n    HD[b,1] = np.copy(fb)\n    HD[b,3] = np.copy(hb1)\n    HD[H[b,3],2] = np.copy(hb2)\n    Hb1 = np.zeros((B,6), dtype=int)\n    Hb2 = np.zeros((B,6), dtype=int)\n    Hb1[:,0] = -1\n    Hb2[:,0] = H[b,0]\n    Hb1[:,1] = fb\n    Hb2[:,1] = HD[H[b,3],1]\n    Hb1[:,2] = b\n    Hb2[:,2] = HD[H[b,3],3]#HD[H[b,2],2]##\n    Hb1[:,3] = HD[b,2]\n    Hb2[:,3] = H[b,3]\n    Hb1[:,4] = hb2\n    Hb2[:,4] = hb1\n    Hb1[:,5] = eb\n    Hb2[:,5] = eb\n    HD = np.vstack((HD, Hb1, Hb2))\n    HR = np.copy(HD)\n    HD[:,0] = HR[HR[:,4],1]\n    HD[:,1] = HR[:,0]\n    HD[:,2] = HR[HR[:,3],4]\n    HD[:,3] = HR[HR[:,4],2]\n    dual_vertices = self.face_barycenters()\n    face_normals = self.face_normals()\n    edge_vec = self.vertices[H[b,0]] - self.vertices[H[H[b,2],0]]\n    normals = np.cross(edge_vec, face_normals[H[H[b,4],1]])\n    new_vertices = self.edge_mid_points()[H[b,5]] + normals/2\n    dual_vertices = np.vstack((dual_vertices, new_vertices))\n    dual_mesh = Mesh()\n    dual_mesh._halfedges = HD\n    dual_mesh._vertices = dual_vertices\n    dual_mesh.topology_update()\n    return dual_mesh\n</code></pre>"},{"location":"functions/meshpy/#meshpy.edge","title":"<code>edge(self, halfedge_index=None)</code>","text":"<p>Retrieves the edge associated with a specified half-edge.</p> <p>This function returns the index of the edge that the specified half-edge belongs to.</p> <p>Parameters:</p> Name Type Description Default <code>halfedge_index</code> <code>(int, optional(default=None))</code> <p>The index of the half-edge. If None, returns the edge indices for all half-edges.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>edge_index</code> <code>int or numpy array</code> <p>The index of the edge associated with the specified half-edge, or an array of edge indices for all half-edges.</p> Note <p>This function assumes that the specified half-edge exists in the mesh. The edge index is shared by the specified half-edge and its twin.</p> See Also <p>origin : Retrieves the origin vertex of a half-edge.</p> <p>face : Retrieves the face associated with a half-edge.</p> <p>twin : Retrieves the twin half-edge.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def edge(self, halfedge_index=None):\n    \"\"\"\n    Retrieves the edge associated with a specified half-edge.\n\n    This function returns the index of the edge that the specified half-edge belongs to.\n\n    Parameters\n    ----------\n    halfedge_index : int, optional (default=None)\n        The index of the half-edge. If None, returns the edge indices for all half-edges.\n\n    Returns\n    -------\n    edge_index : int or numpy array\n        The index of the edge associated with the specified half-edge, or an array of edge indices for all half-edges.\n\n    Note\n    ----\n    This function assumes that the specified half-edge exists in the mesh.\n    The edge index is shared by the specified half-edge and its twin.\n\n    See Also\n    --------\n    origin : Retrieves the origin vertex of a half-edge.\n\n    face : Retrieves the face associated with a half-edge.\n\n    twin : Retrieves the twin half-edge.\n    \"\"\"\n    H = self.halfedges\n    if halfedge_index is None:\n        return H[:,5]\n    return H[halfedge_index,5]\n</code></pre>"},{"location":"functions/meshpy/#meshpy.edge_angles","title":"<code>edge_angles(self)</code>","text":"<p>Computes the dihedral angles for each edge in the mesh.</p> <p>This function calculates the dihedral angle between adjacent faces for each edge. The dihedral angle is the angle between the face normals.</p> <p>The main logic involves:</p> <ol> <li> <p>Iterating over each edge and its adjacent faces.</p> </li> <li> <p>Computing the dot product of the face normals.</p> </li> <li> <p>Calculating the dihedral angle using the arccosine function.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>angles</code> <code>numpy array</code> <p>An array of dihedral angles for each edge.</p> Note <p>This function assumes that the mesh is manifold and orientable. The dihedral angles are computed based on the current face normals.</p> See Also <p>edge_angle_vectors : Computes the angle vectors for each edge.</p> <p>face_normals : Computes the normal vectors of all faces.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def edge_angles(self):\n    \"\"\"\n    Computes the dihedral angles for each edge in the mesh.\n\n    This function calculates the dihedral angle between adjacent faces for each edge.\n    The dihedral angle is the angle between the face normals.\n\n    The main logic involves:\n\n    1. Iterating over each edge and its adjacent faces.\n\n    2. Computing the dot product of the face normals.\n\n    3. Calculating the dihedral angle using the arccosine function.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    angles : numpy array\n        An array of dihedral angles for each edge.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The dihedral angles are computed based on the current face normals.\n\n    See Also\n    --------\n    edge_angle_vectors : Computes the angle vectors for each edge.\n\n    face_normals : Computes the normal vectors of all faces.\n    \"\"\"\n    sin = self.edge_sine_vectors()\n    beta = np.arcsin(np.linalg.norm(sin, axis=1))\n    return beta\n</code></pre>"},{"location":"functions/meshpy/#meshpy.edge_cotangents_weigths","title":"<code>edge_cotangents_weigths(self)</code>","text":"<p>Computes the cotangent weights for each edge in the mesh.</p> <p>This function calculates the cotangent weights based on the angles  between adjacent edges. Cotangent weights are commonly used in  discrete differential geometry for various computations.</p> <p>The main logic involves:</p> <ol> <li> <p>Iterating over each edge and its adjacent faces.</p> </li> <li> <p>Computing the cotangent of the angles between adjacent edges.</p> </li> <li> <p>Summing the cotangent weights for each edge.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>cotangent_weights</code> <code>numpy array</code> <p>The cotangent weights for each edge.</p> Note <p>This function assumes that the mesh is manifold and orientable. The cotangent weights are computed based on the current mesh topology and geometry.</p> See Also <p>mean_curvature_normal : Computes the mean curvature normal using cotangent weights.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def edge_cotangents_weigths(self):\n    \"\"\"\n    Computes the cotangent weights for each edge in the mesh.\n\n    This function calculates the cotangent weights based on the angles \n    between adjacent edges. Cotangent weights are commonly used in \n    discrete differential geometry for various computations.\n\n    The main logic involves:\n\n    1. Iterating over each edge and its adjacent faces.\n\n    2. Computing the cotangent of the angles between adjacent edges.\n\n    3. Summing the cotangent weights for each edge.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    cotangent_weights : numpy array\n        The cotangent weights for each edge.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The cotangent weights are computed based on the current mesh topology and geometry.\n\n    See Also\n    --------\n    mean_curvature_normal : Computes the mean curvature normal using cotangent weights.\n    \"\"\"\n    H = self.halfedges\n    V0 = self.vertices[H[:,0]]\n    V1 = self.vertices[H[H[:,2],0]]\n    V2 = self.vertices[H[H[:,3],0]]\n    E1 = (V0 - V2) / np.linalg.norm(V0 - V2, axis=1, keepdims=True)\n    E2 = (V1 - V2) / np.linalg.norm(V1 - V2, axis=1, keepdims=True)\n    cos = np.einsum('ij,ij-&gt;i', E1, E2)\n    sin = np.linalg.norm(np.cross(E1, E2, axis=1), axis=1)\n    cotan = cos / sin\n    h = np.argsort(H[:,5])\n    cotan = cotan[h]\n    e = H[h,5]\n    cotan = utilities.sum_repeated(cotan, e)\n    return cotan / 2\n</code></pre>"},{"location":"functions/meshpy/#meshpy.edge_faces","title":"<code>edge_faces(self)</code>","text":"<p>Retrieves the faces adjacent to each edge in the mesh.</p> <p>This function returns the indices of the two faces that share each edge. For boundary edges, one of the face indices will be -1.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>f1</code> <code>numpy array</code> <p>The indices of the first face adjacent to each edge.</p> <code>f2</code> <code>numpy array</code> <p>The indices of the second face adjacent to each edge.</p> Note <p>This function assumes that the mesh is manifold and orientable. The edge faces are useful for local mesh analysis and processing.</p> See Also <p>edge_vertices : Retrieves the vertices of each edge.</p> <p>are_boundary_edges : Checks if edges are on the boundary.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def edge_faces(self):\n    \"\"\"\n    Retrieves the faces adjacent to each edge in the mesh.\n\n    This function returns the indices of the two faces that share each edge.\n    For boundary edges, one of the face indices will be -1.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    f1 : numpy array\n        The indices of the first face adjacent to each edge.\n    f2 : numpy array\n        The indices of the second face adjacent to each edge.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The edge faces are useful for local mesh analysis and processing.\n\n    See Also\n    --------\n    edge_vertices : Retrieves the vertices of each edge.\n\n    are_boundary_edges : Checks if edges are on the boundary.\n    \"\"\"\n    H  = self.halfedges\n    f  = H[np.argsort(H[:,5]),1]\n    f1 = f[0::2]\n    f2 = f[1::2]\n    return f1, f2\n</code></pre>"},{"location":"functions/meshpy/#meshpy.edge_lengths","title":"<code>edge_lengths(self)</code>","text":"<p>Computes the lengths of all edges in the mesh.</p> <p>This function calculates the length of each edge using the Euclidean distance between its two vertices.</p> <p>The main logic involves:</p> <ol> <li> <p>Iterating over all edges.</p> </li> <li> <p>Computing the length as the Euclidean distance between the two vertex positions.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>lengths</code> <code>numpy array</code> <p>An array of edge lengths.</p> Note <p>This function assumes that the mesh edges are valid and non-degenerate. The edge lengths are computed based on the current vertex positions.</p> See Also <p>edge_vectors : Computes the direction vectors of all edges.</p> <p>mean_edge_length : Computes the mean length of all edges.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def edge_lengths(self):\n    \"\"\"\n    Computes the lengths of all edges in the mesh.\n\n    This function calculates the length of each edge using the Euclidean distance\n    between its two vertices.\n\n    The main logic involves:\n\n    1. Iterating over all edges.\n\n    2. Computing the length as the Euclidean distance between the two vertex positions.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    lengths : numpy array\n        An array of edge lengths.\n\n    Note\n    ----\n    This function assumes that the mesh edges are valid and non-degenerate.\n    The edge lengths are computed based on the current vertex positions.\n\n    See Also\n    --------\n    edge_vectors : Computes the direction vectors of all edges.\n\n    mean_edge_length : Computes the mean length of all edges.\n    \"\"\"\n    v1, v2 = self.edge_vertices()\n    V1 = self.vertices[v1]\n    V2 = self.vertices[v2]\n    V = V1 - V2\n    L = np.linalg.norm(V, axis=1)\n    return L\n</code></pre>"},{"location":"functions/meshpy/#meshpy.edge_mid_points","title":"<code>edge_mid_points(self)</code>","text":"<p>Computes the midpoints of all edges in the mesh.</p> <p>This function calculates the midpoint of each edge by averaging the positions of its two vertices.</p> <p>The main logic involves:</p> <ol> <li> <p>Iterating over all edges.</p> </li> <li> <p>Computing the midpoint as the average of the two vertex positions.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>midpoints</code> <code>numpy array</code> <p>An array of edge midpoints, where each midpoint is a vector [x, y, z].</p> Note <p>This function assumes that the mesh edges are valid and non-degenerate. The edge midpoints are computed based on the current vertex positions.</p> See Also <p>edge_lengths : Computes the lengths of all edges.</p> <p>edge_vectors : Computes the direction vectors of all edges.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def edge_mid_points(self):\n    \"\"\"\n    Computes the midpoints of all edges in the mesh.\n\n    This function calculates the midpoint of each edge by averaging the positions\n    of its two vertices.\n\n    The main logic involves:\n\n    1. Iterating over all edges.\n\n    2. Computing the midpoint as the average of the two vertex positions.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    midpoints : numpy array\n        An array of edge midpoints, where each midpoint is a vector [x, y, z].\n\n    Note\n    ----\n    This function assumes that the mesh edges are valid and non-degenerate.\n    The edge midpoints are computed based on the current vertex positions.\n\n    See Also\n    --------\n    edge_lengths : Computes the lengths of all edges.\n\n    edge_vectors : Computes the direction vectors of all edges.\n    \"\"\"\n    v1, v2 = self.edge_vertices()\n    M = 0.5*(self.vertices[v1] + self.vertices[v2])\n    return M\n</code></pre>"},{"location":"functions/meshpy/#meshpy.edge_normals","title":"<code>edge_normals(self)</code>","text":"<p>Computes the normal vectors for each edge in the mesh.</p> <p>This function calculates the edge normals by averaging the face normals of the faces adjacent to each edge. If an edge is on the boundary, its normal is computed based on the single adjacent face.</p> <p>The main logic involves:</p> <ol> <li> <p>Identifying the faces adjacent to each edge.</p> </li> <li> <p>Averaging the face normals of these adjacent faces.</p> </li> <li> <p>Normalizing the resulting vector to obtain the edge normal.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>normals</code> <code>numpy array</code> <p>An array of edge normals, where each normal is a unit vector [nx, ny, nz].</p> Note <p>This function assumes that the mesh is manifold and orientable. The edge normals are computed based on the current face normals and mesh topology.</p> See Also <p>face_normals : Computes the normal vectors for each face.</p> <p>vertex_normals : Computes the normal vectors for each vertex.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def edge_normals(self):\n    \"\"\"\n    Computes the normal vectors for each edge in the mesh.\n\n    This function calculates the edge normals by averaging the face normals\n    of the faces adjacent to each edge. If an edge is on the boundary, its\n    normal is computed based on the single adjacent face.\n\n    The main logic involves:\n\n    1. Identifying the faces adjacent to each edge.\n\n    2. Averaging the face normals of these adjacent faces.\n\n    3. Normalizing the resulting vector to obtain the edge normal.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    normals : numpy array\n        An array of edge normals, where each normal is a unit vector [nx, ny, nz].\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The edge normals are computed based on the current face normals and mesh topology.\n\n    See Also\n    --------\n    face_normals : Computes the normal vectors for each face.\n\n    vertex_normals : Computes the normal vectors for each vertex.\n    \"\"\"\n    N = self.face_normals()\n    N = np.insert(N, N.shape[0], 0, axis=0)\n    f1, f2 = self.edge_faces()\n    normals = N[f1] + N[f2]\n    normals = normals / np.linalg.norm(normals, axis=1, keepdims=True)\n    return normals\n</code></pre>"},{"location":"functions/meshpy/#meshpy.edge_sine_vectors","title":"<code>edge_sine_vectors(self)</code>","text":"<p>Computes the sine vectors for each edge in the mesh.</p> <p>This function calculates the sine vectors by considering the sine of the  dihedral angle between adjacent faces. The sine vector is proportional to  the cross product of the face normals.</p> <p>The main logic involves:</p> <ol> <li> <p>Iterating over each edge and its adjacent faces.</p> </li> <li> <p>Computing the cross product of the face normals.</p> </li> <li> <p>Normalizing the resulting vector to obtain the sine vector.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>sine_vectors</code> <code>numpy array</code> <p>An array of sine vectors for each edge.</p> Note <p>This function assumes that the mesh is manifold and orientable. The sine vectors are computed based on the current face normals.</p> See Also <p>edge_angle_vectors : Computes the angle vectors for each edge.</p> <p>face_normals : Computes the normal vectors of all faces.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def edge_sine_vectors(self):\n    \"\"\"\n    Computes the sine vectors for each edge in the mesh.\n\n    This function calculates the sine vectors by considering the sine of the \n    dihedral angle between adjacent faces. The sine vector is proportional to \n    the cross product of the face normals.\n\n    The main logic involves:\n\n    1. Iterating over each edge and its adjacent faces.\n\n    2. Computing the cross product of the face normals.\n\n    3. Normalizing the resulting vector to obtain the sine vector.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    sine_vectors : numpy array\n        An array of sine vectors for each edge.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The sine vectors are computed based on the current face normals.\n\n    See Also\n    --------\n    edge_angle_vectors : Computes the angle vectors for each edge.\n\n    face_normals : Computes the normal vectors of all faces.\n    \"\"\"\n    v, ej = self.vertex_ring_edges_iterators(sort=True)\n    normals = self.face_normals()\n    v1, v2 = self.edge_vertices()\n    f1, f2 = self.edge_faces()\n    bf1 = np.where(f1 == -1)[0]\n    bf2 = np.where(f2 == -1)[0]\n    f1[bf1] = f2[bf1]\n    f2[bf2] = f1[bf2]\n    F1 = normals[f1,:]\n    F2 = normals[f2,:]\n    sin = np.cross(F1, F2)\n    return sin\n</code></pre>"},{"location":"functions/meshpy/#meshpy.edge_vertices","title":"<code>edge_vertices(self)</code>","text":"<p>Retrieves the vertices of each edge in the mesh.</p> <p>This function returns the indices of the two vertices that form each edge.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>v1</code> <code>numpy array</code> <p>The indices of the first vertex of each edge.</p> <code>v2</code> <code>numpy array</code> <p>The indices of the second vertex of each edge.</p> Note <p>This function assumes that the mesh is manifold and orientable. The edge vertices are useful for local mesh analysis and processing.</p> See Also <p>edge_faces : Retrieves the faces adjacent to each edge.</p> <p>edge_lengths : Computes the lengths of all edges.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def edge_vertices(self):\n    \"\"\"\n    Retrieves the vertices of each edge in the mesh.\n\n    This function returns the indices of the two vertices that form each edge.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    v1 : numpy array\n        The indices of the first vertex of each edge.\n    v2 : numpy array\n        The indices of the second vertex of each edge.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The edge vertices are useful for local mesh analysis and processing.\n\n    See Also\n    --------\n    edge_faces : Retrieves the faces adjacent to each edge.\n\n    edge_lengths : Computes the lengths of all edges.\n    \"\"\"\n    H  = self.halfedges\n    v  = H[np.argsort(H[:,5]),0]\n    v1 = v[0::2]\n    v2 = v[1::2]\n    return v1, v2\n</code></pre>"},{"location":"functions/meshpy/#meshpy.edge_vertices_iterators","title":"<code>edge_vertices_iterators(self, sort=False)</code>","text":"<p>Iterates over the vertices of each edge.</p> <p>This function provides iterators for the vertices that form each edge,  with an option for sorting.</p> <p>Parameters:</p> Name Type Description Default <code>sort</code> <code>(bool, optional(default=False))</code> <p>Whether to sort the vertices by vertex index.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>e</code> <code>numpy array</code> <p>The indices of the edges.</p> <code>vi</code> <code>numpy array</code> <p>The indices of the vertices forming each edge.</p> Note <p>This function assumes that the mesh is manifold and orientable. The edge vertices are useful for local mesh analysis and processing.</p> See Also <p>edge_faces : Retrieves the faces adjacent to each edge.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def edge_vertices_iterators(self, sort=False):\n    \"\"\"\n    Iterates over the vertices of each edge.\n\n    This function provides iterators for the vertices that form each edge, \n    with an option for sorting.\n\n    Parameters\n    ----------\n    sort : bool, optional (default=False)\n        Whether to sort the vertices by vertex index.\n\n    Returns\n    -------\n    e : numpy array\n        The indices of the edges.\n    vi : numpy array\n        The indices of the vertices forming each edge.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The edge vertices are useful for local mesh analysis and processing.\n\n    See Also\n    --------\n    edge_faces : Retrieves the faces adjacent to each edge.\n    \"\"\"\n    H = self.halfedges\n    e  = H[:,5]\n    vi = H[:,0]\n    if sort:\n        i  = np.argsort(H[:,5])\n        e  = e[i]\n        vi = vi[i]\n    return e, vi\n</code></pre>"},{"location":"functions/meshpy/#meshpy.equalize_valences","title":"<code>equalize_valences(self)</code>","text":"<p>Equalizes the valences of vertices in a triangular mesh.</p> <p>This function attempts to balance the number of edges connected to each vertex by performing local mesh operations such as edge flips, splits, and collapses. The goal is to achieve a more uniform vertex valence distribution.</p> <p>The main logic involves:</p> <ol> <li> <p>Iterating over all edges and checking their valences.</p> </li> <li> <p>Performing edge flips, splits, or collapses to balance valences.</p> </li> <li> <p>Repeating the process until the desired valence distribution is achieved.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>success</code> <code>bool</code> <p>Whether the valence equalization was successful.</p> Note <p>This function assumes that the mesh is a triangular mesh. The mesh topology is updated to achieve a more uniform valence distribution.</p> See Also <p>split_edges : Splits edges to achieve a desired maximum length.</p> <p>collapse_edges : Collapses edges to achieve a desired minimum length.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def equalize_valences(self):\n    \"\"\"\n    Equalizes the valences of vertices in a triangular mesh.\n\n    This function attempts to balance the number of edges connected to each vertex\n    by performing local mesh operations such as edge flips, splits, and collapses.\n    The goal is to achieve a more uniform vertex valence distribution.\n\n    The main logic involves:\n\n    1. Iterating over all edges and checking their valences.\n\n    2. Performing edge flips, splits, or collapses to balance valences.\n\n    3. Repeating the process until the desired valence distribution is achieved.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    success : bool\n        Whether the valence equalization was successful.\n\n    Note\n    ----\n    This function assumes that the mesh is a triangular mesh.\n    The mesh topology is updated to achieve a more uniform valence distribution.\n\n    See Also\n    --------\n    split_edges : Splits edges to achieve a desired maximum length.\n\n    collapse_edges : Collapses edges to achieve a desired minimum length.\n    \"\"\"\n    if not self.is_triangular_mesh():\n        return False\n    H = self.halfedges\n    _, he = np.unique(H[:,5], return_index=True)\n    t = np.repeat(6, self.V)\n    t[self.boundary_vertices()] = 4\n    t[self.mesh_corners()] = 3\n    _, _, l = self.vertex_ring_vertices_iterators(True, False, True)\n    for h in he:\n        a = H[h,0]\n        b = H[H[h,4],0]\n        c = H[H[h,3],0]\n        d = H[H[H[h,4],3],0]\n        deviation_0  = (l[a] - t[H[h,0]])**2\n        deviation_0 += (l[b] - t[H[H[h,4],0]])**2\n        deviation_0 += (l[c] - t[H[H[h,3],0]])**2\n        deviation_0 += (l[d] - t[H[H[H[h,4],3],0]])**2\n        deviation_1  = (l[a] - t[H[h,0]] - 1)**2\n        deviation_1 += (l[b] - t[H[H[h,4],0]] - 1)**2\n        deviation_1 += (l[c] - t[H[H[h,3],0]] + 1)**2\n        deviation_1 += (l[d] - t[H[H[H[h,4],3],0]] + 1)**2\n        if deviation_1 &lt; deviation_0:\n            if self._flip_halfedge(h):\n                l[a] -= 1\n                l[b] -= 1\n                l[c] += 1\n                l[d] += 1\n    self.topology_update()\n    return True\n</code></pre>"},{"location":"functions/meshpy/#meshpy.exploded_mesh","title":"<code>exploded_mesh(self)</code>","text":"<p>Creates an exploded version of the mesh.</p> <p>This function generates a new mesh where each face is separated from the others, effectively \"exploding\" the mesh into individual faces.</p> <p>The main logic involves:</p> <ol> <li> <p>Duplicating the vertices for each face.</p> </li> <li> <p>Creating new faces using the duplicated vertices.</p> </li> <li> <p>Constructing the exploded mesh topology.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>exploded_mesh</code> <code>Mesh</code> <p>The exploded mesh instance.</p> Note <p>This function assumes that the input mesh is manifold and orientable. The exploded mesh is constructed based on the current mesh topology and geometry.</p> See Also <p>dual_mesh : Constructs the dual mesh of the current mesh.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def exploded_mesh(self):\n    \"\"\"\n    Creates an exploded version of the mesh.\n\n    This function generates a new mesh where each face is separated from the others,\n    effectively \"exploding\" the mesh into individual faces.\n\n    The main logic involves:\n\n    1. Duplicating the vertices for each face.\n\n    2. Creating new faces using the duplicated vertices.\n\n    3. Constructing the exploded mesh topology.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    exploded_mesh : Mesh\n        The exploded mesh instance.\n\n    Note\n    ----\n    This function assumes that the input mesh is manifold and orientable.\n    The exploded mesh is constructed based on the current mesh topology and geometry.\n\n    See Also\n    --------\n    dual_mesh : Constructs the dual mesh of the current mesh.\n    \"\"\"\n    f, v = self.face_vertices_iterators()\n    vertices = self.vertices[v]\n    k = np.arange(len(v))\n    faces_list = [[] for i in range(self.F)]\n    for i in range(len(f)):\n        faces_list[f[i]].append(k[i])\n    exp_mesh = Mesh()\n    exp_mesh.make_mesh(vertices, faces_list)\n    return exp_mesh\n</code></pre>"},{"location":"functions/meshpy/#meshpy.face","title":"<code>face(self, halfedge_index=None)</code>","text":"<p>Retrieves the face associated with a specified half-edge.</p> <p>This function returns the index of the face that the specified half-edge belongs to.</p> <p>Parameters:</p> Name Type Description Default <code>halfedge_index</code> <code>(int, optional(default=None))</code> <p>The index of the half-edge. If None, returns the face indices for all half-edges.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>face_index</code> <code>int or numpy array</code> <p>The index of the face associated with the specified half-edge, or an array of face indices for all half-edges.</p> Note <p>This function assumes that the specified half-edge exists in the mesh. The face index is -1 if the half-edge is on the boundary.</p> See Also <p>origin : Retrieves the origin vertex of a half-edge.</p> <p>next : Retrieves the next half-edge in the face loop.</p> <p>previous : Retrieves the previous half-edge in the face loop.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def face(self, halfedge_index=None):\n    \"\"\"\n    Retrieves the face associated with a specified half-edge.\n\n    This function returns the index of the face that the specified half-edge belongs to.\n\n    Parameters\n    ----------\n    halfedge_index : int, optional (default=None)\n        The index of the half-edge. If None, returns the face indices for all half-edges.\n\n    Returns\n    -------\n    face_index : int or numpy array\n        The index of the face associated with the specified half-edge, or an array of face indices for all half-edges.\n\n    Note\n    ----\n    This function assumes that the specified half-edge exists in the mesh.\n    The face index is -1 if the half-edge is on the boundary.\n\n    See Also\n    --------\n    origin : Retrieves the origin vertex of a half-edge.\n\n    next : Retrieves the next half-edge in the face loop.\n\n    previous : Retrieves the previous half-edge in the face loop.\n    \"\"\"\n    H = self.halfedges\n    if halfedge_index is None:\n        return H[:,1]\n    return H[halfedge_index,1]\n</code></pre>"},{"location":"functions/meshpy/#meshpy.face_areas","title":"<code>face_areas(self)</code>","text":"<p>Computes the areas of all faces in the mesh.</p> <p>This function calculates the area of each face using the cross product of its edge vectors. For triangular faces, the area is half the magnitude of the cross product of two edges.</p> <p>The main logic involves:</p> <ol> <li> <p>Iterating over each face to extract its vertices.</p> </li> <li> <p>Computing the cross product of two edge vectors.</p> </li> <li> <p>Calculating the area as half the magnitude of the cross product.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>areas</code> <code>numpy array</code> <p>An array of face areas.</p> Note <p>This function assumes that the mesh faces are planar. The face areas are computed based on the current vertex positions.</p> See Also <p>area : Computes the total surface area of the mesh.</p> <p>face_vector_areas : Computes the vector areas of faces.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def face_areas(self):\n    \"\"\"\n    Computes the areas of all faces in the mesh.\n\n    This function calculates the area of each face using the cross product\n    of its edge vectors. For triangular faces, the area is half the magnitude\n    of the cross product of two edges.\n\n    The main logic involves:\n\n    1. Iterating over each face to extract its vertices.\n\n    2. Computing the cross product of two edge vectors.\n\n    3. Calculating the area as half the magnitude of the cross product.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    areas : numpy array\n        An array of face areas.\n\n    Note\n    ----\n    This function assumes that the mesh faces are planar.\n    The face areas are computed based on the current vertex positions.\n\n    See Also\n    --------\n    area : Computes the total surface area of the mesh.\n\n    face_vector_areas : Computes the vector areas of faces.\n    \"\"\"\n    N = self.face_vector_areas()\n    A = np.linalg.norm(N, axis=1)\n    return A\n</code></pre>"},{"location":"functions/meshpy/#meshpy.face_barycenters","title":"<code>face_barycenters(self)</code>","text":"<p>Computes the barycenters (geometric centers) of all faces in the mesh.</p> <p>This function calculates the barycenter of each face by averaging the positions of its vertices.</p> <p>The main logic involves:</p> <ol> <li> <p>Iterating over all faces.</p> </li> <li> <p>Computing the barycenter as the average of the vertex positions.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>barycenters</code> <code>numpy array</code> <p>An array of face barycenters, where each barycenter is a vector [x, y, z].</p> Note <p>This function assumes that the mesh faces are valid and non-degenerate. The barycenters are computed based on the current vertex positions.</p> See Also <p>face_areas : Computes the areas of all faces.</p> <p>face_circum_circles : Computes the circumcircles of all faces.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def face_barycenters(self):\n    \"\"\"\n    Computes the barycenters (geometric centers) of all faces in the mesh.\n\n    This function calculates the barycenter of each face by averaging the positions\n    of its vertices.\n\n    The main logic involves:\n\n    1. Iterating over all faces.\n\n    2. Computing the barycenter as the average of the vertex positions.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    barycenters : numpy array\n        An array of face barycenters, where each barycenter is a vector [x, y, z].\n\n    Note\n    ----\n    This function assumes that the mesh faces are valid and non-degenerate.\n    The barycenters are computed based on the current vertex positions.\n\n    See Also\n    --------\n    face_areas : Computes the areas of all faces.\n\n    face_circum_circles : Computes the circumcircles of all faces.\n    \"\"\"\n    H = self.halfedges\n    H = H[np.where(H[:,1] &gt;= 0)[0],:]\n    i = np.argsort(H[:,1])\n    f = H[i,1]\n    v = H[i,0]\n    V = self.vertices[v,:]\n    B = utilities.sum_repeated(V,f)\n    L = self.face_lengths()\n    L = np.column_stack((L,L,L))\n    B = B/L\n    return B\n</code></pre>"},{"location":"functions/meshpy/#meshpy.face_circum_circles","title":"<code>face_circum_circles(self)</code>","text":"<p>Computes the circumcircles of all faces in the mesh.</p> <p>This function calculates the circumcircle of each face by finding the circle that passes through its vertices. For triangular faces, the circumcircle is defined by the three vertices.</p> <p>The main logic involves:</p> <ol> <li> <p>Iterating over all faces.</p> </li> <li> <p>Computing the circumcircle using the vertices of each face.</p> </li> <li> <p>Returning the center and radius of each circumcircle.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>circumcircles</code> <code>list of tuples</code> <p>A list of circumcircle information for each face, where each entry is  (center_x, center_y, center_z, radius).</p> Note <p>This function assumes that the mesh faces are valid and non-degenerate. The circumcircles are computed based on the current vertex positions.</p> See Also <p>face_barycenters : Computes the barycenters of all faces.</p> <p>face_areas : Computes the areas of all faces.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def face_circum_circles(self):\n    \"\"\"\n    Computes the circumcircles of all faces in the mesh.\n\n    This function calculates the circumcircle of each face by finding the circle\n    that passes through its vertices. For triangular faces, the circumcircle is\n    defined by the three vertices.\n\n    The main logic involves:\n\n    1. Iterating over all faces.\n\n    2. Computing the circumcircle using the vertices of each face.\n\n    3. Returning the center and radius of each circumcircle.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    circumcircles : list of tuples\n        A list of circumcircle information for each face, where each entry is \n        (center_x, center_y, center_z, radius).\n\n    Note\n    ----\n    This function assumes that the mesh faces are valid and non-degenerate.\n    The circumcircles are computed based on the current vertex positions.\n\n    See Also\n    --------\n    face_barycenters : Computes the barycenters of all faces.\n\n    face_areas : Computes the areas of all faces.\n    \"\"\"\n    f, vi = self.face_vertices_iterators()\n    _, j = np.unique(f,True)\n    p1 = self.vertices[vi[j]]\n    p2 = self.vertices[vi[j+1]]\n    p3 = self.vertices[vi[j+2]]\n    circles = circle_three_points(p1, p2, p3)\n    return circles\n</code></pre>"},{"location":"functions/meshpy/#meshpy.face_edges_iterators","title":"<code>face_edges_iterators(self)</code>","text":"<p>Iterates over the edges in each face.</p> <p>This function provides iterators for the edges that form each face.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>f</code> <code>numpy array</code> <p>The indices of the faces.</p> <code>ei</code> <code>numpy array</code> <p>The indices of the edges in each face.</p> Note <p>This function assumes that the mesh is manifold and orientable. The face edges are useful for local mesh analysis and processing.</p> See Also <p>face_vertices_iterators : Iterates over vertices in each face.</p> <p>face_edge_vertices_iterators : Iterates over vertices of edges in each face.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def face_edges_iterators(self):\n    \"\"\"\n    Iterates over the edges in each face.\n\n    This function provides iterators for the edges that form each face.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    f : numpy array\n        The indices of the faces.\n    ei : numpy array\n        The indices of the edges in each face.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The face edges are useful for local mesh analysis and processing.\n\n    See Also\n    --------\n    face_vertices_iterators : Iterates over vertices in each face.\n\n    face_edge_vertices_iterators : Iterates over vertices of edges in each face.\n    \"\"\"\n    H = self.halfedges\n    i  = self.face_ordered_halfedges()\n    ei = H[i,5]\n    f  = H[i,1]\n    return f, ei\n</code></pre>"},{"location":"functions/meshpy/#meshpy.face_lengths","title":"<code>face_lengths(self)</code>","text":"<p>Computes the number of edges (length) for each face in the mesh.</p> <p>This function returns the number of edges for each face, which is equivalent  to the number of vertices forming the face.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>face_lengths</code> <code>numpy array</code> <p>The number of edges for each face.</p> Note <p>This function assumes that the mesh is manifold and orientable. The face lengths are useful for mesh analysis and processing.</p> See Also <p>faces_list : Retrieves the list of faces.</p> <p>face_vertices_iterators : Iterates over vertices of each face.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def face_lengths(self):\n    \"\"\"\n    Computes the number of edges (length) for each face in the mesh.\n\n    This function returns the number of edges for each face, which is equivalent \n    to the number of vertices forming the face.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    face_lengths : numpy array\n        The number of edges for each face.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The face lengths are useful for mesh analysis and processing.\n\n    See Also\n    --------\n    faces_list : Retrieves the list of faces.\n\n    face_vertices_iterators : Iterates over vertices of each face.\n    \"\"\"\n    H = self.halfedges\n    f = H[H[:,1] &gt;= 0,1]\n    f = f[np.argsort(f)]\n    i = np.ones((f.shape), 'i')\n    lengths = utilities.sum_repeated(i, f)\n    return lengths\n</code></pre>"},{"location":"functions/meshpy/#meshpy.face_normals","title":"<code>face_normals(self)</code>","text":"<p>Computes the normal vectors for each face in the mesh.</p> <p>This function calculates the face normals by taking the cross product of two edges of each face and normalizing the resulting vector.</p> <p>The main logic involves:</p> <ol> <li> <p>Iterating over each face to extract its vertices.</p> </li> <li> <p>Computing the cross product of two edges to obtain the normal vector.</p> </li> <li> <p>Normalizing the normal vector to ensure unit length.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>normals</code> <code>numpy array</code> <p>An array of face normals, where each normal is a unit vector [nx, ny, nz].</p> Note <p>This function assumes that the mesh faces are planar and that the half-edge structure is correctly defined. The normals are computed based on the current vertex positions.</p> See Also <p>vertex_normals : Computes the normal vectors for each vertex.</p> <p>edge_normals : Computes the normal vectors for each edge.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def face_normals(self):\n    \"\"\"\n    Computes the normal vectors for each face in the mesh.\n\n    This function calculates the face normals by taking the cross product of two edges\n    of each face and normalizing the resulting vector.\n\n    The main logic involves:\n\n    1. Iterating over each face to extract its vertices.\n\n    2. Computing the cross product of two edges to obtain the normal vector.\n\n    3. Normalizing the normal vector to ensure unit length.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    normals : numpy array\n        An array of face normals, where each normal is a unit vector [nx, ny, nz].\n\n    Note\n    ----\n    This function assumes that the mesh faces are planar and that the half-edge structure is correctly defined.\n    The normals are computed based on the current vertex positions.\n\n    See Also\n    --------\n    vertex_normals : Computes the normal vectors for each vertex.\n\n    edge_normals : Computes the normal vectors for each edge.\n    \"\"\"\n    N = self.face_vector_areas()\n    N = N / np.linalg.norm(N, axis=1, keepdims=True)\n    return N\n</code></pre>"},{"location":"functions/meshpy/#meshpy.face_ordered_halfedges","title":"<code>face_ordered_halfedges(self)</code>","text":"<p>Retrieves the half-edges in each face, ordered by traversal.</p> <p>This function returns the indices of half-edges that form each face, ordered  in a consistent traversal direction.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>ordered_halfedges</code> <code>numpy array</code> <p>The indices of half-edges in each face, ordered by traversal.</p> Note <p>This function assumes that the mesh is manifold and orientable. The half-edges are ordered to facilitate consistent traversal around each face.</p> See Also <p>face_vertices_iterators : Iterates over vertices in each face.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def face_ordered_halfedges(self):\n    \"\"\"\n    Retrieves the half-edges in each face, ordered by traversal.\n\n    This function returns the indices of half-edges that form each face, ordered \n    in a consistent traversal direction.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    ordered_halfedges : numpy array\n        The indices of half-edges in each face, ordered by traversal.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The half-edges are ordered to facilitate consistent traversal around each face.\n\n    See Also\n    --------\n    face_vertices_iterators : Iterates over vertices in each face.\n    \"\"\"\n    H = np.copy(self.halfedges)\n    i = np.argsort(H[:,1])\n    i = i[np.where(H[i,1] &gt;= 0)]\n    f = H[i,1]\n    index = np.arange(i.shape[0])\n    _, j = np.unique(f, True)\n    f = np.delete(f,j)\n    index = np.delete(index, j)\n    while f.shape[0] &gt; 0:\n        _, j = np.unique(f, True)\n        i[index[j]] = H[i[index[j] - 1],2]\n        f = np.delete(f, j)\n        index = np.delete(index, j)\n    return i\n</code></pre>"},{"location":"functions/meshpy/#meshpy.face_planarity","title":"<code>face_planarity(self, scale_invariant=True)</code>","text":"<p>Computes the planarity of each face in the mesh.</p> <p>This function calculates the planarity of each face by measuring the deviation from a perfect plane. The planarity can be computed as either absolute or scale-invariant.</p> <p>The main logic involves:</p> <ol> <li> <p>Iterating over all faces.</p> </li> <li> <p>Computing the deviation from planarity using the cross product of edge vectors.</p> </li> <li> <p>Normalizing the deviation if scale-invariant planarity is requested.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>scale_invariant</code> <code>(bool, optional(default=True))</code> <p>Whether to compute scale-invariant planarity.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>planarity</code> <code>numpy array</code> <p>An array of face planarity values.</p> Note <p>This function assumes that the mesh faces are valid and non-degenerate. The planarity is computed based on the current vertex positions.</p> See Also <p>face_areas : Computes the areas of all faces.</p> <p>face_normals : Computes the normal vectors of all faces.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def face_planarity(self, scale_invariant=True):\n    \"\"\"\n    Computes the planarity of each face in the mesh.\n\n    This function calculates the planarity of each face by measuring the deviation\n    from a perfect plane. The planarity can be computed as either absolute or\n    scale-invariant.\n\n    The main logic involves:\n\n    1. Iterating over all faces.\n\n    2. Computing the deviation from planarity using the cross product of edge vectors.\n\n    3. Normalizing the deviation if scale-invariant planarity is requested.\n\n    Parameters\n    ----------\n    scale_invariant : bool, optional (default=True)\n        Whether to compute scale-invariant planarity.\n\n    Returns\n    -------\n    planarity : numpy array\n        An array of face planarity values.\n\n    Note\n    ----\n    This function assumes that the mesh faces are valid and non-degenerate.\n    The planarity is computed based on the current vertex positions.\n\n    See Also\n    --------\n    face_areas : Computes the areas of all faces.\n\n    face_normals : Computes the normal vectors of all faces.\n    \"\"\"\n    planarity = np.zeros((self.F))\n    f, vi = self.face_vertices_iterators()\n    i = np.ones((f.shape[0]),dtype=int)\n    j = np.arange(f.shape[0])\n    _, k = np.unique(f, True)\n    L = utilities.sum_repeated(i, f)\n    index = j[k]\n    quad = np.where(L &gt; 3)[0]\n    shift = 0\n    while len(quad) &gt; 0:\n        P1 = self.vertices[vi[index[quad] + shift]]\n        P2 = self.vertices[vi[index[quad] + shift + 1]]\n        P3 = self.vertices[vi[index[quad] + shift + 2]]\n        P4 = self.vertices[vi[index[quad] + shift + 3]]\n        V1 = P3 - P1\n        V2 = P4 - P2\n        N  = np.cross(V1,V2)\n        eps = np.finfo(float).eps\n        P12 = P2 - P1\n        norm = ((np.linalg.norm(N, axis=1) + eps))\n        d = np.einsum('ij,ij-&gt;i', P12, N) / norm\n        if scale_invariant:\n            d1 = np.linalg.norm(V1, axis=1)\n            d2 = np.linalg.norm(V1, axis=1)\n            p = np.abs(d) / ((d1 + d2)/2)\n        else:\n            p = np.abs(d)\n        planarity[quad] = np.maximum(p, planarity[quad])\n        L -= 1\n        shift += 1\n        quad = np.where(L &gt; 3)[0]\n    return planarity\n</code></pre>"},{"location":"functions/meshpy/#meshpy.face_triangles","title":"<code>face_triangles(self)</code>","text":"<p>Decomposes each face into triangles.</p> <p>This function splits each face of the mesh into triangles, which is useful for  rendering or further processing. The resulting triangles are returned along  with their corresponding face indices.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>triangles</code> <code>numpy array</code> <p>An array of triangles, where each triangle is represented by three vertex indices.</p> <code>face_indices</code> <code>numpy array</code> <p>The indices of the original faces that each triangle belongs to.</p> Note <p>This function assumes that the mesh is manifold and orientable. The decomposition is useful for rendering or further processing.</p> See Also <p>faces_list : Retrieves the list of faces.</p> <p>face_lengths : Computes the number of edges for each face.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def face_triangles(self):\n    \"\"\"\n    Decomposes each face into triangles.\n\n    This function splits each face of the mesh into triangles, which is useful for \n    rendering or further processing. The resulting triangles are returned along \n    with their corresponding face indices.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    triangles : numpy array\n        An array of triangles, where each triangle is represented by three vertex indices.\n    face_indices : numpy array\n        The indices of the original faces that each triangle belongs to.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The decomposition is useful for rendering or further processing.\n\n    See Also\n    --------\n    faces_list : Retrieves the list of faces.\n\n    face_lengths : Computes the number of edges for each face.\n    \"\"\"\n    H = np.copy(self.halfedges)\n    h = np.argsort(H[:,1])\n    h = h[np.where(H[h,1] &gt;= 0)]\n    f = H[h,1]\n    f_i, j = np.unique(f, True)\n    one = np.arange(j.shape[0])\n    f = np.delete(f, j)\n    f = np.delete(f, j-one)\n    f = np.delete(f, j-2*one)\n    T = np.column_stack((H[j,0], H[H[j,2],0], H[H[H[j,2],2],0]))\n    nex = H[H[H[j,2],2],2]\n    face_index = f_i\n    offset = 0\n    while len(f) &gt; 0:\n        f_i, j = np.unique(f, True)\n        T_i = np.column_stack((T[offset+f_i,-1], H[nex[f_i],0], T[f_i,0]))\n        f = np.delete(f, j)\n        nex = H[nex,2]\n        T = np.vstack((T, T_i))\n        face_index = np.hstack((face_index, f_i))\n        offset += len(f_i)\n    return T, face_index\n</code></pre>"},{"location":"functions/meshpy/#meshpy.face_vector_areas","title":"<code>face_vector_areas(self)</code>","text":"<p>Computes the vector areas of all faces in the mesh.</p> <p>This function calculates the vector area of each face, which is the cross  product of two edge vectors scaled by half. The vector area is a vector  perpendicular to the face with a magnitude equal to the face area.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>vector_areas</code> <code>numpy array</code> <p>An array of vector areas for each face.</p> Note <p>This function assumes that the mesh faces are planar. The vector areas are computed based on the current vertex positions.</p> See Also <p>face_areas : Computes the scalar areas of all faces.</p> <p>face_normals : Computes the normal vectors of all faces.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def face_vector_areas(self):\n    \"\"\"\n    Computes the vector areas of all faces in the mesh.\n\n    This function calculates the vector area of each face, which is the cross \n    product of two edge vectors scaled by half. The vector area is a vector \n    perpendicular to the face with a magnitude equal to the face area.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    vector_areas : numpy array\n        An array of vector areas for each face.\n\n    Note\n    ----\n    This function assumes that the mesh faces are planar.\n    The vector areas are computed based on the current vertex positions.\n\n    See Also\n    --------\n    face_areas : Computes the scalar areas of all faces.\n\n    face_normals : Computes the normal vectors of all faces.\n    \"\"\"\n    f, v1, v2 = self.face_edge_vertices_iterators(order=True)\n    V1 = self.vertices[v1,:]\n    V2 = self.vertices[v2,:]\n    N  = np.cross(V1,V2)\n    normals = utilities.sum_repeated(N, f)\n    return 0.5 * normals\n</code></pre>"},{"location":"functions/meshpy/#meshpy.face_vertices_iterators","title":"<code>face_vertices_iterators(self)</code>","text":"<p>Iterates over the vertices in each face.</p> <p>This function provides iterators for the vertices that form each face.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>f</code> <code>numpy array</code> <p>The indices of the faces.</p> <code>vi</code> <code>numpy array</code> <p>The indices of the vertices in each face.</p> Note <p>This function assumes that the mesh is manifold and orientable. The face vertices are useful for local mesh analysis and processing.</p> See Also <p>face_edge_vertices_iterators : Iterates over vertices of edges in each face.</p> <p>face_edges_iterators : Iterates over edges in each face.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def face_vertices_iterators(self):\n    \"\"\"\n    Iterates over the vertices in each face.\n\n    This function provides iterators for the vertices that form each face.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    f : numpy array\n        The indices of the faces.\n    vi : numpy array\n        The indices of the vertices in each face.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The face vertices are useful for local mesh analysis and processing.\n\n    See Also\n    --------\n    face_edge_vertices_iterators : Iterates over vertices of edges in each face.\n\n    face_edges_iterators : Iterates over edges in each face.\n    \"\"\"\n    H = self.halfedges\n    i  = self.face_ordered_halfedges()\n    vi = H[i,0]\n    f  = H[i,1]\n    return f, vi\n</code></pre>"},{"location":"functions/meshpy/#meshpy.flip_edge","title":"<code>flip_edge(self, edge_index)</code>","text":"<p>Flips the specified edge in the mesh.</p> <p>This function reverses the direction of the specified edge by swapping its  adjacent faces. This operation is useful for optimizing mesh quality.</p> <p>The main logic involves:</p> <ol> <li> <p>Identifying the half-edges associated with the edge.</p> </li> <li> <p>Swapping the adjacent faces of the edge.</p> </li> <li> <p>Updating the half-edge structure.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>edge_index</code> <code>int</code> <p>The index of the edge to be flipped.</p> required <p>Returns:</p> Name Type Description <code>success</code> <code>bool</code> <p>Whether the edge flip was successful.</p> Note <p>This function assumes that the specified edge exists in the mesh. The edge flip is only performed if it results in a valid mesh topology.</p> See Also <p>split_edge : Splits an edge into two edges.</p> <p>collapse_edge : Collapses an edge into a single vertex.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def flip_edge(self, edge_index):\n    \"\"\"\n    Flips the specified edge in the mesh.\n\n    This function reverses the direction of the specified edge by swapping its \n    adjacent faces. This operation is useful for optimizing mesh quality.\n\n    The main logic involves:\n\n    1. Identifying the half-edges associated with the edge.\n\n    2. Swapping the adjacent faces of the edge.\n\n    3. Updating the half-edge structure.\n\n    Parameters\n    ----------\n    edge_index : int\n        The index of the edge to be flipped.\n\n    Returns\n    -------\n    success : bool\n        Whether the edge flip was successful.\n\n    Note\n    ----\n    This function assumes that the specified edge exists in the mesh.\n    The edge flip is only performed if it results in a valid mesh topology.\n\n    See Also\n    --------\n    split_edge : Splits an edge into two edges.\n\n    collapse_edge : Collapses an edge into a single vertex.\n    \"\"\"\n    h = self.edge_halfedge(edge_index)\n    if not self.is_halfedge_bounding_tri_faces(h):\n        return False\n    self._flip_halfedge(h)\n    self.topology_update()\n</code></pre>"},{"location":"functions/meshpy/#meshpy.flip_normals","title":"<code>flip_normals(self)</code>","text":"<p>Flips the normals of the mesh by reversing the half-edge orientation.</p> <p>This function inverts the direction of all face normals by swapping the  orientation of the half-edges. This effectively reverses the winding order  of the faces.</p> <p>The main logic involves:</p> <ol> <li> <p>Iterating over all half-edges.</p> </li> <li> <p>Swapping the origin and destination vertices of each half-edge.</p> </li> <li> <p>Updating the face normals accordingly.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The mesh normals are updated in place.</p> Note <p>This function assumes that the mesh is manifold and orientable. The normals are flipped based on the current half-edge structure.</p> See Also <p>face_normals : Computes the normal vectors of all faces.</p> <p>vertex_normals : Computes the normal vectors of all vertices.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def flip_normals(self):\n    \"\"\"\n    Flips the normals of the mesh by reversing the half-edge orientation.\n\n    This function inverts the direction of all face normals by swapping the \n    orientation of the half-edges. This effectively reverses the winding order \n    of the faces.\n\n    The main logic involves:\n\n    1. Iterating over all half-edges.\n\n    2. Swapping the origin and destination vertices of each half-edge.\n\n    3. Updating the face normals accordingly.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    None\n        The mesh normals are updated in place.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The normals are flipped based on the current half-edge structure.\n\n    See Also\n    --------\n    face_normals : Computes the normal vectors of all faces.\n\n    vertex_normals : Computes the normal vectors of all vertices.\n    \"\"\"\n    H = self.halfedges\n    H[:,0] = H[H[:,2],0]\n    H[:,[2,3]] = H[:,[3,2]]\n</code></pre>"},{"location":"functions/meshpy/#meshpy.halfedge_face_vertices","title":"<code>halfedge_face_vertices(self, halfedge_index)</code>","text":"<p>Retrieves the vertices of the face associated with a specified half-edge.</p> <p>This function returns the sequence of vertices that form the face associated  with the specified half-edge. The vertices are returned in the order they  appear around the face.</p> <p>The main logic involves:</p> <ol> <li> <p>Starting from the specified half-edge.</p> </li> <li> <p>Iteratively following the next half-edge in the face loop to collect vertices.</p> </li> <li> <p>Returning the sequence of vertices.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>halfedge_index</code> <code>int</code> <p>The index of the half-edge.</p> required <p>Returns:</p> Name Type Description <code>face_vertices</code> <code>list of int</code> <p>The indices of vertices forming the face.</p> Note <p>This function assumes that the specified half-edge exists in the mesh. The vertices are returned in the order they appear around the face.</p> See Also <p>halfedge_ring_vertices : Retrieves the vertices in the half-edge ring.</p> <p>face_vertices_iterators : Iterates over vertices of all faces.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def halfedge_face_vertices(self, halfedge_index):\n    \"\"\"\n    Retrieves the vertices of the face associated with a specified half-edge.\n\n    This function returns the sequence of vertices that form the face associated \n    with the specified half-edge. The vertices are returned in the order they \n    appear around the face.\n\n    The main logic involves:\n\n    1. Starting from the specified half-edge.\n\n    2. Iteratively following the next half-edge in the face loop to collect vertices.\n\n    3. Returning the sequence of vertices.\n\n    Parameters\n    ----------\n    halfedge_index : int\n        The index of the half-edge.\n\n    Returns\n    -------\n    face_vertices : list of int\n        The indices of vertices forming the face.\n\n    Note\n    ----\n    This function assumes that the specified half-edge exists in the mesh.\n    The vertices are returned in the order they appear around the face.\n\n    See Also\n    --------\n    halfedge_ring_vertices : Retrieves the vertices in the half-edge ring.\n\n    face_vertices_iterators : Iterates over vertices of all faces.\n    \"\"\"\n    H = self.halfedges\n    ring = self.halfedge_face_ring(halfedge_index)\n    vertices = H[ring,0]\n    return vertices\n</code></pre>"},{"location":"functions/meshpy/#meshpy.halfedge_length","title":"<code>halfedge_length(self, halfedge_index)</code>","text":"<p>Computes the length of a specified half-edge.</p> <p>This function calculates the Euclidean distance between the origin and destination  vertices of the specified half-edge.</p> <p>The main logic involves:</p> <ol> <li> <p>Retrieving the origin and destination vertices of the half-edge.</p> </li> <li> <p>Computing the Euclidean distance between the two vertices.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>halfedge_index</code> <code>int</code> <p>The index of the half-edge.</p> required <p>Returns:</p> Name Type Description <code>length</code> <code>float</code> <p>The length of the specified half-edge.</p> Note <p>This function assumes that the specified half-edge exists in the mesh. The length is computed based on the current vertex positions.</p> See Also <p>edge_lengths : Computes the lengths of all edges in the mesh.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def halfedge_length(self, halfedge_index):\n    \"\"\"\n    Computes the length of a specified half-edge.\n\n    This function calculates the Euclidean distance between the origin and destination \n    vertices of the specified half-edge.\n\n    The main logic involves:\n\n    1. Retrieving the origin and destination vertices of the half-edge.\n\n    2. Computing the Euclidean distance between the two vertices.\n\n    Parameters\n    ----------\n    halfedge_index : int\n        The index of the half-edge.\n\n    Returns\n    -------\n    length : float\n        The length of the specified half-edge.\n\n    Note\n    ----\n    This function assumes that the specified half-edge exists in the mesh.\n    The length is computed based on the current vertex positions.\n\n    See Also\n    --------\n    edge_lengths : Computes the lengths of all edges in the mesh.\n    \"\"\"\n    H = self.halfedges\n    h = halfedge_index\n    V1 = self.vertices[H[h,0]]\n    V2 = self.vertices[H[H[h,4],0]]\n    E = V1 - V2\n    return (E[0]**2 + E[1]**2 + E[2]**2)**0.5\n</code></pre>"},{"location":"functions/meshpy/#meshpy.halfedge_ring","title":"<code>halfedge_ring(self, halfedge_index)</code>","text":"<p>Retrieves the half-edge ring around a specified half-edge.</p> <p>This function returns the sequence of half-edges that form a loop around the  specified half-edge. The half-edge ring can be used to traverse the mesh topology.</p> <p>The main logic involves:</p> <ol> <li> <p>Starting from the specified half-edge.</p> </li> <li> <p>Iteratively following the next half-edge in the loop until the starting half-edge is reached.</p> </li> <li> <p>Returning the sequence of half-edges in the loop.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>halfedge_index</code> <code>int</code> <p>The index of the starting half-edge.</p> required <p>Returns:</p> Name Type Description <code>ring</code> <code>list of int</code> <p>The indices of half-edges in the half-edge ring.</p> Note <p>This function assumes that the specified half-edge exists in the mesh. The half-edge ring can be used for further mesh traversal and manipulation.</p> See Also <p>vertex_halfedge : Retrieves a half-edge originating from a specified vertex.</p> <p>halfedge_ring_vertices : Retrieves the vertices in the half-edge ring.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def halfedge_ring(self, halfedge_index):\n    \"\"\"\n    Retrieves the half-edge ring around a specified half-edge.\n\n    This function returns the sequence of half-edges that form a loop around the \n    specified half-edge. The half-edge ring can be used to traverse the mesh topology.\n\n    The main logic involves:\n\n    1. Starting from the specified half-edge.\n\n    2. Iteratively following the next half-edge in the loop until the starting half-edge is reached.\n\n    3. Returning the sequence of half-edges in the loop.\n\n    Parameters\n    ----------\n    halfedge_index : int\n        The index of the starting half-edge.\n\n    Returns\n    -------\n    ring : list of int\n        The indices of half-edges in the half-edge ring.\n\n    Note\n    ----\n    This function assumes that the specified half-edge exists in the mesh.\n    The half-edge ring can be used for further mesh traversal and manipulation.\n\n    See Also\n    --------\n    vertex_halfedge : Retrieves a half-edge originating from a specified vertex.\n\n    halfedge_ring_vertices : Retrieves the vertices in the half-edge ring.\n    \"\"\"\n    H = self.halfedges\n    h0 = halfedge_index\n    ring = [h0]\n    h = H[H[h0,3],4]\n    while h != h0:\n        ring.append(h)\n        h = H[H[h,3],4]\n    return ring\n</code></pre>"},{"location":"functions/meshpy/#meshpy.halfedge_ring_faces","title":"<code>halfedge_ring_faces(self, halfedge_index)</code>","text":"<p>Retrieves the faces adjacent to the half-edge ring of a specified half-edge.</p> <p>This function returns the sequence of faces that are adjacent to the half-edge  ring starting from the specified half-edge. The faces are returned in the order  they appear around the ring.</p> <p>The main logic involves:</p> <ol> <li> <p>Starting from the specified half-edge.</p> </li> <li> <p>Iteratively following the next half-edge in the ring to collect adjacent faces.</p> </li> <li> <p>Returning the sequence of faces.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>halfedge_index</code> <code>int</code> <p>The index of the starting half-edge.</p> required <p>Returns:</p> Name Type Description <code>ring_faces</code> <code>list of int</code> <p>The indices of faces adjacent to the half-edge ring.</p> Note <p>This function assumes that the specified half-edge exists in the mesh. The faces are returned in the order they appear around the ring.</p> See Also <p>halfedge_ring : Retrieves the half-edge ring around a specified half-edge.</p> <p>face_vertices_iterators : Iterates over vertices of all faces.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def halfedge_ring_faces(self, halfedge_index):\n    \"\"\"\n    Retrieves the faces adjacent to the half-edge ring of a specified half-edge.\n\n    This function returns the sequence of faces that are adjacent to the half-edge \n    ring starting from the specified half-edge. The faces are returned in the order \n    they appear around the ring.\n\n    The main logic involves:\n\n    1. Starting from the specified half-edge.\n\n    2. Iteratively following the next half-edge in the ring to collect adjacent faces.\n\n    3. Returning the sequence of faces.\n\n    Parameters\n    ----------\n    halfedge_index : int\n        The index of the starting half-edge.\n\n    Returns\n    -------\n    ring_faces : list of int\n        The indices of faces adjacent to the half-edge ring.\n\n    Note\n    ----\n    This function assumes that the specified half-edge exists in the mesh.\n    The faces are returned in the order they appear around the ring.\n\n    See Also\n    --------\n    halfedge_ring : Retrieves the half-edge ring around a specified half-edge.\n\n    face_vertices_iterators : Iterates over vertices of all faces.\n    \"\"\"\n    H = self.halfedges\n    ring = self.halfedge_ring(halfedge_index)\n    faces = H[H[ring,2],1]\n    return faces\n</code></pre>"},{"location":"functions/meshpy/#meshpy.halfedge_ring_vertices","title":"<code>halfedge_ring_vertices(self, halfedge_index)</code>","text":"<p>Retrieves the vertices in the half-edge ring around a specified half-edge.</p> <p>This function returns the sequence of vertices that form the half-edge ring  starting from the specified half-edge. The vertices are returned in the order  they appear around the ring.</p> <p>Parameters:</p> Name Type Description Default <code>halfedge_index</code> <code>int</code> <p>The index of the starting half-edge.</p> required <p>Returns:</p> Name Type Description <code>vertices</code> <code>list of int</code> <p>The indices of vertices in the half-edge ring.</p> Note <p>This function assumes that the specified half-edge exists in the mesh. The half-edge ring vertices are useful for local mesh analysis and processing.</p> See Also <p>halfedge_ring : Retrieves the half-edge ring around a specified half-edge.</p> <p>vertex_ring_vertices_iterators : Iterates over vertices in the vertex ring.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def halfedge_ring_vertices(self, halfedge_index):\n    \"\"\"\n    Retrieves the vertices in the half-edge ring around a specified half-edge.\n\n    This function returns the sequence of vertices that form the half-edge ring \n    starting from the specified half-edge. The vertices are returned in the order \n    they appear around the ring.\n\n    Parameters\n    ----------\n    halfedge_index : int\n        The index of the starting half-edge.\n\n    Returns\n    -------\n    vertices : list of int\n        The indices of vertices in the half-edge ring.\n\n    Note\n    ----\n    This function assumes that the specified half-edge exists in the mesh.\n    The half-edge ring vertices are useful for local mesh analysis and processing.\n\n    See Also\n    --------\n    halfedge_ring : Retrieves the half-edge ring around a specified half-edge.\n\n    vertex_ring_vertices_iterators : Iterates over vertices in the vertex ring.\n    \"\"\"\n    H = self.halfedges\n    ring = self.halfedge_ring(halfedge_index)\n    vertices = H[H[ring,2],0]\n    return vertices\n</code></pre>"},{"location":"functions/meshpy/#meshpy.inner_halfedges","title":"<code>inner_halfedges(self)</code>","text":"<p>Retrieves the indices of inner half-edges in the mesh.</p> <p>This function identifies and returns the half-edges that are not on the boundary.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>inner_halfedges</code> <code>numpy array</code> <p>The indices of inner half-edges.</p> Note <p>This function assumes that the mesh is manifold and orientable. The inner half-edges are useful for mesh analysis and processing.</p> See Also <p>boundary_halfedges : Retrieves the indices of boundary half-edges.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def inner_halfedges(self):\n    \"\"\"\n    Retrieves the indices of inner half-edges in the mesh.\n\n    This function identifies and returns the half-edges that are not on the boundary.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    inner_halfedges : numpy array\n        The indices of inner half-edges.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The inner half-edges are useful for mesh analysis and processing.\n\n    See Also\n    --------\n    boundary_halfedges : Retrieves the indices of boundary half-edges.\n    \"\"\"\n    H = self.halfedges\n    h = np.where(H[:,1] != -1)[0]\n    return h\n</code></pre>"},{"location":"functions/meshpy/#meshpy.inner_vertices","title":"<code>inner_vertices(self)</code>","text":"<p>Retrieves the indices of inner vertices in the mesh.</p> <p>This function identifies and returns the vertices that are not on the boundary of the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>inner_vertices</code> <code>numpy array</code> <p>The indices of vertices that are not on the boundary.</p> Note <p>This function assumes that the mesh is manifold and orientable. The inner vertices are useful for mesh analysis and processing.</p> See Also <p>boundary_vertices : Retrieves the indices of boundary vertices.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def inner_vertices(self):\n    \"\"\"\n    Retrieves the indices of inner vertices in the mesh.\n\n    This function identifies and returns the vertices that are not on the boundary of the mesh.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    inner_vertices : numpy array\n        The indices of vertices that are not on the boundary.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The inner vertices are useful for mesh analysis and processing.\n\n    See Also\n    --------\n    boundary_vertices : Retrieves the indices of boundary vertices.\n    \"\"\"\n    b = self.boundary_vertices()\n    v = np.arange(self.V)\n    mask = np.invert(np.in1d(v, b))\n    v = v[mask]\n    return v\n</code></pre>"},{"location":"functions/meshpy/#meshpy.is_boundary_halfedge_ring","title":"<code>is_boundary_halfedge_ring(self, ring)</code>","text":"<p>Checks if a half-edge ring is on the boundary of the mesh.</p> <p>This function verifies whether the specified half-edge ring is part of the  mesh boundary. It returns True if the ring is on the boundary, False otherwise.</p> <p>The main logic involves:</p> <ol> <li> <p>Iterating over the half-edge ring.</p> </li> <li> <p>Checking if any half-edge in the ring is a boundary half-edge.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>ring</code> <code>list of int</code> <p>The indices of half-edges in the ring.</p> required <p>Returns:</p> Name Type Description <code>is_boundary</code> <code>bool</code> <p>Whether the half-edge ring is on the boundary.</p> Note <p>This function assumes that the mesh is manifold and orientable. The check is based on the current mesh topology and half-edge definitions.</p> See Also <p>is_halfedge_bounding_tri_faces : Checks if a half-edge bounds triangular faces.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def is_boundary_halfedge_ring(self, ring):\n    \"\"\"\n    Checks if a half-edge ring is on the boundary of the mesh.\n\n    This function verifies whether the specified half-edge ring is part of the \n    mesh boundary. It returns True if the ring is on the boundary, False otherwise.\n\n    The main logic involves:\n\n    1. Iterating over the half-edge ring.\n\n    2. Checking if any half-edge in the ring is a boundary half-edge.\n\n    Parameters\n    ----------\n    ring : list of int\n        The indices of half-edges in the ring.\n\n    Returns\n    -------\n    is_boundary : bool\n        Whether the half-edge ring is on the boundary.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The check is based on the current mesh topology and half-edge definitions.\n\n    See Also\n    --------\n    is_halfedge_bounding_tri_faces : Checks if a half-edge bounds triangular faces.\n    \"\"\"\n    H = self.halfedges\n    for h in ring:\n        if H[h,1] == -1:\n            v0 = H[h,0]\n            v1 = H[H[h,2],0]\n            v2 = H[H[h,3],0]\n            E1 = (self.vertices[v1] - self.vertices[v0])\n            E2 = (self.vertices[v0] - self.vertices[v2])\n            E1 = E1 / (E1[0]**2 + E1[1]**2 + E1[2]**2 + 1e-10)**0.5\n            E2 = E2 / (E2[0]**2 + E2[1]**2 + E2[2]**2 + 1e-10)**0.5\n            dot = E1[0]*E2[0] + E1[1]*E2[1] + E1[2]*E2[2]\n            if dot &lt; self.corner_tolerance:\n                return 2\n            else:\n                return 1\n    return 0\n</code></pre>"},{"location":"functions/meshpy/#meshpy.is_halfedge_bounding_tri_faces","title":"<code>is_halfedge_bounding_tri_faces(self, halfedge_index)</code>","text":"<p>Checks if a specified half-edge bounds triangular faces.</p> <p>This function verifies whether the specified half-edge is part of a triangular  face or a boundary edge. It returns True if the half-edge bounds triangular faces,  False otherwise.</p> <p>The main logic involves:</p> <ol> <li> <p>Checking the face associated with the half-edge.</p> </li> <li> <p>Verifying if the face is triangular or a boundary face.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>halfedge_index</code> <code>int</code> <p>The index of the half-edge.</p> required <p>Returns:</p> Name Type Description <code>is_bounding</code> <code>bool</code> <p>Whether the half-edge bounds triangular faces.</p> Note <p>This function assumes that the mesh is manifold and orientable. The check is based on the current mesh topology and face definitions.</p> See Also <p>is_boundary_halfedge_ring : Checks if a half-edge ring is on the boundary.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def is_halfedge_bounding_tri_faces(self, halfedge_index):\n    \"\"\"\n    Checks if a specified half-edge bounds triangular faces.\n\n    This function verifies whether the specified half-edge is part of a triangular \n    face or a boundary edge. It returns True if the half-edge bounds triangular faces, \n    False otherwise.\n\n    The main logic involves:\n\n    1. Checking the face associated with the half-edge.\n\n    2. Verifying if the face is triangular or a boundary face.\n\n    Parameters\n    ----------\n    halfedge_index : int\n        The index of the half-edge.\n\n    Returns\n    -------\n    is_bounding : bool\n        Whether the half-edge bounds triangular faces.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The check is based on the current mesh topology and face definitions.\n\n    See Also\n    --------\n    is_boundary_halfedge_ring : Checks if a half-edge ring is on the boundary.\n    \"\"\"\n    H = self.halfedges\n    h = halfedge_index\n    for i in range(2):\n        counter = 1\n        h0 = h\n        h = H[h,2]\n        while h != h0:\n            h = H[h,2]\n            counter += 1\n            if counter &gt; 3:\n                return False\n        h = H[halfedge_index,4]\n    return True\n</code></pre>"},{"location":"functions/meshpy/#meshpy.is_triangular_mesh","title":"<code>is_triangular_mesh(self)</code>","text":"<p>Checks if the mesh is a triangular mesh.</p> <p>This function verifies whether all faces in the mesh are triangles.</p> <p>The main logic involves:</p> <ol> <li> <p>Iterating over all faces.</p> </li> <li> <p>Checking the number of vertices per face.</p> </li> <li> <p>Returning True if all faces are triangles, otherwise False.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>is_triangular</code> <code>bool</code> <p>Whether the mesh is a triangular mesh.</p> Note <p>This function assumes that the mesh is manifold and orientable. The check is based on the current mesh topology.</p> See Also <p>loop : Applies the Loop subdivision algorithm (requires a triangular mesh).</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def is_triangular_mesh(self):\n    \"\"\"\n    Checks if the mesh is a triangular mesh.\n\n    This function verifies whether all faces in the mesh are triangles.\n\n    The main logic involves:\n\n    1. Iterating over all faces.\n\n    2. Checking the number of vertices per face.\n\n    3. Returning True if all faces are triangles, otherwise False.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    is_triangular : bool\n        Whether the mesh is a triangular mesh.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The check is based on the current mesh topology.\n\n    See Also\n    --------\n    loop : Applies the Loop subdivision algorithm (requires a triangular mesh).\n    \"\"\"\n    l = self.face_lengths()\n    if len(np.where(l != 3)[0] &gt; 0):\n        return False\n    else:\n        return True\n</code></pre>"},{"location":"functions/meshpy/#meshpy.loop","title":"<code>loop(self, steps=1)</code>","text":"<p>Applies the Loop subdivision algorithm to the mesh.</p> <p>This function refines the mesh by subdividing each triangle into four smaller triangles. The new vertices are positioned based on the Loop subdivision rules.</p> <p>The main logic involves:</p> <ol> <li> <p>Identifying the vertices and edges of each triangle.</p> </li> <li> <p>Computing the new vertex positions using the Loop subdivision weights.</p> </li> <li> <p>Creating new faces and updating the mesh topology.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>steps</code> <code>(int, optional(default=1))</code> <p>The number of subdivision steps to apply.</p> <code>1</code> <p>Returns:</p> Type Description <code>None</code> <p>The mesh is updated within the class instance.</p> Note <p>This function assumes that the mesh is triangular and manifold. The Loop subdivision algorithm is only applicable to triangular meshes.</p> See Also <p>catmull_clark : Applies the Catmull-Clark subdivision algorithm.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def loop(self, steps=1):\n    \"\"\"\n    Applies the Loop subdivision algorithm to the mesh.\n\n    This function refines the mesh by subdividing each triangle into four smaller triangles.\n    The new vertices are positioned based on the Loop subdivision rules.\n\n    The main logic involves:\n\n    1. Identifying the vertices and edges of each triangle.\n\n    2. Computing the new vertex positions using the Loop subdivision weights.\n\n    3. Creating new faces and updating the mesh topology.\n\n    Parameters\n    ----------\n    steps : int, optional (default=1)\n        The number of subdivision steps to apply.\n\n    Returns\n    -------\n    None\n        The mesh is updated within the class instance.\n\n    Note\n    ----\n    This function assumes that the mesh is triangular and manifold.\n    The Loop subdivision algorithm is only applicable to triangular meshes.\n\n    See Also\n    --------\n    catmull_clark : Applies the Catmull-Clark subdivision algorithm.\n    \"\"\"\n    if not self.is_triangular_mesh():\n        return False\n    def _loop(self):\n        V = self.V\n        H = self.halfedges\n        _, h1 = np.unique(H[:,1], True)\n        h1 = np.delete(h1, np.where(H[h1,1] == -1))\n        h2 = H[h1,2]\n        h3 = H[h1,3]\n        F0 = np.array((H[h1,5]+V, H[h2,5]+V, H[h3,5]+V)).T\n        F1 = np.array((H[h1,0], H[h1,5]+V, H[H[h1,3],5]+V)).T\n        F2 = np.array((H[h2,0], H[h2,5]+V, H[H[h2,3],5]+V)).T\n        F3 = np.array((H[h3,0], H[h3,5]+V, H[H[h3,3],5]+V)).T\n        new_faces = np.vstack((F0, F1, F2, F3)).tolist()\n        v, vj, l = self.vertex_ring_vertices_iterators(sort=True,\n                                                    return_lengths=True)\n        c = 1./l * (5./8 - (3./8 + 1./4*np.cos(2*np.pi*l**(-1.)))**2)\n        d = 1 - l*c\n        c = np.array([c,c,c]).T\n        d = np.array([d,d,d]).T\n        ring = utilities.sum_repeated(self.vertices[vj], v)\n        V0 = c*ring + d*self.vertices\n        _, e = np.unique(H[:,5], True)\n        v1 = self.vertices[H[e,0]]\n        v2 = self.vertices[H[H[e,4],0]]\n        v3 = self.vertices[H[H[e,3],0]]\n        v4 = self.vertices[H[H[H[e,4],3],0]]\n        be = self.boundary_edges()\n        v3[be] = v1[be]\n        v4[be] = v2[be]\n        V1 = 3./8*v1 + 3./8*v2 + 1./8*v3 + 1./8*v4\n        bh = np.where(H[:,1] == -1)[0]\n        v0 = self.vertices[H[bh,0]]\n        v5 = self.vertices[H[H[bh,3],0]]\n        v6 = self.vertices[H[H[bh,2],0]]\n        V0[H[bh,0]] = 1./8*v6 + 1./8*v5 + 3./4*v0\n        new_vertices = np.vstack((V0, V1))\n        self.make_mesh(new_vertices, new_faces)\n    for i in range(steps):\n        self._loop()\n</code></pre>"},{"location":"functions/meshpy/#meshpy.make_kdtree","title":"<code>make_kdtree(self)</code>","text":"<p>Constructs a k-d tree from the mesh vertices for efficient nearest-neighbor queries.</p> <p>This function creates a k-d tree data structure using the vertex positions, allowing for fast nearest-neighbor searches.</p> <p>The main logic involves:</p> <ol> <li> <p>Creating a k-d tree from the vertex positions.</p> </li> <li> <p>Storing the k-d tree within the mesh instance for later use.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The k-d tree is stored within the mesh instance.</p> Note <p>This function assumes that the mesh vertices are valid and non-empty. The k-d tree is used to accelerate nearest-neighbor queries.</p> See Also <p>closest_vertices : Finds the closest vertices to a set of query points.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def make_kdtree(self):\n    \"\"\"\n    Constructs a k-d tree from the mesh vertices for efficient nearest-neighbor queries.\n\n    This function creates a k-d tree data structure using the vertex positions,\n    allowing for fast nearest-neighbor searches.\n\n    The main logic involves:\n\n    1. Creating a k-d tree from the vertex positions.\n\n    2. Storing the k-d tree within the mesh instance for later use.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    None\n        The k-d tree is stored within the mesh instance.\n\n    Note\n    ----\n    This function assumes that the mesh vertices are valid and non-empty.\n    The k-d tree is used to accelerate nearest-neighbor queries.\n\n    See Also\n    --------\n    closest_vertices : Finds the closest vertices to a set of query points.\n    \"\"\"\n    kdtree = spatial.cKDTree(self.vertices)\n    self._kdtree = kdtree\n</code></pre>"},{"location":"functions/meshpy/#meshpy.make_mesh","title":"<code>make_mesh(self, vertices_list, faces_list)</code>","text":"<p>Constructs a half-edge mesh data structure from a list of vertices and faces.</p> <p>This function initializes the half-edge mesh by creating the necessary data structures, including half-edges, vertices, and faces. It ensures that the mesh is manifold and orientable, and it reorients the mesh if necessary.</p> <p>The main logic involves:</p> <ol> <li> <p>Creating half-edges from the input vertices and faces.</p> </li> <li> <p>Establishing relationships between half-edges, vertices, and faces.</p> </li> <li> <p>Handling boundary edges and faces.</p> </li> <li> <p>Reorienting the mesh if it is not initially orientable.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>vertices_list</code> <code>list of lists</code> <p>A list of vertex coordinates, where each vertex is represented as [x, y, z].</p> required <code>faces_list</code> <code>list of lists</code> <p>A list of faces, where each face is represented as a list of vertex indices.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The mesh is constructed within the class instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the mesh is not manifold and orientable.</p> Note <p>This function assumes that the input vertices and faces form a valid mesh. The mesh must be manifold and orientable for the half-edge structure to be correctly defined.</p> See Also <p>read_obj_file : Reads mesh data from an OBJ file.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def make_mesh(self, vertices_list, faces_list):\n    \"\"\"\n    Constructs a half-edge mesh data structure from a list of vertices and faces.\n\n    This function initializes the half-edge mesh by creating the necessary data structures,\n    including half-edges, vertices, and faces. It ensures that the mesh is manifold and orientable,\n    and it reorients the mesh if necessary.\n\n    The main logic involves:\n\n    1. Creating half-edges from the input vertices and faces.\n\n    2. Establishing relationships between half-edges, vertices, and faces.\n\n    3. Handling boundary edges and faces.\n\n    4. Reorienting the mesh if it is not initially orientable.\n\n    Parameters\n    ----------\n    vertices_list : list of lists\n        A list of vertex coordinates, where each vertex is represented as [x, y, z].\n    faces_list : list of lists\n        A list of faces, where each face is represented as a list of vertex indices.\n\n    Returns\n    -------\n    None\n        The mesh is constructed within the class instance.\n\n    Raises\n    ------\n    ValueError\n        If the mesh is not manifold and orientable.\n\n    Note\n    ----\n    This function assumes that the input vertices and faces form a valid mesh.\n    The mesh must be manifold and orientable for the half-edge structure to be correctly defined.\n\n    See Also\n    --------\n    read_obj_file : Reads mesh data from an OBJ file.\n\n    \"\"\"   \n    def _make_halfedges(self, vertices_list, faces_list):\n        self._V = len(vertices_list)\n        self._F = len(faces_list)\n        self._vertices = np.array(vertices_list, 'f')\n        orig = []\n        face = []\n        nexx = []\n        prev = []\n        twin_i = []\n        twin_j = []\n        h = 0\n        for f in range(self.F):\n            N = len(faces_list[f])\n            orig.append(faces_list[f][0])\n            face.append(f)\n            nexx.append(h + 1)\n            prev.append(h + N - 1)\n            twin_i.append(faces_list[f][1])\n            twin_j.append(faces_list[f][0])\n            for v in range(1, N-1):\n                orig.append(faces_list[f][v])\n                face.append(f)\n                nexx.append(h + v + 1)\n                prev.append(h + v - 1)\n                twin_i.append(faces_list[f][v+1])\n                twin_j.append(faces_list[f][v])\n            orig.append(faces_list[f][N-1])\n            face.append(f)\n            nexx.append(h)\n            prev.append(h + N - 2)\n            twin_i.append(faces_list[f][0])\n            twin_j.append(faces_list[f][N-1])\n            h += N\n        H = np.zeros((h, 6), 'i')\n        H[:,0] = orig\n        H[:,1] = face\n        H[:,2] = nexx\n        H[:,3] = prev\n        twin = coo_matrix((np.arange(h) + 1, (twin_i, twin_j)), shape=(h, h))\n        twin = twin.tocsc()\n        H[:,4] = twin[H[:,0],H[H[:,2],0]] - 1\n        b = np.where(H[:,4] == -1)[0]\n        boundary = H[b,:]\n        boundary[:,0] = H[H[b,2],0]\n        boundary[:,1] = -1\n        boundary[:,4] = b\n        #B = boundary.shape[0]  # test by Davide\n        B = len(boundary)\n        if B &gt; 0:\n            Bh = np.arange(h, h+B)\n            H[b,4] = Bh\n            zeros = np.zeros(B)\n            p = coo_matrix((Bh, (H[b,0], zeros)), shape=(self.V, 1))\n            p = p.tocsc()\n            # print(boundary[:,0]) # test by Davide\n            # print(zeros) # test by Davide\n            # print(p) # test by Davide\n            boundary[:,3] = p[boundary[:,0],zeros]\n            i = boundary[boundary[:,3]-h,0]\n            p = coo_matrix((Bh, (i, zeros)), shape=(self.V, 1))\n            p = p.tocsc()\n            boundary[:,2] = p[boundary[:,0], zeros]\n            H = np.vstack((H, boundary))\n        K = H[:,(3,4)]\n        K[:,0] = np.arange(H.shape[0])\n        m = np.amin(K, axis=1)\n        u = np.unique(m)\n        imap = np.arange(np.max(u) + 1, dtype=int)\n        imap[u] = np.arange(u.shape[0])\n        H[:,5] = imap[m]\n        self._halfedges = H\n        self._E = int(H.shape[0] / 2)\n        self.topology_update()\n\n    try:\n        self._make_halfedges(vertices_list, faces_list)\n    except:\n        try:\n            faces_list = self.orient_faces(vertices_list, faces_list)\n            self._make_halfedges(vertices_list, faces_list)\n            print('*** Mesh reoriented ***')\n        except:\n            raise ValueError('The mesh is not manifold and orientable!')\n    print(self)\n</code></pre>"},{"location":"functions/meshpy/#meshpy.make_obj_file","title":"<code>make_obj_file(self, file_name, overwrite=False)</code>","text":"<p>Writes the mesh data to an OBJ file.</p> <p>This function exports the mesh vertices and faces to an OBJ file, which can be  used for visualization or further processing.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>The path to the OBJ file.</p> required <code>overwrite</code> <code>(bool, optional(default=False))</code> <p>Whether to overwrite the file if it already exists.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>file_path</code> <code>str</code> <p>The path to the created OBJ file (without the extension).</p> Note <p>This function assumes that the mesh data is valid and manifold. The OBJ file format is widely supported for 3D visualization and modeling.</p> See Also <p>read_obj_file : Reads mesh data from an OBJ file.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def make_obj_file(self, file_name, overwrite=False):\n    \"\"\"\n    Writes the mesh data to an OBJ file.\n\n    This function exports the mesh vertices and faces to an OBJ file, which can be \n    used for visualization or further processing.\n\n    Parameters\n    ----------\n    file_name : str\n        The path to the OBJ file.\n    overwrite : bool, optional (default=False)\n        Whether to overwrite the file if it already exists.\n\n    Returns\n    -------\n    file_path : str\n        The path to the created OBJ file (without the extension).\n\n    Note\n    ----\n    This function assumes that the mesh data is valid and manifold.\n    The OBJ file format is widely supported for 3D visualization and modeling.\n\n    See Also\n    --------\n    read_obj_file : Reads mesh data from an OBJ file.\n    \"\"\"\n    path = utilities.make_filepath(file_name, 'obj', overwrite)\n    obj = open(path, 'w')\n    line = ('o {}\\n').format(file_name)\n    obj.write(line)\n    faces = self.faces_list()\n    for v in range(self.V):\n        vi = self.vertices[v]\n        line = ('v {} {} {}\\n').format(vi[0], vi[1], vi[2])\n        obj.write(line)\n    for f in range(self.F):\n            obj.write('f ')\n            N = len(faces[f])\n            for v in range(N - 1):\n                vf = str(faces[f][v] + 1)\n                #obj.write(unicode(vf + '//' + ' '))\n                obj.write(vf + ' ')\n            vf = str(faces[f][N - 1] + 1)\n            #obj.write(unicode(vf + '//' + '\\n'))\n            obj.write(vf + '\\n')\n    obj.close()\n    return path.split('.')[0]\n</code></pre>"},{"location":"functions/meshpy/#meshpy.make_simply_connected","title":"<code>make_simply_connected(self)</code>","text":"<p>Modifies the mesh to make it simply connected by removing boundary loops.</p> <p>This function cuts the mesh along boundary edges to eliminate multiple  boundary loops, resulting in a simply connected mesh.</p> <p>The main logic involves:</p> <ol> <li> <p>Identifying all boundary loops in the mesh.</p> </li> <li> <p>Cutting the mesh along boundary edges to merge boundary loops.</p> </li> <li> <p>Reconstructing the mesh topology after cutting.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The mesh topology is updated in place.</p> Note <p>This function assumes that the mesh is manifold and orientable. The resulting mesh will have a single boundary loop.</p> See Also <p>boundary_curves : Retrieves the boundary loops of the mesh.</p> <p>cut : Cuts the mesh along a specified boundary edge.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def make_simply_connected(self):\n    \"\"\"\n    Modifies the mesh to make it simply connected by removing boundary loops.\n\n    This function cuts the mesh along boundary edges to eliminate multiple \n    boundary loops, resulting in a simply connected mesh.\n\n    The main logic involves:\n\n    1. Identifying all boundary loops in the mesh.\n\n    2. Cutting the mesh along boundary edges to merge boundary loops.\n\n    3. Reconstructing the mesh topology after cutting.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    None\n        The mesh topology is updated in place.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The resulting mesh will have a single boundary loop.\n\n    See Also\n    --------\n    boundary_curves : Retrieves the boundary loops of the mesh.\n\n    cut : Cuts the mesh along a specified boundary edge.\n    \"\"\"\n    curves = self.boundary_curves(corner_split=False)\n    while len(curves) &gt; 1:\n        curve = curves[0]\n        i = 0\n        v = curve[i]\n        while len(self.vertex_ring_vertices(v)) &lt; 3:\n            i += 1\n            v = curve[i]\n        self.cut(v)\n        curves = self.boundary_curves(corner_split=False)\n</code></pre>"},{"location":"functions/meshpy/#meshpy.mesh_center","title":"<code>mesh_center(self)</code>","text":"<p>Computes the geometric center of the mesh.</p> <p>This function calculates the center of the mesh by averaging the coordinates of its bounding box.</p> <p>The main logic involves:</p> <ol> <li> <p>Calling <code>bounding_box</code> to compute the axis-aligned bounding box.</p> </li> <li> <p>Computing the center as the midpoint of each axis range.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>center</code> <code>numpy array</code> <p>The geometric center of the mesh, represented as [x, y, z].</p> Note <p>This function assumes that the mesh vertices are valid and non-empty. The center is computed based on the current bounding box.</p> See Also <p>bounding_box : Computes the axis-aligned bounding box of the mesh.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def mesh_center(self):\n    \"\"\"\n    Computes the geometric center of the mesh.\n\n    This function calculates the center of the mesh by averaging the coordinates\n    of its bounding box.\n\n    The main logic involves:\n\n    1. Calling `bounding_box` to compute the axis-aligned bounding box.\n\n    2. Computing the center as the midpoint of each axis range.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    center : numpy array\n        The geometric center of the mesh, represented as [x, y, z].\n\n    Note\n    ----\n    This function assumes that the mesh vertices are valid and non-empty.\n    The center is computed based on the current bounding box.\n\n    See Also\n    --------\n    bounding_box : Computes the axis-aligned bounding box of the mesh.\n    \"\"\"\n    B = self.bounding_box()\n    x = (B[0][0] + B[0][1])/2\n    y = (B[1][0] + B[1][1])/2\n    z = (B[2][0] + B[2][1])/2\n    return np.array([x,y,z])\n</code></pre>"},{"location":"functions/meshpy/#meshpy.mesh_corners","title":"<code>mesh_corners(self)</code>","text":"<p>Identifies the corner vertices of the mesh.</p> <p>This function detects and returns the vertices that are considered corners  based on the angle between adjacent edges.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>corners</code> <code>numpy array</code> <p>The indices of corner vertices.</p> Note <p>This function assumes that the mesh is manifold and orientable. The corner vertices are useful for mesh analysis and processing.</p> See Also <p>boundary_curves : Retrieves the boundary curves in terms of vertices.</p> <p>boundary_curves_halfedges : Retrieves the boundary curves in terms of half-edges.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def mesh_corners(self):\n    \"\"\"\n    Identifies the corner vertices of the mesh.\n\n    This function detects and returns the vertices that are considered corners \n    based on the angle between adjacent edges.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    corners : numpy array\n        The indices of corner vertices.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The corner vertices are useful for mesh analysis and processing.\n\n    See Also\n    --------\n    boundary_curves : Retrieves the boundary curves in terms of vertices.\n\n    boundary_curves_halfedges : Retrieves the boundary curves in terms of half-edges.\n    \"\"\"\n    H = self.halfedges\n    b = np.where(H[:,1] == -1)[0]\n    v0 = H[b,0]\n    vp = H[H[b,3],0]\n    vn = H[H[b,2],0]\n    Vp = self.vertices[v0,:] - self.vertices[vp,:]\n    Vn = self.vertices[vn,:] - self.vertices[v0,:]\n    Vp = Vp / np.linalg.norm(Vp, axis=1, keepdims=True)\n    Vn = Vn / np.linalg.norm(Vn, axis=1, keepdims=True)\n    C = np.einsum('ij,ij-&gt;i', Vp, Vn)\n    corners = v0[np.where(C[:] &lt; self.corner_tolerance)[0]]\n    return corners\n</code></pre>"},{"location":"functions/meshpy/#meshpy.mesh_curves","title":"<code>mesh_curves(self)</code>","text":"<p>Extracts the curves from the mesh, including boundary and internal curves.</p> <p>This function identifies and extracts curves from the mesh by following  edges and vertices. The curves can be used for analysis or visualization.</p> <p>The main logic involves:</p> <ol> <li> <p>Identifying boundary and internal edges.</p> </li> <li> <p>Following edges to form continuous curves.</p> </li> <li> <p>Returning the extracted curves as lists of vertex indices.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>curves</code> <code>list of lists</code> <p>A list of curves, where each curve is represented by a list of vertex indices.</p> Note <p>This function assumes that the mesh is manifold and orientable. The curves are extracted based on the current mesh topology.</p> See Also <p>boundary_curves : Retrieves the boundary loops of the mesh.</p> <p>mesh_polylines : Converts curves to polyline objects.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def mesh_curves(self):\n    \"\"\"\n    Extracts the curves from the mesh, including boundary and internal curves.\n\n    This function identifies and extracts curves from the mesh by following \n    edges and vertices. The curves can be used for analysis or visualization.\n\n    The main logic involves:\n\n    1. Identifying boundary and internal edges.\n\n    2. Following edges to form continuous curves.\n\n    3. Returning the extracted curves as lists of vertex indices.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    curves : list of lists\n        A list of curves, where each curve is represented by a list of vertex indices.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The curves are extracted based on the current mesh topology.\n\n    See Also\n    --------\n    boundary_curves : Retrieves the boundary loops of the mesh.\n\n    mesh_polylines : Converts curves to polyline objects.\n    \"\"\"\n    _,_, valence = self.vertex_ring_vertices_iterators(return_lengths=True)\n    boundary_vertices = self.boundary_vertices()\n    H = self.halfedges\n    boundaries = self.boundary_curves_halfedges(True)\n    done = []\n    curves = []\n    for boundary in boundaries:\n        family = []\n        for h in boundary:\n            if H[h,0] not in done:\n                curve = [H[h,0]]\n                if valence[H[h,0]] &lt;= 3:\n                    turn = 1\n                else:\n                    turn = 2\n                for i in range(turn):\n                    h = H[H[h,4],2]\n                vertex = H[H[h,4],0]\n                stop = False\n                exclude = False\n                if vertex in boundary_vertices:\n                    stop = True\n                    exclude = True\n                while not stop:\n                    curve.append(vertex)\n                    if vertex in boundary_vertices:\n                        stop = True\n                        done.append(vertex)\n                    if valence[vertex] &lt;= 4:\n                        turn = 1\n                    else:\n                        turn = 2\n                    for i in range(turn):\n                        h = H[H[H[h,2],4],2]\n                    vertex = H[H[h,4],0]\n                if not exclude:\n                    family.append(curve)\n        if len(family) &gt; 0:\n            curves.append(family)\n    curves.append(self.boundary_curves(True))\n    return curves\n</code></pre>"},{"location":"functions/meshpy/#meshpy.mesh_polylines","title":"<code>mesh_polylines(self)</code>","text":"<p>Converts the mesh curves to polyline objects for visualization.</p> <p>This function takes the extracted curves from the mesh and converts them  into polyline objects, which can be used for visualization or further processing.</p> <p>The main logic involves:</p> <ol> <li> <p>Calling <code>mesh_curves</code> to extract the curves from the mesh.</p> </li> <li> <p>Converting each curve to a polyline object using vertex positions.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>polylines</code> <code>list of Polyline objects</code> <p>A list of polyline objects representing the mesh curves.</p> Note <p>This function assumes that the mesh curves are valid and non-degenerate. The polylines are created based on the current vertex positions.</p> See Also <p>mesh_curves : Extracts the curves from the mesh.</p> <p>Polyline : A class representing a polyline object.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def mesh_polylines(self):\n    \"\"\"\n    Converts the mesh curves to polyline objects for visualization.\n\n    This function takes the extracted curves from the mesh and converts them \n    into polyline objects, which can be used for visualization or further processing.\n\n    The main logic involves:\n\n    1. Calling `mesh_curves` to extract the curves from the mesh.\n\n    2. Converting each curve to a polyline object using vertex positions.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    polylines : list of Polyline objects\n        A list of polyline objects representing the mesh curves.\n\n    Note\n    ----\n    This function assumes that the mesh curves are valid and non-degenerate.\n    The polylines are created based on the current vertex positions.\n\n    See Also\n    --------\n    mesh_curves : Extracts the curves from the mesh.\n\n    Polyline : A class representing a polyline object.\n    \"\"\"\n    curves = self.mesh_curves()\n    polylines = []\n    for family in curves:\n        poly_family = []\n        for curve in family:\n            poly_family.append(Polyline(self.vertices[curve,:]))\n        polylines.append(poly_family)\n    return polylines\n</code></pre>"},{"location":"functions/meshpy/#meshpy.move","title":"<code>move(self, displacement_vector)</code>","text":"<p>Translates the mesh by a specified displacement vector.</p> <p>This function moves the entire mesh by adding the displacement vector to  each vertex position.</p> <p>The main logic involves:</p> <ol> <li> <p>Adding the displacement vector to each vertex coordinate.</p> </li> <li> <p>Updating the vertex positions in place.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>displacement_vector</code> <code>list or numpy array</code> <p>The displacement vector [dx, dy, dz] to apply to the mesh.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The mesh vertices are updated in place.</p> Note <p>This function assumes that the displacement vector is valid. The mesh is translated based on the current vertex positions.</p> See Also <p>scale : Scales the mesh by a specified factor.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def move(self, displacement_vector):\n    \"\"\"\n    Translates the mesh by a specified displacement vector.\n\n    This function moves the entire mesh by adding the displacement vector to \n    each vertex position.\n\n    The main logic involves:\n\n    1. Adding the displacement vector to each vertex coordinate.\n\n    2. Updating the vertex positions in place.\n\n    Parameters\n    ----------\n    displacement_vector : list or numpy array\n        The displacement vector [dx, dy, dz] to apply to the mesh.\n\n    Returns\n    -------\n    None\n        The mesh vertices are updated in place.\n\n    Note\n    ----\n    This function assumes that the displacement vector is valid.\n    The mesh is translated based on the current vertex positions.\n\n    See Also\n    --------\n    scale : Scales the mesh by a specified factor.\n    \"\"\"\n    self.vertices[:,[0,1,2]] += np.array(displacement_vector)[[0,1,2]]\n</code></pre>"},{"location":"functions/meshpy/#meshpy.next","title":"<code>next(self, halfedge_index=None)</code>","text":"<p>Retrieves the next half-edge in the face loop.</p> <p>This function returns the index of the next half-edge in the face loop starting from the specified half-edge.</p> <p>Parameters:</p> Name Type Description Default <code>halfedge_index</code> <code>(int, optional(default=None))</code> <p>The index of the half-edge. If None, returns the next half-edges for all half-edges.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>next_halfedge</code> <code>int or numpy array</code> <p>The index of the next half-edge in the face loop, or an array of next half-edges for all half-edges.</p> Note <p>This function assumes that the specified half-edge exists in the mesh. The next half-edge is part of the same face as the specified half-edge.</p> See Also <p>previous : Retrieves the previous half-edge in the face loop.</p> <p>origin : Retrieves the origin vertex of a half-edge.</p> <p>face : Retrieves the face associated with a half-edge.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def next(self, halfedge_index=None):\n    \"\"\"\n    Retrieves the next half-edge in the face loop.\n\n    This function returns the index of the next half-edge in the face loop starting from the specified half-edge.\n\n    Parameters\n    ----------\n    halfedge_index : int, optional (default=None)\n        The index of the half-edge. If None, returns the next half-edges for all half-edges.\n\n    Returns\n    -------\n    next_halfedge : int or numpy array\n        The index of the next half-edge in the face loop, or an array of next half-edges for all half-edges.\n\n    Note\n    ----\n    This function assumes that the specified half-edge exists in the mesh.\n    The next half-edge is part of the same face as the specified half-edge.\n\n    See Also\n    --------\n    previous : Retrieves the previous half-edge in the face loop.\n\n    origin : Retrieves the origin vertex of a half-edge.\n\n    face : Retrieves the face associated with a half-edge.\n    \"\"\"\n    H = self.halfedges\n    if halfedge_index is None:\n        return H[:,2]\n    return H[halfedge_index,2]\n</code></pre>"},{"location":"functions/meshpy/#meshpy.orient_faces","title":"<code>orient_faces(self, vertices_list, faces_list)</code>","text":"<p>Reorients the faces of the mesh to ensure consistent winding order.</p> <p>This function processes the input vertices and faces to ensure that all faces  have a consistent orientation. This is necessary for creating a valid half-edge  structure.</p> <p>The main logic involves:</p> <ol> <li> <p>Iterating over all faces and checking their orientation.</p> </li> <li> <p>Reversing the vertex order of any face with inconsistent orientation.</p> </li> <li> <p>Returning the reoriented face list.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>vertices_list</code> <code>list of lists</code> <p>The list of vertex coordinates [x, y, z].</p> required <code>faces_list</code> <code>list of lists</code> <p>The list of faces, where each face is defined by vertex indices.</p> required <p>Returns:</p> Name Type Description <code>oriented_faces</code> <code>list of lists</code> <p>The reoriented face list with consistent winding order.</p> Note <p>This function assumes that the input mesh is manifold and orientable. The reoriented faces are necessary for constructing a valid half-edge structure.</p> See Also <p>make_mesh : Constructs the half-edge mesh from vertices and faces.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def orient_faces(self, vertices_list, faces_list):\n    \"\"\"\n    Reorients the faces of the mesh to ensure consistent winding order.\n\n    This function processes the input vertices and faces to ensure that all faces \n    have a consistent orientation. This is necessary for creating a valid half-edge \n    structure.\n\n    The main logic involves:\n\n    1. Iterating over all faces and checking their orientation.\n\n    2. Reversing the vertex order of any face with inconsistent orientation.\n\n    3. Returning the reoriented face list.\n\n    Parameters\n    ----------\n    vertices_list : list of lists\n        The list of vertex coordinates [x, y, z].\n    faces_list : list of lists\n        The list of faces, where each face is defined by vertex indices.\n\n    Returns\n    -------\n    oriented_faces : list of lists\n        The reoriented face list with consistent winding order.\n\n    Note\n    ----\n    This function assumes that the input mesh is manifold and orientable.\n    The reoriented faces are necessary for constructing a valid half-edge structure.\n\n    See Also\n    --------\n    make_mesh : Constructs the half-edge mesh from vertices and faces.\n    \"\"\"\n    F = len(faces_list)\n    V = len(vertices_list)\n    fmap = -np.ones((V,V), dtype=int)\n    inconsistent = np.zeros((V,V), dtype=int)\n    flipped = np.zeros(F, dtype=bool)\n    oriented = np.zeros(F, dtype=bool)\n    oriented_faces = copy.deepcopy(faces_list)\n    for f in range(F):\n        face = faces_list[f]\n        for j in range(len(face)):\n            v0 = face[j-1]\n            v1 = face[j]\n            if fmap[v0,v1] == -1:\n                fmap[v0,v1] = f\n            else:\n                fmap[v1,v0] = f\n                inconsistent[v0,v1] = True\n                inconsistent[v1,v0] = True\n    ring = [0]\n    oriented[0] = True\n    i = 1\n    while len(ring) &gt; 0:\n        next_ring = []\n        for f in ring:\n            face = faces_list[f]\n            for j in range(len(face)):\n                flip = False\n                v0 = face[j-1]\n                v1 = face[j]\n                if fmap[v0,v1] == f:\n                    v2 = v1\n                    v3 = v0\n                else:\n                    v2 = v0\n                    v3 = v1\n                if inconsistent[v2,v3] and not flipped[f]:\n                    flip = True\n                if not inconsistent[v2,v3] and flipped[f]:\n                    flip = True\n                fi = fmap[v2,v3]\n                if fi != -1 and not oriented[fi]:\n                    if fi not in next_ring:\n                        next_ring.append(fi)\n                    if flip:\n                        oriented_faces[fi].reverse()\n                        flipped[fi] = True\n                    i += 1\n                    oriented[fi] = True\n                    if i == F:\n                        return oriented_faces\n        ring = next_ring\n        if len(ring) == 0:\n            try:\n                ring = [np.where(oriented == False)[0][0]]\n            except:\n                return\n</code></pre>"},{"location":"functions/meshpy/#meshpy.origin","title":"<code>origin(self, halfedge_index=None)</code>","text":"<p>Retrieves the origin vertex of a specified half-edge.</p> <p>This function returns the index of the vertex where the specified half-edge originates.</p> <p>Parameters:</p> Name Type Description Default <code>halfedge_index</code> <code>(int, optional(default=None))</code> <p>The index of the half-edge. If None, returns the origin vertices for all half-edges.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>origin_vertex</code> <code>int or numpy array</code> <p>The index of the origin vertex for the specified half-edge, or an array of origin vertices for all half-edges.</p> Note <p>This function assumes that the specified half-edge exists in the mesh. The origin vertex is the starting vertex of the half-edge.</p> See Also <p>next : Retrieves the next half-edge in the face loop.</p> <p>previous : Retrieves the previous half-edge in the face loop.</p> <p>twin : Retrieves the twin half-edge.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def origin(self, halfedge_index=None):\n    \"\"\"\n    Retrieves the origin vertex of a specified half-edge.\n\n    This function returns the index of the vertex where the specified half-edge originates.\n\n    Parameters\n    ----------\n    halfedge_index : int, optional (default=None)\n        The index of the half-edge. If None, returns the origin vertices for all half-edges.\n\n    Returns\n    -------\n    origin_vertex : int or numpy array\n        The index of the origin vertex for the specified half-edge, or an array of origin vertices for all half-edges.\n\n    Note\n    ----\n    This function assumes that the specified half-edge exists in the mesh.\n    The origin vertex is the starting vertex of the half-edge.\n\n    See Also\n    --------\n    next : Retrieves the next half-edge in the face loop.\n\n    previous : Retrieves the previous half-edge in the face loop.\n\n    twin : Retrieves the twin half-edge.\n    \"\"\"\n    H = self.halfedges\n    if halfedge_index is None:\n        return H[:,0]\n    return H[halfedge_index,0]\n</code></pre>"},{"location":"functions/meshpy/#meshpy.previous","title":"<code>previous(self, halfedge_index=None)</code>","text":"<p>Retrieves the previous half-edge in the face loop.</p> <p>This function returns the index of the previous half-edge in the face loop starting from the specified half-edge.</p> <p>Parameters:</p> Name Type Description Default <code>halfedge_index</code> <code>(int, optional(default=None))</code> <p>The index of the half-edge. If None, returns the previous half-edges for all half-edges.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>previous_halfedge</code> <code>int or numpy array</code> <p>The index of the previous half-edge in the face loop, or an array of previous half-edges for all half-edges.</p> Note <p>This function assumes that the specified half-edge exists in the mesh. The previous half-edge is part of the same face as the specified half-edge.</p> See Also <p>next : Retrieves the next half-edge in the face loop.</p> <p>origin : Retrieves the origin vertex of a half-edge.</p> <p>face : Retrieves the face associated with a half-edge.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def previous(self, halfedge_index=None):\n    \"\"\"\n    Retrieves the previous half-edge in the face loop.\n\n    This function returns the index of the previous half-edge in the face loop starting from the specified half-edge.\n\n    Parameters\n    ----------\n    halfedge_index : int, optional (default=None)\n        The index of the half-edge. If None, returns the previous half-edges for all half-edges.\n\n    Returns\n    -------\n    previous_halfedge : int or numpy array\n        The index of the previous half-edge in the face loop, or an array of previous half-edges for all half-edges.\n\n    Note\n    ----\n    This function assumes that the specified half-edge exists in the mesh.\n    The previous half-edge is part of the same face as the specified half-edge.\n\n    See Also\n    --------\n    next : Retrieves the next half-edge in the face loop.\n\n    origin : Retrieves the origin vertex of a half-edge.\n\n    face : Retrieves the face associated with a half-edge.\n    \"\"\"\n    H = self.halfedges\n    if halfedge_index is None:\n        return H[:,3]\n    return H[halfedge_index,3]\n</code></pre>"},{"location":"functions/meshpy/#meshpy.principal_curvatures","title":"<code>principal_curvatures(self, area_normalization=False, use_sine=False)</code>","text":"<p>Computes the principal curvatures and directions for each vertex in the mesh.</p> <p>This function calculates the principal curvatures and their corresponding  directions by analyzing the extended shape operator at each vertex.</p> <p>The main logic involves:</p> <ol> <li> <p>Computing the extended shape operator for each vertex.</p> </li> <li> <p>Diagonalizing the shape operator to obtain the principal curvatures and directions.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>area_normalization</code> <code>(bool, optional(default=False))</code> <p>Whether to normalize the shape operator by the vertex area.</p> <code>False</code> <code>use_sine</code> <code>(bool, optional(default=False))</code> <p>Whether to use sine vectors instead of angle vectors.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>k1</code> <code>numpy array</code> <p>The first principal curvature at each vertex.</p> <code>k2</code> <code>numpy array</code> <p>The second principal curvature at each vertex.</p> <code>D1</code> <code>numpy array</code> <p>The direction of the first principal curvature.</p> <code>D2</code> <code>numpy array</code> <p>The direction of the second principal curvature.</p> Note <p>This function assumes that the mesh is manifold and orientable. The principal curvatures are computed based on the current mesh geometry and topology.</p> See Also <p>extended_shape_operator : Computes the extended shape operator for each vertex.</p> <p>gaussian_curvature : Computes the Gaussian curvature from principal curvatures.</p> <p>mean_curvature : Computes the mean curvature from principal curvatures.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def principal_curvatures(self, area_normalization=False, use_sine=False):\n    \"\"\"\n    Computes the principal curvatures and directions for each vertex in the mesh.\n\n    This function calculates the principal curvatures and their corresponding \n    directions by analyzing the extended shape operator at each vertex.\n\n    The main logic involves:\n\n    1. Computing the extended shape operator for each vertex.\n\n    2. Diagonalizing the shape operator to obtain the principal curvatures and directions.\n\n    Parameters\n    ----------\n    area_normalization : bool, optional (default=False)\n        Whether to normalize the shape operator by the vertex area.\n    use_sine : bool, optional (default=False)\n        Whether to use sine vectors instead of angle vectors.\n\n    Returns\n    -------\n    k1 : numpy array\n        The first principal curvature at each vertex.\n    k2 : numpy array\n        The second principal curvature at each vertex.\n    D1 : numpy array\n        The direction of the first principal curvature.\n    D2 : numpy array\n        The direction of the second principal curvature.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The principal curvatures are computed based on the current mesh geometry and topology.\n\n    See Also\n    --------\n    extended_shape_operator : Computes the extended shape operator for each vertex.\n\n    gaussian_curvature : Computes the Gaussian curvature from principal curvatures.\n\n    mean_curvature : Computes the mean curvature from principal curvatures.\n    \"\"\"\n    W = self.extended_shape_operator(area_normalization, use_sine)\n    try:\n        eig = np.linalg.eigh(W)\n        srt = np.argsort(np.abs(eig[0]), axis=1)\n        i = np.arange(self.V)\n        i1 = srt[:,1]\n        i2 = srt[:,2]\n        k1 = eig[0][i,i1]\n        k2 = eig[0][i,i2]\n        V1 = eig[1][i,:,i1]\n        V2 = eig[1][i,:,i2]\n        N = self.vertex_normals()\n        D1 = utilities.normalize(np.cross(V1,N))\n        D2 = utilities.normalize(np.cross(V2,N))\n    except:\n        V = self.V\n        return (np.ones(V), np.ones(V), np.ones((V,3)), np.ones((V,3)))\n    return (k1, k2, D1, D2)\n</code></pre>"},{"location":"functions/meshpy/#meshpy.read_obj_file","title":"<code>read_obj_file(self, file_name)</code>","text":"<p>Reads mesh data from an OBJ file and constructs the half-edge mesh.</p> <p>This function parses the OBJ file to extract vertices and faces, and then calls the <code>make_mesh</code> method to construct the half-edge mesh data structure.</p> <p>The main logic involves:</p> <ol> <li> <p>Reading the OBJ file line by line to extract vertex and face information.</p> </li> <li> <p>Handling different formats of face definitions (e.g., with or without texture coordinates).</p> </li> <li> <p>Calling <code>make_mesh</code> to construct the mesh.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>The path to the OBJ file.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The mesh is constructed within the class instance.</p> Note <p>This function assumes that the OBJ file is correctly formatted and contains valid mesh data. The mesh must be manifold and orientable for the half-edge structure to be correctly defined.</p> See Also <p>make_mesh : Constructs the half-edge mesh from vertices and faces.</p> <p>make_obj_file : Writes the mesh data to an OBJ file.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def read_obj_file(self, file_name):\n    \"\"\"\n    Reads mesh data from an OBJ file and constructs the half-edge mesh.\n\n    This function parses the OBJ file to extract vertices and faces, and then calls\n    the `make_mesh` method to construct the half-edge mesh data structure.\n\n    The main logic involves:\n\n    1. Reading the OBJ file line by line to extract vertex and face information.\n\n    2. Handling different formats of face definitions (e.g., with or without texture coordinates).\n\n    3. Calling `make_mesh` to construct the mesh.\n\n    Parameters\n    ----------\n    file_name : str\n        The path to the OBJ file.\n\n    Returns\n    -------\n    None\n        The mesh is constructed within the class instance.\n\n    Note\n    ----\n    This function assumes that the OBJ file is correctly formatted and contains valid mesh data.\n    The mesh must be manifold and orientable for the half-edge structure to be correctly defined.\n\n    See Also\n    --------\n    make_mesh : Constructs the half-edge mesh from vertices and faces.\n\n    make_obj_file : Writes the mesh data to an OBJ file.\n    \"\"\"\n    file_name = str(file_name)\n    self.name = file_name.split('.')[0]\n    obj_file = open(file_name, encoding='utf-8')\n    vertices_list = []\n    uv_list = []\n    faces_list = []\n    for l in obj_file:\n        splited_line = l.split(' ')\n        if splited_line[0] == 'v':\n            split_x = splited_line[1].split('\\n')\n            x = float(split_x[0])\n            split_y = splited_line[2].split('\\n')\n            y = float(split_y[0])\n            split_z = splited_line[3].split('\\n')\n            try:\n                z = float(split_z[0])\n            except ValueError:\n                print('WARNING: disable line wrap when saving .obj')\n            vertices_list.append([x, y ,z])\n        elif splited_line[0] == 'f':\n            v_list = []\n            L = len(splited_line)\n            try:\n                for i in range(1, L):\n                    splited_face_data = splited_line[i].split('/')\n                    v_list.append(int(splited_face_data[0]) - 1 )\n                faces_list.append(v_list)\n            except ValueError:\n                v_list = []\n                for i in range(1, L-1):\n                    v_list.append(int(splited_line[i]) - 1 )\n                faces_list.append(v_list)\n        if splited_line[0] == 'vt':\n            split_u = splited_line[1].split('\\n')\n            u = float(split_u[0])\n            split_v = splited_line[2].split('\\n')\n            v = float(split_v[0])\n            vertices_list.append([u,v])\n        if len(uv_list) &gt; 0:\n            self._uv = np.array(uv_list)\n    self.make_mesh(vertices_list, faces_list)\n</code></pre>"},{"location":"functions/meshpy/#meshpy.scale","title":"<code>scale(self, factor, center=[0, 0, 0])</code>","text":"<p>Scales the mesh by a specified factor relative to a center point.</p> <p>This function scales the mesh by multiplying each vertex position by the  specified factor, relative to a given center point.</p> <p>The main logic involves:</p> <ol> <li> <p>Translating the mesh to the origin by subtracting the center point.</p> </li> <li> <p>Scaling the mesh by the specified factor.</p> </li> <li> <p>Translating the mesh back to the original center point.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>factor</code> <code>float</code> <p>The scaling factor to apply to the mesh.</p> required <code>center</code> <code>list or numpy array, optional (default=[0, 0, 0])</code> <p>The center point relative to which the mesh is scaled.</p> <code>[0, 0, 0]</code> <p>Returns:</p> Type Description <code>None</code> <p>The mesh vertices are updated in place.</p> Note <p>This function assumes that the scaling factor is non-zero. The mesh is scaled based on the current vertex positions.</p> See Also <p>move : Translates the mesh by a specified displacement vector.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def scale(self, factor, center=[0, 0, 0]):\n    \"\"\"\n    Scales the mesh by a specified factor relative to a center point.\n\n    This function scales the mesh by multiplying each vertex position by the \n    specified factor, relative to a given center point.\n\n    The main logic involves:\n\n    1. Translating the mesh to the origin by subtracting the center point.\n\n    2. Scaling the mesh by the specified factor.\n\n    3. Translating the mesh back to the original center point.\n\n    Parameters\n    ----------\n    factor : float\n        The scaling factor to apply to the mesh.\n    center : list or numpy array, optional (default=[0, 0, 0])\n        The center point relative to which the mesh is scaled.\n\n    Returns\n    -------\n    None\n        The mesh vertices are updated in place.\n\n    Note\n    ----\n    This function assumes that the scaling factor is non-zero.\n    The mesh is scaled based on the current vertex positions.\n\n    See Also\n    --------\n    move : Translates the mesh by a specified displacement vector.\n    \"\"\"\n    self.vertices[:,:] *= factor\n    self.vertices[:,0] -= center[0]\n    self.vertices[:,1] -= center[1]\n    self.vertices[:,2] -= center[2]\n</code></pre>"},{"location":"functions/meshpy/#meshpy.split_edges","title":"<code>split_edges(self, max_length)</code>","text":"<p>Splits edges in the mesh that exceed a specified maximum length.</p> <p>This function iterates over all edges and splits those that are longer than  the specified maximum length. New vertices are inserted at the midpoints of  these edges, and the mesh topology is updated accordingly.</p> <p>The main logic involves:</p> <ol> <li> <p>Iterating over all edges and checking their lengths.</p> </li> <li> <p>Splitting edges that exceed the maximum length.</p> </li> <li> <p>Updating the mesh topology with new vertices and edges.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>max_length</code> <code>float</code> <p>The maximum allowed length for edges.</p> required <p>Returns:</p> Name Type Description <code>success</code> <code>bool</code> <p>Whether the edge splitting was successful.</p> Note <p>This function assumes that the mesh is a triangular mesh. The mesh topology is updated to ensure all edges are within the specified length.</p> See Also <p>collapse_edges : Collapses edges that are shorter than a specified minimum length.</p> <p>equalize_valences : Balances vertex valences in the mesh.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def split_edges(self, max_length):\n    \"\"\"\n    Splits edges in the mesh that exceed a specified maximum length.\n\n    This function iterates over all edges and splits those that are longer than \n    the specified maximum length. New vertices are inserted at the midpoints of \n    these edges, and the mesh topology is updated accordingly.\n\n    The main logic involves:\n\n    1. Iterating over all edges and checking their lengths.\n\n    2. Splitting edges that exceed the maximum length.\n\n    3. Updating the mesh topology with new vertices and edges.\n\n    Parameters\n    ----------\n    max_length : float\n        The maximum allowed length for edges.\n\n    Returns\n    -------\n    success : bool\n        Whether the edge splitting was successful.\n\n    Note\n    ----\n    This function assumes that the mesh is a triangular mesh.\n    The mesh topology is updated to ensure all edges are within the specified length.\n\n    See Also\n    --------\n    collapse_edges : Collapses edges that are shorter than a specified minimum length.\n\n    equalize_valences : Balances vertex valences in the mesh.\n    \"\"\"\n    if not self.is_triangular_mesh():\n        return False\n    H = self.halfedges\n    _, he = np.unique(H[:,5], return_index=True)\n    self._expand_arrays(len(he))\n    for h in he:\n        if self.halfedge_length(h) &gt; max_length:\n            self._split_halfedge(h)\n    self._cull_arrays()\n    return True\n</code></pre>"},{"location":"functions/meshpy/#meshpy.split_edge","title":"<code>split_edge(self, edge_index)</code>","text":"<p>Splits the specified edge into two edges by inserting a new vertex.</p> <p>This function subdivides the specified edge by adding a new vertex at its midpoint. The new vertex is connected to the original vertices of the edge.</p> <p>The main logic involves:</p> <ol> <li> <p>Identifying the half-edges associated with the edge.</p> </li> <li> <p>Inserting a new vertex at the midpoint of the edge.</p> </li> <li> <p>Creating new half-edges and updating the mesh topology.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>edge_index</code> <code>int</code> <p>The index of the edge to be split.</p> required <p>Returns:</p> Name Type Description <code>success</code> <code>bool</code> <p>Whether the edge split was successful.</p> Note <p>This function assumes that the specified edge exists in the mesh. The edge split is only performed if it results in a valid mesh topology.</p> See Also <p>flip_edge : Flips an edge by swapping its adjacent faces.</p> <p>collapse_edge : Collapses an edge into a single vertex.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def split_edge(self, edge_index):\n    \"\"\"\n    Splits the specified edge into two edges by inserting a new vertex.\n\n    This function subdivides the specified edge by adding a new vertex at its midpoint.\n    The new vertex is connected to the original vertices of the edge.\n\n    The main logic involves:\n\n    1. Identifying the half-edges associated with the edge.\n\n    2. Inserting a new vertex at the midpoint of the edge.\n\n    3. Creating new half-edges and updating the mesh topology.\n\n    Parameters\n    ----------\n    edge_index : int\n        The index of the edge to be split.\n\n    Returns\n    -------\n    success : bool\n        Whether the edge split was successful.\n\n    Note\n    ----\n    This function assumes that the specified edge exists in the mesh.\n    The edge split is only performed if it results in a valid mesh topology.\n\n    See Also\n    --------\n    flip_edge : Flips an edge by swapping its adjacent faces.\n\n    collapse_edge : Collapses an edge into a single vertex.\n    \"\"\"\n    h = self.edge_halfedge(edge_index)\n    if not self.is_halfedge_bounding_tri_faces(h):\n        return False\n    self._expand_arrays()\n    self._split_halfedge(h)\n    self._cull_arrays()\n</code></pre>"},{"location":"functions/meshpy/#meshpy.twin","title":"<code>twin(self, halfedge_index=None)</code>","text":"<p>Retrieves the twin half-edge of a specified half-edge.</p> <p>This function returns the index of the twin half-edge, which is the counterpart  of the specified half-edge across the shared edge.</p> <p>Parameters:</p> Name Type Description Default <code>halfedge_index</code> <code>(int, optional(default=None))</code> <p>The index of the half-edge. If None, returns the twin half-edges for all half-edges.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>twin_halfedge</code> <code>int or numpy array</code> <p>The index of the twin half-edge, or an array of twin half-edges for all half-edges.</p> Note <p>This function assumes that the specified half-edge exists in the mesh. The twin half-edge is part of the same edge as the specified half-edge but belongs to a different face.</p> See Also <p>origin : Retrieves the origin vertex of a half-edge.</p> <p>face : Retrieves the face associated with a half-edge.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def twin(self, halfedge_index=None):\n    \"\"\"\n    Retrieves the twin half-edge of a specified half-edge.\n\n    This function returns the index of the twin half-edge, which is the counterpart \n    of the specified half-edge across the shared edge.\n\n    Parameters\n    ----------\n    halfedge_index : int, optional (default=None)\n        The index of the half-edge. If None, returns the twin half-edges for all half-edges.\n\n    Returns\n    -------\n    twin_halfedge : int or numpy array\n        The index of the twin half-edge, or an array of twin half-edges for all half-edges.\n\n    Note\n    ----\n    This function assumes that the specified half-edge exists in the mesh.\n    The twin half-edge is part of the same edge as the specified half-edge but belongs to a different face.\n\n    See Also\n    --------\n    origin : Retrieves the origin vertex of a half-edge.\n\n    face : Retrieves the face associated with a half-edge.\n    \"\"\"\n    H = self.halfedges\n    if halfedge_index is None:\n        return H[:,4]\n    return H[halfedge_index,4]\n</code></pre>"},{"location":"functions/meshpy/#meshpy.vertex_double_ring_vertices_iterators","title":"<code>vertex_double_ring_vertices_iterators(self)</code>","text":"<p>Iterates over the vertices in the double ring around each vertex.</p> <p>This function provides iterators for the vertices in the double ring around  each vertex, which includes the vertex ring and the vertices adjacent to it.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>v</code> <code>numpy array</code> <p>The indices of the central vertices.</p> <code>vj</code> <code>numpy array</code> <p>The indices of the vertices in the double ring.</p> Note <p>This function assumes that the mesh is manifold and orientable. The double ring vertices are useful for local mesh analysis and processing.</p> See Also <p>vertex_ring_vertices_iterators : Iterates over vertices in the vertex ring.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def vertex_double_ring_vertices_iterators(self):\n    \"\"\"\n    Iterates over the vertices in the double ring around each vertex.\n\n    This function provides iterators for the vertices in the double ring around \n    each vertex, which includes the vertex ring and the vertices adjacent to it.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    v : numpy array\n        The indices of the central vertices.\n    vj : numpy array\n        The indices of the vertices in the double ring.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The double ring vertices are useful for local mesh analysis and processing.\n\n    See Also\n    --------\n    vertex_ring_vertices_iterators : Iterates over vertices in the vertex ring.\n    \"\"\"\n    #import time\n    #t0 = time.time()\n    v, vj = self.vertex_ring_vertices_iterators(sort=True)\n    M = coo_matrix((vj, (v, vj)), shape=(self.V, self.V))\n    M = M.todense()\n    ring = np.copy(M)\n    while v.shape[0] &gt; 0:\n        vi, j = np.unique(v, True)\n        ring[vi] += M[vj[j]]\n        v = np.delete(v, j)\n        vj = np.delete(vj, j)\n    #t4 = time.time()\n    #print(t4-t0)\n    return ring.nonzero()\n</code></pre>"},{"location":"functions/meshpy/#meshpy.vertex_double_ring_vertices_list","title":"<code>vertex_double_ring_vertices_list(self)</code>","text":"<p>Returns a list of double rings for each vertex.</p> <p>This function constructs a list where each entry corresponds to a vertex and  contains the indices of vertices in its double ring.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>ring_list</code> <code>list of lists</code> <p>A list where each entry is a list of vertex indices in the double ring.</p> Note <p>This function assumes that the mesh is manifold and orientable. The double ring vertices are useful for local mesh analysis and processing.</p> See Also <p>vertex_double_ring_vertices_iterators : Iterates over vertices in the double ring.</p> <p>vertex_ring_vertices_list : Returns a list of vertex rings for each vertex.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def vertex_double_ring_vertices_list(self):\n    \"\"\"\n    Returns a list of double rings for each vertex.\n\n    This function constructs a list where each entry corresponds to a vertex and \n    contains the indices of vertices in its double ring.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    ring_list : list of lists\n        A list where each entry is a list of vertex indices in the double ring.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The double ring vertices are useful for local mesh analysis and processing.\n\n    See Also\n    --------\n    vertex_double_ring_vertices_iterators : Iterates over vertices in the double ring.\n\n    vertex_ring_vertices_list : Returns a list of vertex rings for each vertex.\n    \"\"\"\n    ring_list = [[] for i in range(self.V)]\n    v, vj = self.vertex_double_ring_vertices_iterators()\n    for i in range(len(v)):\n        ring_list[v[i]].append(vj[i])\n    return ring_list\n</code></pre>"},{"location":"functions/meshpy/#meshpy.vertex_halfedge","title":"<code>vertex_halfedge(self, vertex_index)</code>","text":"<p>Retrieves a half-edge originating from a specified vertex.</p> <p>This function returns one of the half-edges that starts at the specified vertex. The returned half-edge can be used to traverse the mesh topology.</p> <p>The main logic involves:</p> <ol> <li> <p>Searching for a half-edge that originates from the specified vertex.</p> </li> <li> <p>Returning the index of the found half-edge.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>vertex_index</code> <code>int</code> <p>The index of the vertex.</p> required <p>Returns:</p> Name Type Description <code>halfedge_index</code> <code>int</code> <p>The index of a half-edge originating from the specified vertex.</p> Note <p>This function assumes that the specified vertex exists in the mesh. The returned half-edge can be used for further mesh traversal and manipulation.</p> See Also <p>halfedge_ring : Retrieves the half-edge ring around a specified half-edge.</p> <p>vertex_ring_vertices : Retrieves the vertices in the vertex ring around a specified vertex.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def vertex_halfedge(self, vertex_index):\n    \"\"\"\n    Retrieves a half-edge originating from a specified vertex.\n\n    This function returns one of the half-edges that starts at the specified vertex.\n    The returned half-edge can be used to traverse the mesh topology.\n\n    The main logic involves:\n\n    1. Searching for a half-edge that originates from the specified vertex.\n\n    2. Returning the index of the found half-edge.\n\n    Parameters\n    ----------\n    vertex_index : int\n        The index of the vertex.\n\n    Returns\n    -------\n    halfedge_index : int\n        The index of a half-edge originating from the specified vertex.\n\n    Note\n    ----\n    This function assumes that the specified vertex exists in the mesh.\n    The returned half-edge can be used for further mesh traversal and manipulation.\n\n    See Also\n    --------\n    halfedge_ring : Retrieves the half-edge ring around a specified half-edge.\n\n    vertex_ring_vertices : Retrieves the vertices in the vertex ring around a specified vertex.\n    \"\"\"\n    H = self.halfedges\n    v = np.where(H[:,0] == vertex_index)[0][0]\n    return v\n</code></pre>"},{"location":"functions/meshpy/#meshpy.vertex_local_frame","title":"<code>vertex_local_frame(self)</code>","text":"<p>Computes a local coordinate frame (origin, x, y, z) for each vertex.</p> <p>This function assigns a local frame to each vertex, where: - The origin is the vertex position. - The z-axis is aligned with the vertex normal. - The x and y axes are orthogonal to the z-axis and each other.</p> <p>The main logic involves:</p> <ol> <li> <p>Computing the vertex normals.</p> </li> <li> <p>Finding orthogonal vectors to the vertex normals.</p> </li> <li> <p>Constructing the local frames.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>frame</code> <code>Frame object</code> <p>A Frame object containing the local frames for each vertex.</p> Note <p>This function assumes that the mesh is manifold and orientable. The local frames are computed based on the current vertex positions and normals.</p> See Also <p>vertex_normals : Computes the normal vectors of all vertices.</p> <p>Frame : A class representing a local coordinate frame.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def vertex_local_frame(self):\n    \"\"\"\n    Computes a local coordinate frame (origin, x, y, z) for each vertex.\n\n    This function assigns a local frame to each vertex, where:\n    - The origin is the vertex position.\n    - The z-axis is aligned with the vertex normal.\n    - The x and y axes are orthogonal to the z-axis and each other.\n\n    The main logic involves:\n\n    1. Computing the vertex normals.\n\n    2. Finding orthogonal vectors to the vertex normals.\n\n    3. Constructing the local frames.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    frame : Frame object\n        A Frame object containing the local frames for each vertex.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The local frames are computed based on the current vertex positions and normals.\n\n    See Also\n    --------\n    vertex_normals : Computes the normal vectors of all vertices.\n\n    Frame : A class representing a local coordinate frame.\n    \"\"\"\n    o = self.vertices\n    z = self.vertex_normals()\n    x = utilities.orthogonal_vectors(z)\n    y = np.cross(z,x)\n    frame = Frame(o, x, y, z)\n    return frame\n</code></pre>"},{"location":"functions/meshpy/#meshpy.vertex_normals","title":"<code>vertex_normals(self)</code>","text":"<p>Computes the normal vectors for each vertex in the mesh.</p> <p>This function calculates the vertex normals by averaging the face normals of the faces adjacent to each vertex. The resulting normals are normalized to ensure they are unit vectors.</p> <p>The main logic involves:</p> <ol> <li> <p>Iterating over each vertex to identify its adjacent faces.</p> </li> <li> <p>Summing the face normals of these adjacent faces.</p> </li> <li> <p>Normalizing the summed vector to obtain the vertex normal.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>normals</code> <code>numpy array</code> <p>An array of vertex normals, where each normal is a unit vector [nx, ny, nz].</p> Note <p>This function assumes that the mesh is manifold and orientable. The vertex normals are computed based on the current face normals and mesh topology.</p> See Also <p>face_normals : Computes the normal vectors for each face.</p> <p>edge_normals : Computes the normal vectors for each edge.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def vertex_normals(self):\n    \"\"\"\n    Computes the normal vectors for each vertex in the mesh.\n\n    This function calculates the vertex normals by averaging the face normals\n    of the faces adjacent to each vertex. The resulting normals are normalized\n    to ensure they are unit vectors.\n\n    The main logic involves:\n\n    1. Iterating over each vertex to identify its adjacent faces.\n\n    2. Summing the face normals of these adjacent faces.\n\n    3. Normalizing the summed vector to obtain the vertex normal.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    normals : numpy array\n        An array of vertex normals, where each normal is a unit vector [nx, ny, nz].\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The vertex normals are computed based on the current face normals and mesh topology.\n\n    See Also\n    --------\n    face_normals : Computes the normal vectors for each face.\n\n    edge_normals : Computes the normal vectors for each edge.\n    \"\"\"\n    N = self.face_vector_areas()\n    v, fi = self.vertex_ring_faces_iterators(sort=True)\n    N = N[fi,:]\n    normals = utilities.sum_repeated(N, v)\n    normals = normals / np.linalg.norm(normals, axis=1, keepdims=True)\n    return normals\n</code></pre>"},{"location":"functions/meshpy/#meshpy.vertex_ring_edges_iterators","title":"<code>vertex_ring_edges_iterators(self, sort=False, order=False)</code>","text":"<p>Iterates over the edges in the vertex ring around each vertex.</p> <p>This function provides iterators for the edges in the vertex ring around  each vertex, with options for sorting and ordering.</p> <p>Parameters:</p> Name Type Description Default <code>sort</code> <code>(bool, optional(default=False))</code> <p>Whether to sort the edges by edge index.</p> <code>False</code> <code>order</code> <code>(bool, optional(default=False))</code> <p>Whether to order the edges by traversal direction.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>v</code> <code>numpy array</code> <p>The indices of the central vertices.</p> <code>ej</code> <code>numpy array</code> <p>The indices of the adjacent edges in the vertex ring.</p> Note <p>This function assumes that the mesh is manifold and orientable. The vertex ring edges are useful for local mesh analysis and processing.</p> See Also <p>vertex_ring_vertices_iterators : Iterates over vertices in the vertex ring.</p> <p>vertex_ring_faces_iterators : Iterates over faces in the vertex ring.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def vertex_ring_edges_iterators(self, sort=False, order=False):\n    \"\"\"\n    Iterates over the edges in the vertex ring around each vertex.\n\n    This function provides iterators for the edges in the vertex ring around \n    each vertex, with options for sorting and ordering.\n\n    Parameters\n    ----------\n    sort : bool, optional (default=False)\n        Whether to sort the edges by edge index.\n    order : bool, optional (default=False)\n        Whether to order the edges by traversal direction.\n\n    Returns\n    -------\n    v : numpy array\n        The indices of the central vertices.\n    ej : numpy array\n        The indices of the adjacent edges in the vertex ring.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The vertex ring edges are useful for local mesh analysis and processing.\n\n    See Also\n    --------\n    vertex_ring_vertices_iterators : Iterates over vertices in the vertex ring.\n\n    vertex_ring_faces_iterators : Iterates over faces in the vertex ring.\n    \"\"\"\n    H = self.halfedges\n    v  = H[:,0]\n    ej = H[:,5]\n    if order:\n        i  = self.vertex_ring_ordered_halfedges()\n        v  = v[i]\n        ej = ej[i]\n    elif sort:\n        i  = np.argsort(v)\n        v  = v[i]\n        ej = ej[i]\n    return v, ej\n</code></pre>"},{"location":"functions/meshpy/#meshpy.vertex_ring_edges_list","title":"<code>vertex_ring_edges_list(self)</code>","text":"<p>Returns a list of edges in the vertex ring for each vertex.</p> <p>This function constructs a list where each entry corresponds to a vertex and  contains the indices of edges in its vertex ring.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>ring_list</code> <code>list of lists</code> <p>A list where each entry is a list of edge indices in the vertex ring.</p> Note <p>This function assumes that the mesh is manifold and orientable. The vertex ring edges are useful for local mesh analysis and processing.</p> See Also <p>vertex_ring_edges_iterators : Iterates over edges in the vertex ring.</p> <p>vertex_ring_vertices_list : Returns a list of vertex rings for each vertex.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def vertex_ring_edges_list(self):\n    \"\"\"\n    Returns a list of edges in the vertex ring for each vertex.\n\n    This function constructs a list where each entry corresponds to a vertex and \n    contains the indices of edges in its vertex ring.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    ring_list : list of lists\n        A list where each entry is a list of edge indices in the vertex ring.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The vertex ring edges are useful for local mesh analysis and processing.\n\n    See Also\n    --------\n    vertex_ring_edges_iterators : Iterates over edges in the vertex ring.\n\n    vertex_ring_vertices_list : Returns a list of vertex rings for each vertex.\n    \"\"\"\n    ring_list = [[] for i in range(self.V)]\n    v, ej = self.vertex_ring_edges_iterators(order=True)\n    for i in range(len(v)):\n        ring_list[v[i]].append(ej[i])\n    return ring_list\n</code></pre>"},{"location":"functions/meshpy/#meshpy.vertex_ring_expansion","title":"<code>vertex_ring_expansion(self, v_index, callback=None, depth=None)</code>","text":"<p>Expands the vertex ring around a specified vertex up to a given depth.</p> <p>This function performs a breadth-first traversal of the mesh starting from  the specified vertex and collects all vertices within the given depth.</p> <p>The main logic involves:</p> <ol> <li> <p>Initializing the traversal from the specified vertex.</p> </li> <li> <p>Iteratively expanding the vertex ring by following adjacent vertices.</p> </li> <li> <p>Optionally applying a callback function to each vertex during traversal.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>v_index</code> <code>int</code> <p>The index of the starting vertex.</p> required <code>callback</code> <code>(function, optional(default=None))</code> <p>An optional callback function to apply to each vertex.</p> <code>None</code> <code>depth</code> <code>(int, optional(default=None))</code> <p>The maximum depth of the traversal. If None, expands to the entire mesh.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>expanded_vertices</code> <code>numpy array</code> <p>The indices of all vertices within the specified depth.</p> Note <p>This function assumes that the mesh is manifold and connected. The vertex ring expansion is based on the current mesh topology.</p> See Also <p>vertex_ring_vertices_iterators : Iterates over vertices in the vertex ring.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def vertex_ring_expansion(self, v_index, callback=None, depth=None):\n    \"\"\"\n    Expands the vertex ring around a specified vertex up to a given depth.\n\n    This function performs a breadth-first traversal of the mesh starting from \n    the specified vertex and collects all vertices within the given depth.\n\n    The main logic involves:\n\n    1. Initializing the traversal from the specified vertex.\n\n    2. Iteratively expanding the vertex ring by following adjacent vertices.\n\n    3. Optionally applying a callback function to each vertex during traversal.\n\n    Parameters\n    ----------\n    v_index : int\n        The index of the starting vertex.\n    callback : function, optional (default=None)\n        An optional callback function to apply to each vertex.\n    depth : int, optional (default=None)\n        The maximum depth of the traversal. If None, expands to the entire mesh.\n\n    Returns\n    -------\n    expanded_vertices : numpy array\n        The indices of all vertices within the specified depth.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and connected.\n    The vertex ring expansion is based on the current mesh topology.\n\n    See Also\n    --------\n    vertex_ring_vertices_iterators : Iterates over vertices in the vertex ring.\n    \"\"\"\n    vi, vj = self.vertex_ring_vertices_iterators()\n    mring = np.full(self.V, False)\n    sring = np.full(self.V, False)\n    search = np.array([v_index], dtype='i')\n    mring[v_index] = True\n    if depth is None:\n        depth = self.V\n    for i in range(depth):\n        sring[:] = False\n        for v in search:\n            ring = vj[vi == v]\n            ring = ring[np.invert(mring[ring])]\n            mring[ring] = True\n            sring[ring] = True\n            if callable(callback):\n                callback(v, ring)\n        search = np.where(sring)[0]\n        if np.all(mring):\n            return np.where(mring)[0]\n    return np.where(mring)[0]\n</code></pre>"},{"location":"functions/meshpy/#meshpy.vertex_ring_faces_iterators","title":"<code>vertex_ring_faces_iterators(self, sort=False, order=False)</code>","text":"<p>Iterates over the faces in the vertex ring around each vertex.</p> <p>This function provides iterators for the faces in the vertex ring around  each vertex, with options for sorting and ordering.</p> <p>Parameters:</p> Name Type Description Default <code>sort</code> <code>(bool, optional(default=False))</code> <p>Whether to sort the faces by face index.</p> <code>False</code> <code>order</code> <code>(bool, optional(default=False))</code> <p>Whether to order the faces by traversal direction.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>v</code> <code>numpy array</code> <p>The indices of the central vertices.</p> <code>fj</code> <code>numpy array</code> <p>The indices of the adjacent faces in the vertex ring.</p> Note <p>This function assumes that the mesh is manifold and orientable. The vertex ring faces are useful for local mesh analysis and processing.</p> See Also <p>vertex_ring_vertices_iterators : Iterates over vertices in the vertex ring.</p> <p>vertex_ring_edges_iterators : Iterates over edges in the vertex ring.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def vertex_ring_faces_iterators(self, sort=False, order=False):\n    \"\"\"\n    Iterates over the faces in the vertex ring around each vertex.\n\n    This function provides iterators for the faces in the vertex ring around \n    each vertex, with options for sorting and ordering.\n\n    Parameters\n    ----------\n    sort : bool, optional (default=False)\n        Whether to sort the faces by face index.\n    order : bool, optional (default=False)\n        Whether to order the faces by traversal direction.\n\n    Returns\n    -------\n    v : numpy array\n        The indices of the central vertices.\n    fj : numpy array\n        The indices of the adjacent faces in the vertex ring.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The vertex ring faces are useful for local mesh analysis and processing.\n\n    See Also\n    --------\n    vertex_ring_vertices_iterators : Iterates over vertices in the vertex ring.\n\n    vertex_ring_edges_iterators : Iterates over edges in the vertex ring.\n    \"\"\"\n    H = self.halfedges\n    if order:\n        i  = self.vertex_ring_ordered_halfedges()\n        v  = H[i,0]\n        fj = H[i,1]\n    else:\n        i  = np.where(H[:,1] &gt;= 0)[0]\n        v  = H[i,0]\n        fj = H[i,1]\n        if sort:\n            i  = np.argsort(v)\n            v  = v[i]\n            fj = fj[i]\n    return v, fj\n</code></pre>"},{"location":"functions/meshpy/#meshpy.vertex_ring_faces_list","title":"<code>vertex_ring_faces_list(self)</code>","text":"<p>Returns a list of faces in the vertex ring for each vertex.</p> <p>This function constructs a list where each entry corresponds to a vertex and  contains the indices of faces in its vertex ring.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>ring_list</code> <code>list of lists</code> <p>A list where each entry is a list of face indices in the vertex ring.</p> Note <p>This function assumes that the mesh is manifold and orientable. The vertex ring faces are useful for local mesh analysis and processing.</p> See Also <p>vertex_ring_faces_iterators : Iterates over faces in the vertex ring.</p> <p>vertex_ring_vertices_list : Returns a list of vertex rings for each vertex.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def vertex_ring_faces_list(self):\n    \"\"\"\n    Returns a list of faces in the vertex ring for each vertex.\n\n    This function constructs a list where each entry corresponds to a vertex and \n    contains the indices of faces in its vertex ring.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    ring_list : list of lists\n        A list where each entry is a list of face indices in the vertex ring.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The vertex ring faces are useful for local mesh analysis and processing.\n\n    See Also\n    --------\n    vertex_ring_faces_iterators : Iterates over faces in the vertex ring.\n\n    vertex_ring_vertices_list : Returns a list of vertex rings for each vertex.\n    \"\"\"\n    ring_list = [[] for i in range(self.V)]\n    v, fj = self.vertex_ring_faces_iterators(order=True)\n    for i in range(len(v)):\n        ring_list[v[i]].append(fj[i])\n    return ring_list\n</code></pre>"},{"location":"functions/meshpy/#meshpy.vertex_ring_ordered_halfedges","title":"<code>vertex_ring_ordered_halfedges(self)</code>","text":"<p>Retrieves the half-edges in the vertex ring around each vertex, ordered by traversal.</p> <p>This function returns the indices of half-edges that form the vertex ring around  each vertex, ordered in a consistent traversal direction.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>ordered_halfedges</code> <code>numpy array</code> <p>The indices of half-edges in the vertex ring, ordered by traversal.</p> Note <p>This function assumes that the mesh is manifold and orientable. The half-edges are ordered to facilitate consistent traversal around each vertex.</p> See Also <p>vertex_ring_vertices_iterators : Iterates over vertices in the vertex ring.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def vertex_ring_ordered_halfedges(self):\n    \"\"\"\n    Retrieves the half-edges in the vertex ring around each vertex, ordered by traversal.\n\n    This function returns the indices of half-edges that form the vertex ring around \n    each vertex, ordered in a consistent traversal direction.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    ordered_halfedges : numpy array\n        The indices of half-edges in the vertex ring, ordered by traversal.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The half-edges are ordered to facilitate consistent traversal around each vertex.\n\n    See Also\n    --------\n    vertex_ring_vertices_iterators : Iterates over vertices in the vertex ring.\n    \"\"\"\n    H = np.copy(self.halfedges)\n    i = np.argsort(H[:,0])\n    v = H[i,0]\n    index = np.arange(H.shape[0])\n    _, j = np.unique(v, True)\n    v = np.delete(v,j)\n    index = np.delete(index,j)\n    while v.shape[0] &gt; 0:\n        _, j = np.unique(v, True)\n        i[index[j]] = H[H[i[index[j] - 1],3],4]\n        v = np.delete(v,j)\n        index = np.delete(index,j)\n    return i\n</code></pre>"},{"location":"functions/meshpy/#meshpy.vertex_ring_parametrization","title":"<code>vertex_ring_parametrization(self)</code>","text":"<p>Computes a parametrization of the vertex ring around each vertex.</p> <p>This function assigns a parametric coordinate (U, V) to each vertex in the  vertex ring, based on the angular position around the central vertex.</p> <p>The main logic involves:</p> <ol> <li> <p>Iterating over each vertex and its adjacent vertices (vertex ring).</p> </li> <li> <p>Computing the angular position of each adjacent vertex.</p> </li> <li> <p>Assigning parametric coordinates (U, V) based on the angular position.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>v</code> <code>numpy array</code> <p>The indices of the central vertices.</p> <code>vj</code> <code>numpy array</code> <p>The indices of the adjacent vertices in the vertex ring.</p> <code>U</code> <code>numpy array</code> <p>The U-coordinates of the parametrization.</p> <code>V</code> <code>numpy array</code> <p>The V-coordinates of the parametrization.</p> Note <p>This function assumes that the mesh is manifold and orientable. The parametrization is based on the current mesh topology and geometry.</p> See Also <p>vertex_ring_vertices_iterators : Iterates over vertices in the vertex ring.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def vertex_ring_parametrization(self):\n    \"\"\"\n    Computes a parametrization of the vertex ring around each vertex.\n\n    This function assigns a parametric coordinate (U, V) to each vertex in the \n    vertex ring, based on the angular position around the central vertex.\n\n    The main logic involves:\n\n    1. Iterating over each vertex and its adjacent vertices (vertex ring).\n\n    2. Computing the angular position of each adjacent vertex.\n\n    3. Assigning parametric coordinates (U, V) based on the angular position.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    v : numpy array\n        The indices of the central vertices.\n    vj : numpy array\n        The indices of the adjacent vertices in the vertex ring.\n    U : numpy array\n        The U-coordinates of the parametrization.\n    V : numpy array\n        The V-coordinates of the parametrization.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The parametrization is based on the current mesh topology and geometry.\n\n    See Also\n    --------\n    vertex_ring_vertices_iterators : Iterates over vertices in the vertex ring.\n    \"\"\"\n    v, vj, l = self.vertex_ring_vertices_iterators(sort=True,\n                                                return_lengths=True)\n    index = np.arange(v.shape[0])\n    step = np.zeros(v.shape[0])\n    _, unique = np.unique(v, return_index=True)\n    vertices = np.delete(v, unique)\n    index = np.delete(index, unique)\n    value = 0\n    while len(vertices) &gt; 0:\n        value += 1\n        _, unique = np.unique(vertices, return_index=True)\n        step[index[unique]] = value\n        vertices = np.delete(vertices, unique)\n        index = np.delete(index, unique)\n    phi = 2*np.pi*step / l[v]\n    U = np.sin(phi)\n    V = np.cos(phi)\n    return v, vj, U, V\n</code></pre>"},{"location":"functions/meshpy/#meshpy.vertex_ring_vertices","title":"<code>vertex_ring_vertices(self, vertex_index)</code>","text":"<p>Retrieves the vertices in the vertex ring around a specified vertex.</p> <p>This function returns the sequence of vertices that are directly connected to  the specified vertex. The vertex ring can be used to traverse the mesh topology.</p> <p>The main logic involves:</p> <ol> <li> <p>Starting from a half-edge originating from the specified vertex.</p> </li> <li> <p>Iteratively following the next half-edge in the loop to collect adjacent vertices.</p> </li> <li> <p>Returning the sequence of vertices in the vertex ring.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>vertex_index</code> <code>int</code> <p>The index of the vertex.</p> required <p>Returns:</p> Name Type Description <code>ring_vertices</code> <code>list of int</code> <p>The indices of vertices in the vertex ring.</p> Note <p>This function assumes that the specified vertex exists in the mesh. The vertex ring can be used for further mesh traversal and manipulation.</p> See Also <p>vertex_halfedge : Retrieves a half-edge originating from a specified vertex.</p> <p>halfedge_ring : Retrieves the half-edge ring around a specified half-edge.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def vertex_ring_vertices(self, vertex_index):\n    \"\"\"\n    Retrieves the vertices in the vertex ring around a specified vertex.\n\n    This function returns the sequence of vertices that are directly connected to \n    the specified vertex. The vertex ring can be used to traverse the mesh topology.\n\n    The main logic involves:\n\n    1. Starting from a half-edge originating from the specified vertex.\n\n    2. Iteratively following the next half-edge in the loop to collect adjacent vertices.\n\n    3. Returning the sequence of vertices in the vertex ring.\n\n    Parameters\n    ----------\n    vertex_index : int\n        The index of the vertex.\n\n    Returns\n    -------\n    ring_vertices : list of int\n        The indices of vertices in the vertex ring.\n\n    Note\n    ----\n    This function assumes that the specified vertex exists in the mesh.\n    The vertex ring can be used for further mesh traversal and manipulation.\n\n    See Also\n    --------\n    vertex_halfedge : Retrieves a half-edge originating from a specified vertex.\n\n    halfedge_ring : Retrieves the half-edge ring around a specified half-edge.\n    \"\"\"\n    h = self.vertex_halfedge(vertex_index)\n    ring = self.halfedge_ring_vertices(h)\n    return ring\n</code></pre>"},{"location":"functions/meshpy/#meshpy.vertex_ring_vertices_iterators","title":"<code>vertex_ring_vertices_iterators(self, sort=False, order=False, return_lengths=False)</code>","text":"<p>Iterates over the vertices in the vertex ring around each vertex.</p> <p>This function provides iterators for the vertices in the vertex ring around  each vertex, with options for sorting and ordering.</p> <p>Parameters:</p> Name Type Description Default <code>sort</code> <code>(bool, optional(default=False))</code> <p>Whether to sort the vertices by vertex index.</p> <code>False</code> <code>order</code> <code>(bool, optional(default=False))</code> <p>Whether to order the vertices by traversal direction.</p> <code>False</code> <code>return_lengths</code> <code>(bool, optional(default=False))</code> <p>Whether to return the lengths of the vertex rings.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>v</code> <code>numpy array</code> <p>The indices of the central vertices.</p> <code>vj</code> <code>numpy array</code> <p>The indices of the adjacent vertices in the vertex ring.</p> <code>lengths</code> <code>numpy array, optional</code> <p>The lengths of the vertex rings (returned if <code>return_lengths=True</code>).</p> Note <p>This function assumes that the mesh is manifold and orientable. The vertex ring vertices are useful for local mesh analysis and processing.</p> See Also <p>vertex_ring_faces_iterators : Iterates over faces in the vertex ring.</p> <p>vertex_ring_edges_iterators : Iterates over edges in the vertex ring.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def vertex_ring_vertices_iterators(self, sort=False, order=False, return_lengths=False):\n    \"\"\"\n    Iterates over the vertices in the vertex ring around each vertex.\n\n    This function provides iterators for the vertices in the vertex ring around \n    each vertex, with options for sorting and ordering.\n\n    Parameters\n    ----------\n    sort : bool, optional (default=False)\n        Whether to sort the vertices by vertex index.\n    order : bool, optional (default=False)\n        Whether to order the vertices by traversal direction.\n    return_lengths : bool, optional (default=False)\n        Whether to return the lengths of the vertex rings.\n\n    Returns\n    -------\n    v : numpy array\n        The indices of the central vertices.\n    vj : numpy array\n        The indices of the adjacent vertices in the vertex ring.\n    lengths : numpy array, optional\n        The lengths of the vertex rings (returned if `return_lengths=True`).\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The vertex ring vertices are useful for local mesh analysis and processing.\n\n    See Also\n    --------\n    vertex_ring_faces_iterators : Iterates over faces in the vertex ring.\n\n    vertex_ring_edges_iterators : Iterates over edges in the vertex ring.\n    \"\"\"\n    H = self.halfedges\n    v  = H[:,0]\n    vj = H[H[:,4],0]\n    if order:\n        i  = self.vertex_ring_ordered_halfedges()\n        v  = v[i]\n        vj = vj[i]\n    elif sort:\n        i  = np.argsort(v)\n        v  = v[i]\n        vj = vj[i]\n    if return_lengths:\n        i  = np.ones(vj.shape[0], dtype=int)\n        lj = utilities.sum_repeated(i,v)\n        return v, vj, lj\n    else:\n        return v, vj\n</code></pre>"},{"location":"functions/meshpy/#meshpy.vertex_ring_vertices_list","title":"<code>vertex_ring_vertices_list(self)</code>","text":"<p>Returns a list of vertex rings for each vertex.</p> <p>This function constructs a list where each entry corresponds to a vertex and  contains the indices of vertices in its vertex ring.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>ring_list</code> <code>list of lists</code> <p>A list where each entry is a list of vertex indices in the vertex ring.</p> Note <p>This function assumes that the mesh is manifold and orientable. The vertex ring vertices are useful for local mesh analysis and processing.</p> See Also <p>vertex_ring_vertices_iterators : Iterates over vertices in the vertex ring.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def vertex_ring_vertices_list(self):\n    \"\"\"\n    Returns a list of vertex rings for each vertex.\n\n    This function constructs a list where each entry corresponds to a vertex and \n    contains the indices of vertices in its vertex ring.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    ring_list : list of lists\n        A list where each entry is a list of vertex indices in the vertex ring.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The vertex ring vertices are useful for local mesh analysis and processing.\n\n    See Also\n    --------\n    vertex_ring_vertices_iterators : Iterates over vertices in the vertex ring.\n    \"\"\"\n    ring_list = [[] for i in range(self.V)]\n    v, vj = self.vertex_ring_vertices_iterators(order=True)\n    for i in range(len(v)):\n        ring_list[v[i]].append(vj[i])\n    return ring_list\n</code></pre>"},{"location":"functions/meshpy/#meshpy.vertex_multiple_ring_vertices","title":"<code>vertex_multiple_ring_vertices(self, vertex_index, depth=1)</code>","text":"<p>Retrieves the vertices within a specified depth from a given vertex.</p> <p>This function performs a breadth-first traversal starting from the specified  vertex and collects all vertices within the specified depth. The result  includes the starting vertex and all vertices reachable within the given depth.</p> <p>The main logic involves:</p> <ol> <li> <p>Initializing a queue with the starting vertex.</p> </li> <li> <p>Iteratively expanding the vertex ring up to the specified depth.</p> </li> <li> <p>Collecting all visited vertices.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>vertex_index</code> <code>int</code> <p>The index of the starting vertex.</p> required <code>depth</code> <code>(int, optional(default=1))</code> <p>The maximum depth of traversal.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>ring_vertices</code> <code>numpy array</code> <p>The indices of vertices within the specified depth.</p> Note <p>This function assumes that the mesh is manifold and orientable. The traversal is based on the current mesh topology.</p> See Also <p>vertex_ring_vertices : Retrieves the vertices in the immediate vertex ring.</p> <p>ertex_ring_expansion : Expands the vertex ring with optional callbacks.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def vertex_multiple_ring_vertices(self, vertex_index, depth=1):\n    \"\"\"\n    Retrieves the vertices within a specified depth from a given vertex.\n\n    This function performs a breadth-first traversal starting from the specified \n    vertex and collects all vertices within the specified depth. The result \n    includes the starting vertex and all vertices reachable within the given depth.\n\n    The main logic involves:\n\n    1. Initializing a queue with the starting vertex.\n\n    2. Iteratively expanding the vertex ring up to the specified depth.\n\n    3. Collecting all visited vertices.\n\n    Parameters\n    ----------\n    vertex_index : int\n        The index of the starting vertex.\n    depth : int, optional (default=1)\n        The maximum depth of traversal.\n\n    Returns\n    -------\n    ring_vertices : numpy array\n        The indices of vertices within the specified depth.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The traversal is based on the current mesh topology.\n\n    See Also\n    --------\n    vertex_ring_vertices : Retrieves the vertices in the immediate vertex ring.\n\n    ertex_ring_expansion : Expands the vertex ring with optional callbacks.\n    \"\"\"\n    vi, vj = self.vertex_ring_vertices_iterators()\n    ring = np.array([], dtype='i')\n    search = np.array([vertex_index], dtype='i')\n    for i in range(int(depth)):\n        vring = np.array([], dtype='i')\n        for v in search:\n            vring = np.hstack((vj[vi == v], vring))\n        vring = np.unique(vring)\n        vring = vring[np.invert(np.in1d(vring, ring))]\n        search = vring\n        ring = np.hstack((ring, vring))\n        if len(ring) == self.V:\n            return ring\n    return np.unique(ring)\n</code></pre>"},{"location":"functions/meshpy/#meshpy.vertices_edge_faces_maps","title":"<code>vertices_edge_faces_maps(self)</code>","text":"<p>Creates sparse matrices mapping vertex pairs to edge and face indices.</p> <p>This function constructs sparse matrices where each entry corresponds to a  pair of vertices and contains the indices of the edge and adjacent faces.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>f1Map</code> <code>coo_matrix</code> <p>A sparse matrix mapping vertex pairs to the first adjacent face.</p> <code>f2Map</code> <code>coo_matrix</code> <p>A sparse matrix mapping vertex pairs to the second adjacent face.</p> Note <p>This function assumes that the mesh is manifold and orientable. The maps are useful for efficient lookups and mesh analysis.</p> See Also <p>vertices_edge_map : Creates a map for vertices and edges.</p> <p>edge_faces : Retrieves the faces adjacent to each edge.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def vertices_edge_faces_maps(self):\n    \"\"\"\n    Creates sparse matrices mapping vertex pairs to edge and face indices.\n\n    This function constructs sparse matrices where each entry corresponds to a \n    pair of vertices and contains the indices of the edge and adjacent faces.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    f1Map : scipy.sparse.coo_matrix\n        A sparse matrix mapping vertex pairs to the first adjacent face.\n    f2Map : scipy.sparse.coo_matrix\n        A sparse matrix mapping vertex pairs to the second adjacent face.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The maps are useful for efficient lookups and mesh analysis.\n\n    See Also\n    --------\n    vertices_edge_map : Creates a map for vertices and edges.\n\n    edge_faces : Retrieves the faces adjacent to each edge.\n    \"\"\"\n    H  = self.halfedges\n    v1 = H[:,0]\n    v2 = H[H[:,4],0]\n    f1 = H[:,1]\n    f2 = H[H[:,4],1]\n    f1Map = coo_matrix((f1, (v1,v2)), shape=(self.V, self.V))\n    f2Map = coo_matrix((f2, (v1,v2)), shape=(self.V, self.V))\n    f1Map = f1Map.tocsc()\n    f2Map = f2Map.tocsc()\n    return f1Map, f2Map\n</code></pre>"},{"location":"functions/meshpy/#meshpy.vertices_edge_map","title":"<code>vertices_edge_map(self)</code>","text":"<p>Creates a sparse matrix mapping vertex pairs to edge indices.</p> <p>This function constructs a sparse matrix where each entry corresponds to a  pair of vertices and contains the index of the edge connecting them.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>edge_map</code> <code>coo_matrix</code> <p>A sparse matrix mapping vertex pairs to edge indices.</p> Note <p>This function assumes that the mesh is manifold and orientable. The edge map is useful for efficient edge lookups and mesh analysis.</p> See Also <p>vertices_edge_faces_maps : Creates maps for vertices, edges, and faces.</p> <p>edge_vertices : Retrieves the vertices of each edge.</p> Source code in <code>src/geometry/meshpy.py</code> <pre><code>def vertices_edge_map(self):\n    \"\"\"\n    Creates a sparse matrix mapping vertex pairs to edge indices.\n\n    This function constructs a sparse matrix where each entry corresponds to a \n    pair of vertices and contains the index of the edge connecting them.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    edge_map : scipy.sparse.coo_matrix\n        A sparse matrix mapping vertex pairs to edge indices.\n\n    Note\n    ----\n    This function assumes that the mesh is manifold and orientable.\n    The edge map is useful for efficient edge lookups and mesh analysis.\n\n    See Also\n    --------\n    vertices_edge_faces_maps : Creates maps for vertices, edges, and faces.\n\n    edge_vertices : Retrieves the vertices of each edge.\n    \"\"\"\n    H  = self.halfedges\n    v1 = H[:,0]\n    v2 = H[H[:,4],0]\n    e  = H[:,5]\n    edge_map = coo_matrix((e, (v1,v2)), shape=(self.V, self.V))\n    edge_map = edge_map.tocsc()\n    return edge_map\n</code></pre>"},{"location":"functions/quadrings/","title":"Quadrings","text":"<p>forked and built on geometrylab/geometry/meshpy.py</p> <p>meshpy.py --&gt; quadrings.py --&gt; gridshell_new.py(GeolabGUI)--&gt; gui_basic.py --&gt; guidedprojection_net.py + opt_din.py --&gt; read_file</p>"},{"location":"functions/quadrings/#quadrings.boundary_vertex_3neibs","title":"<code>boundary_vertex_3neibs(self)</code>","text":"<p>Retrieves the neighbors of boundary vertices with valence 3.</p> <p>This function identifies the neighbors of boundary vertices that have  valence 3 and returns their indices.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>boundary_vertices</code> <code>numpy array</code> <p>Indices of boundary vertices with valence 3.</p> <code>left_neighbors</code> <code>numpy array</code> <p>Indices of the left neighbors.</p> <code>right_neighbors</code> <code>numpy array</code> <p>Indices of the right neighbors.</p> <code>inner_neighbors</code> <code>numpy array</code> <p>Indices of the inner neighbors.</p> Note <p>This function assumes that the mesh is a regular mesh. The neighbors are useful for mesh analysis and processing.</p> <p>bdry(include corner) --&gt; return [vl,vr,vinn]; vl,vr in bdry, vinn in inner bdry_3neibs[0]:= 2nd_boundary_vertices, including corners bdry_3neibs[1]:= left of bdry_vertices bdry_3neibs[2]:= right of bdry_vertices</p> See Also <p>boundary_vertices : Retrieves the indices of boundary vertices.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def boundary_vertex_3neibs(self):\n    \"\"\"\n    Retrieves the neighbors of boundary vertices with valence 3.\n\n    This function identifies the neighbors of boundary vertices that have \n    valence 3 and returns their indices.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    boundary_vertices : numpy array\n        Indices of boundary vertices with valence 3.\n    left_neighbors : numpy array\n        Indices of the left neighbors.\n    right_neighbors : numpy array\n        Indices of the right neighbors.\n    inner_neighbors : numpy array\n        Indices of the inner neighbors.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The neighbors are useful for mesh analysis and processing.\n\n    bdry(include corner) --&gt; return [vl,vr,vinn];\n    vl,vr in bdry, vinn in inner\n    bdry_3neibs[0]:= 2nd_boundary_vertices, including corners\n    bdry_3neibs[1]:= left of bdry_vertices\n    bdry_3neibs[2]:= right of bdry_vertices\n\n    See Also\n    --------\n    boundary_vertices : Retrieves the indices of boundary vertices.\n    \"\"\"\n    H = self.halfedges\n    ibdry = self.boundary_vertices()\n    vl,vr,vinn = [],[],[]\n    for v in ibdry:\n        ie = np.where(H[:,0]==v)[0]\n        if len(ie)==3:\n            \"bdry vertex of valence 3\"\n            inn = np.intersect1d(np.where(H[ie,1]!=-1)[0],np.where(H[H[ie,4],1]!=-1)[0])\n            j = ie[inn][0]\n            vinn.append(H[H[j,4],0])\n            vl.append(H[H[j,3],0])\n            vr.append(H[H[H[H[j,4],2],4],0])\n        elif len(ie)==2:\n            \"corner with valence 2\"          \n            if H[ie[0],1]==-1:\n                j = ie[0][0]\n            else:\n                j = ie[1][0]\n            vl.append(H[H[j,4],0])\n            vr.append(H[H[j,3],0])\n            vinn.append([H[H[H[j,4],3],0]])\n    self._ver_bdry_3neibs = [ibdry,np.array(vinn),np.array(vl),np.array(vr)]\n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_1family_oriented_polyline","title":"<code>get_1family_oriented_polyline(self, diagnet=False, poly2=True)</code>","text":"<p>Retrieves one family of oriented polylines from the mesh.</p> <p>This function identifies and returns one family of oriented polylines,  optionally considering diagonal edges and polyline direction.</p> <p>Parameters:</p> Name Type Description Default <code>diagnet</code> <code>(bool, optional(default=False))</code> <p>Whether to consider diagonal edges.</p> <code>False</code> <code>poly2</code> <code>(bool, optional(default=True))</code> <p>The direction of the polylines.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>polyline</code> <code>numpy array</code> <p>The oriented polyline.</p> Note <p>This function assumes that the mesh is a regular mesh. The oriented polylines are useful for mesh analysis and processing.</p> <p>(!still have problem for the demultiple and oriendted quad faces,bad for thickness)</p> See Also <p>get_2families_polyline_from_1closed_bdry : Retrieves two families of polylines.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_1family_oriented_polyline(self, diagnet=False, poly2=True):\n    \"\"\"\n    Retrieves one family of oriented polylines from the mesh.\n\n    This function identifies and returns one family of oriented polylines, \n    optionally considering diagonal edges and polyline direction.\n\n    Parameters\n    ----------\n    diagnet : bool, optional (default=False)\n        Whether to consider diagonal edges.\n    poly2 : bool, optional (default=True)\n        The direction of the polylines.\n\n    Returns\n    -------\n    polyline : numpy array\n        The oriented polyline.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The oriented polylines are useful for mesh analysis and processing.\n\n    (!still have problem for the demultiple and oriendted quad faces,bad for thickness)\n\n    See Also\n    --------\n    get_2families_polyline_from_1closed_bdry : Retrieves two families of polylines.\n    \"\"\"\n    if diagnet:\n        v,v1,v2,v3,v4 = self.rr_star_corner# in diagonal direction\n    else:\n        v,v1,v2,v3,v4 = self.ver_star_matrix.T\n    num = len(v)\n    if poly2:\n        vl,vr = v2,v4\n    else:\n        vl,vr = v1,v3\n    va,vb = vl,v\n    for i in range(num):\n        if v[i] not in np.r_[vl,v] or vr[i] not in np.r_[vl,v]:\n            va = np.r_[va,v[i]]\n            vb = np.r_[vb,vr[i]]\n        else:\n            i1 = np.where(va==v[i])[0]\n            i2 = np.where(vb==vr[i])[0]\n            if len(np.intersect1d(i1,i2))==0:\n                va = np.r_[va,v[i]]\n                vb = np.r_[vb,vr[i]]\n    if demultiple:\n        \"remove multiple edges:\"\n        ind_del = []\n        ck = []\n        for i in range(len(va)):\n            i1 = np.where(vb==va[i])[0]\n            if len(i1) !=0:\n                for j in i1:\n                    if j not in ck and va[j] == vb[i]:\n                        ind_del.append(i)\n                        #print(i,va[i],vb[i],va[j],vb[j])\n                        ck.append(i)\n        if len(ind_del)!=0:\n            ind = np.array(ind_del)   \n            va = np.delete(va,ind)\n            vb = np.delete(vb,ind)  \n    return va,vb\n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_2families_polyline_from_1closed_bdry","title":"<code>get_2families_polyline_from_1closed_bdry(self, diagnet=False, direction=True)</code>","text":"<p>Retrieves two families of polylines from a closed boundary.</p> <p>This function identifies and returns two families of polylines from a closed  boundary, optionally considering diagonal edges and direction.</p> <p>Parameters:</p> Name Type Description Default <code>diagnet</code> <code>(bool, optional(default=False))</code> <p>Whether to consider diagonal edges.</p> <code>False</code> <code>direction</code> <code>(bool, optional(default=True))</code> <p>The direction of the polylines.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>polyline1</code> <code>numpy array</code> <p>The first family of polylines.</p> <code>polyline2</code> <code>numpy array</code> <p>The second family of polylines.</p> Note <p>This function assumes that the mesh has a closed boundary. The polylines are useful for mesh analysis and processing.</p> <p>(along one bdry for a patch-shape; two bdry for a star-shape)</p> See Also <p>get_1family_oriented_polyline : Retrieves one family of oriented polylines.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_2families_polyline_from_1closed_bdry(self, diagnet=False, direction=True):\n    \"\"\"\n    Retrieves two families of polylines from a closed boundary.\n\n    This function identifies and returns two families of polylines from a closed \n    boundary, optionally considering diagonal edges and direction.\n\n    Parameters\n    ----------\n    diagnet : bool, optional (default=False)\n        Whether to consider diagonal edges.\n    direction : bool, optional (default=True)\n        The direction of the polylines.\n\n    Returns\n    -------\n    polyline1 : numpy array\n        The first family of polylines.\n    polyline2 : numpy array\n        The second family of polylines.\n\n    Note\n    ----\n    This function assumes that the mesh has a closed boundary.\n    The polylines are useful for mesh analysis and processing.\n\n    (along one bdry for a patch-shape; two bdry for a star-shape)\n\n    See Also\n    --------\n    get_1family_oriented_polyline : Retrieves one family of oriented polylines.\n    \"\"\"\n    if diag:\n        v0,v1,v2,v3,v4 = self.rr_star_corner\n    else:\n        v0,v1,v2,v3,v4 = self.rrv4f4\n    v13,v24 = np.unique(np.r_[v1,v3]),np.unique(np.r_[v2,v4])\n\n    \"more general, one closed-boundary v\"\n    vb,_ = self.get_a_closed_boundary()\n\n    H = self.halfedges\n    \"boundary are divided/filter into 2class based on v13 or v24 direction\"\n    vb1,vb2 = [],[]\n    vfmly1,vfmly2 = [],[]\n    i1l=i1r=i2l=i2r = np.array([],dtype=int)\n    for i, v in enumerate(vb):\n        if i%interval==0:\n            if v in v13:\n                \"filter to 1st polyline-bdry-vertices\"\n                vb1.append(v)\n                if v in v1:\n                    j = np.where(v1==v)[0]\n                elif v in v3:\n                    j = np.where(v3==v)[0]\n                vx = v0[j]\n                if diag:\n                    vvx = np.r_[v,vx]\n                    vpl,_ = get_diagonal_polyline_from_2points(self,vvx,is_poly=False)\n                else:\n                    e = np.intersect1d(np.where(H[:,0]==v)[0],np.where(H[H[:,4],0]==vx)[0])[0]\n                    vpl,_ = self.get_polyline_from_an_edge(e)\n                if inner:\n                    vpl = vpl[1:-1]\n                vfmly1.append(vpl)\n                i1l = np.r_[i1l,vpl[:-1]]\n                i1r = np.r_[i1r,vpl[1:]]\n            if v in v24:\n                \"filter to 2nd polyline-bdry-vertices\"\n                vb2.append(v)\n                if v in v2:\n                    j = np.where(v2==v)[0]\n                elif v in v4:\n                    j = np.where(v4==v)[0]\n                vx = v0[j]\n                if diag:\n                    vvx = np.r_[v,vx]\n                    vpl,_ = get_diagonal_polyline_from_2points(self,vvx,is_poly=False)\n                else:\n                    e = np.intersect1d(np.where(H[:,0]==v)[0],np.where(H[H[:,4],0]==vx)[0])[0]\n                    vpl,_ = self.get_polyline_from_an_edge(e)\n                if inner:\n                    vpl = vpl[1:-1]\n                vfmly2.append(vpl)\n                i2l = np.r_[i2l,vpl[:-1]]\n                i2r = np.r_[i2r,vpl[1:]]\n    if is_poly:\n        V = self.vertices\n        pl1 = make_polyline_from_endpoints(V[i1l],V[i1r])\n        pl2 = make_polyline_from_endpoints(V[i2l],V[i2r])\n        return pl1,pl2\n    if is_seg:\n        return [i1l,i1r],[i2l,i2r]\n    return [vb1,vfmly1],[vb2,vfmly2]\n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_a_boundary_L_strip","title":"<code>get_a_boundary_L_strip(self, direction)</code>","text":"<p>Retrieves an L-shaped strip of boundary vertices.</p> <p>This function identifies an L-shaped strip of boundary vertices based on  the specified direction.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>bool</code> <p>The direction of the L-strip (True for one direction, False for the other).</p> required <p>Returns:</p> Name Type Description <code>strip</code> <code>numpy array</code> <p>The indices of vertices forming the L-strip.</p> Note <p>This function assumes that the mesh is a regular mesh. The L-strip is useful for mesh analysis and processing.</p> <p>AG-net: only rectangular-patch shape</p> See Also <p>get_cylinder_annulus_mesh_diagonal_oriented_vertices : Retrieves diagonal-oriented vertices.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_a_boundary_L_strip(self, direction):\n    \"\"\"\n    Retrieves an L-shaped strip of boundary vertices.\n\n    This function identifies an L-shaped strip of boundary vertices based on \n    the specified direction.\n\n    Parameters\n    ----------\n    direction : bool\n        The direction of the L-strip (True for one direction, False for the other).\n\n    Returns\n    -------\n    strip : numpy array\n        The indices of vertices forming the L-strip.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The L-strip is useful for mesh analysis and processing.\n\n    AG-net: only rectangular-patch shape\n\n    See Also\n    --------\n    get_cylinder_annulus_mesh_diagonal_oriented_vertices : Retrieves diagonal-oriented vertices.\n    \"\"\"\n    H = self.halfedges\n    v,va,vb,vc,vd = self.rr_star_corner\n    corner = self.corner\n    vii = vb if direction else va\n    i = np.intersect1d(vii,corner)[0]\n\n    def _get_v13(i):\n        \"should have at least one\"\n        e = np.intersect1d(np.where(H[:,1]==-1)[0],np.where(H[:,0]==i)[0])[0]\n        e0 = e\n        ib1,ib2 = [],[]\n        while H[H[e,2],0] not in corner:\n            ib1.append(e)\n            e = H[e,2]\n        ib1.append(e)\n\n        #---------\n        # e = H[e,2]\n        # while H[H[e,2],0] not in corner:\n        #     e = H[e,2]\n        #     ib2.append(e)  \n\n        # v1,v3 = H[ib1,0], H[H[H[ib1,4],3],0]\n        # v1 = np.r_[v1,H[H[H[H[ib2,4],3],3],0]]\n        # v3 = np.r_[v3,H[H[ib2,4],0]]\n\n        #----------------\n        ib1 = ib1[::-1]\n        v1,v3 = H[ib1,0], H[H[H[ib1,4],3],0]\n        while H[H[e0,3],0] not in corner:\n            e0 = H[e0,3]\n            ib2.append(e0)\n        ib2.append(H[e0,3])\n\n        v1 = np.r_[v1,H[H[ib2[1:],4],0]]\n        v3 = np.r_[v3,H[H[H[H[ib2[1:],4],3],3],0]]  \n        return np.c_[v1,v3]\n    \"return L-shape boundary quads (Lx1): v and only 1diag v\"\n    return _get_v13(i)\n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_all_boundary_vertices","title":"<code>get_all_boundary_vertices(self, order=False)</code>","text":"<p>Retrieves all boundary vertices in the mesh.</p> <p>This function identifies and returns all boundary vertices in the mesh,  optionally in a specific order.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>(bool, optional(default=False))</code> <p>Whether to return the boundary vertices in a specific order.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>boundary_vertices</code> <code>numpy array</code> <p>The indices of boundary vertices.</p> <code>boundary_positions</code> <code>numpy array</code> <p>The positions of boundary vertices.</p> Note <p>This function assumes that the mesh has a boundary. The boundary vertices are useful for mesh analysis and processing.</p> See Also <p>boundary_vertices : Retrieves the indices of boundary vertices.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_all_boundary_vertices(self, order=False):\n    \"\"\"\n    Retrieves all boundary vertices in the mesh.\n\n    This function identifies and returns all boundary vertices in the mesh, \n    optionally in a specific order.\n\n    Parameters\n    ----------\n    order : bool, optional (default=False)\n        Whether to return the boundary vertices in a specific order.\n\n    Returns\n    -------\n    boundary_vertices : numpy array\n        The indices of boundary vertices.\n    boundary_positions : numpy array\n        The positions of boundary vertices.\n\n    Note\n    ----\n    This function assumes that the mesh has a boundary.\n    The boundary vertices are useful for mesh analysis and processing.\n\n    See Also\n    --------\n    boundary_vertices : Retrieves the indices of boundary vertices.\n    \"\"\"\n    v = self.boundary_vertices()\n    if order:\n        # v = np.array([],dtype=int)\n        v = self.boundary_curves(corner_split=False)[0]\n        # for i in vi:\n        #     v = np.r_[v,i]\n    B = self.vertices[v]\n    return v,B\n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_both_isopolyline","title":"<code>get_both_isopolyline(self, diagpoly=False, is_one_or_another=False, is_poly=False, only_inner=False, interval=1, is_demultiple=False)</code>","text":"<p>Retrieves two families of isopolyline curves from the mesh.</p> <p>This function identifies and returns two families of isopolyline curves  based on the specified parameters.</p> <p>Parameters:</p> Name Type Description Default <code>diagpoly</code> <code>(bool, optional(default=False))</code> <p>Whether to use diagonal polyline.</p> <code>False</code> <code>is_one_or_another</code> <code>(bool, optional(default=False))</code> <p>Whether to select one family or the other.</p> <code>False</code> <code>is_poly</code> <code>(bool, optional(default=False))</code> <p>Whether to return the result as polylines.</p> <code>False</code> <code>only_inner</code> <code>(bool, optional(default=False))</code> <p>Whether to consider only inner vertices.</p> <code>False</code> <code>interval</code> <code>(int, optional(default=1))</code> <p>The interval between selected vertices.</p> <code>1</code> <code>is_demultiple</code> <code>(bool, optional(default=False))</code> <p>Whether to remove multiple edges.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>polylines</code> <code>list</code> <p>A list of isopolyline curves.</p> Note <p>This function assumes that the mesh is a regular mesh. The isopolyline curves are useful for mesh analysis and processing.</p> <p>AG-net:works for any geometry; but the polys are not orderly arranged</p> <p>menubar_basicplot: show_isoline1,show_isoline2; no multiple edges</p> See Also <p>get_isoline_vertex_list : Retrieves isoline vertices.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_both_isopolyline(self,diagpoly=False,is_one_or_another=False,\n                            is_poly=False,only_inner=False,interval=1,\n                            is_demultiple=False):\n    \"\"\"\n    Retrieves two families of isopolyline curves from the mesh.\n\n    This function identifies and returns two families of isopolyline curves \n    based on the specified parameters.\n\n    Parameters\n    ----------\n    diagpoly : bool, optional (default=False)\n        Whether to use diagonal polyline.\n    is_one_or_another : bool, optional (default=False)\n        Whether to select one family or the other.\n    is_poly : bool, optional (default=False)\n        Whether to return the result as polylines.\n    only_inner : bool, optional (default=False)\n        Whether to consider only inner vertices.\n    interval : int, optional (default=1)\n        The interval between selected vertices.\n    is_demultiple : bool, optional (default=False)\n        Whether to remove multiple edges.\n\n    Returns\n    -------\n    polylines : list\n        A list of isopolyline curves.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The isopolyline curves are useful for mesh analysis and processing.\n\n    AG-net:works for any geometry; but the polys are not orderly arranged\n\n    menubar_basicplot: show_isoline1,show_isoline2; no multiple edges\n\n    See Also\n    --------\n    get_isoline_vertex_list : Retrieves isoline vertices.\n    \"\"\"\n    _,_,lj = self.vertex_ring_vertices_iterators(return_lengths=True)\n    o56 = np.where(lj&gt;4)[0]\n    o4 = np.where(lj==4)[0]\n    boundary = self.boundary_vertices()\n    inv4 = np.intersect1d(o4, boundary)  ## if !=0, bdry has V4\n    if len(o56)==0 and len(inv4)==0: ## no singular inside, no v4 in bdry\n        \"regular-patch-shape or rotational-shape\"\n        ipllist = []\n        vl = vr = np.array([],dtype=int)\n        if diagpoly:\n            if len(self.corner)!=0:\n                \"surface shape: rectangular-patch\"\n                vf1 = self.get_a_boundary_L_strip(direction=True)\n                vf2 = self.get_a_boundary_L_strip(direction=False)\n            else:\n                \"surface shape: cylinder-annulus\"\n                vf1 = self.get_cylinder_annulus_mesh_diagonal_oriented_vertices(True)\n                vf2 = self.get_cylinder_annulus_mesh_diagonal_oriented_vertices(False)\n            allplv = vf1 if is_one_or_another else vf2\n            if interval ==1:\n                for i, k in enumerate(allplv):\n                    if i%interval==0:\n                        iv,_ = get_diagonal_polyline_from_2points(self,k,is_poly=False)   \n                        if len(iv)!=0:\n                            ipllist.append(iv)\n                            vl = np.r_[vl,iv[:-1]]\n                            vr = np.r_[vr,iv[1:]]\n            else:\n                ##AAG_2_4x4patch_16x16_add1loopbdry +3\n                # for i in range(len(allplv)+3): \n                #     if i ==0 or i==1 or i==2:\n                #         continue\n                #     else:\n                #         k = allplv[i-3]\n                for i in range(len(allplv)+1): \n                    if i ==0 :\n                        continue\n                    else:\n                        k = allplv[i-1]\n                        if i%interval==0:\n                            iv,_ = get_diagonal_polyline_from_2points(self,k,is_poly=False)   \n                            if len(iv)!=0:\n                                ipllist.append(iv)\n                                vl = np.r_[vl,iv[:-1]]\n                                vr = np.r_[vr,iv[1:]]\n        else:\n            if len(self.corner)!=0:\n                M = self.patch_matrix\n            else:\n                M = self.rot_patch_matrix  \n            if not is_one_or_another:\n                M = M.T\n            if only_inner:\n                #M = M[1:-1,1:-1]\n                M = M[1:-1,:] ## to except the bdry strips\n            allplv = M.tolist() \n            for i, iv in enumerate(allplv):\n                if i%interval==0:\n                    ipllist.append(iv)\n                    if len(iv)!=0:\n                        vl = np.r_[vl,iv[:-1]]\n                        vr = np.r_[vr,iv[1:]]\n    # elif len(o56)==0 and len(inv4)!=0:\n    #     \"patch\"\n    #     vb1,_ = self.get_i_boundary_vertex_indices(0) # i=0,1,2,3\n    #     try:\n    #         vb2,_ = self.get_i_boundary_vertex_indices(1)# i=0,1,2,3 # to check if 1 or 2\n    #     except:\n    #         vb2,_ = self.get_i_boundary_vertex_indices(1)\n    #     vb = vb1 if is_one_or_another else vb2\n    #     allplv = get_isoline_between_2bdry(self,vb)   \n    #     #ipllist = allplv\n\n    #     if only_inner:\n    #         if allplv[0][0] in self.corner:\n    #             allplv.pop(0)\n    #         if allplv[-1][0] in self.corner:\n    #             allplv.pop()\n    elif len(o56)==0 and len(self.corner)!=0:\n        \"schwarzh_02_diag_unitscale_AAG_AAG\"        \n        ipl1,ipl2 = self.get_2families_polyline_from_1closed_bdry(diag=diagpoly,\n                                                        interval=interval,\n                                                        inner=False) ## need to choose True or False\n        allplv = ipl1[1] if is_one_or_another else ipl2[1]\n\n        ipllist = []\n        vl = vr = np.array([],dtype=int)\n        for i, iv in enumerate(allplv):\n            if i%interval==0:\n                ipllist.append(iv)\n                if len(iv)!=0:\n                    vl = np.r_[vl,iv[:-1]]\n                    vr = np.r_[vr,iv[1:]]\n\n    if is_poly:\n        Vl,Vr = self.vertices[vl], self.vertices[vr]\n        return make_polyline_from_endpoints(Vl,Vr)\n    else:\n        if is_demultiple:\n            \"for ZIG-bdry mesh, if others need to check again\"\n            from huilab.huimesh.curves import remove_multiple_repetitive_lists\n            ipllist = remove_multiple_repetitive_lists(ipllist)\n        return ipllist\n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_checker_select_vertex","title":"<code>get_checker_select_vertex(self, first=[0])</code>","text":"<p>Retrieves the checkerboard selection of vertices.</p> <p>This function identifies and returns the indices of vertices in a  checkerboard pattern, starting from the specified vertex.</p> <p>Parameters:</p> Name Type Description Default <code>first</code> <code>(list, optional(default=[0]))</code> <p>The starting vertex index.</p> <code>[0]</code> <p>Returns:</p> Name Type Description <code>indices</code> <code>list</code> <p>The indices of vertices in the checkerboard pattern.</p> Note <p>This function assumes that the mesh is a regular mesh. The checkerboard selection is useful for mesh analysis and processing.</p> <p>self.checker_vertex: all vertex...blue ~ 0 ; red ~ 1; left ~ -1</p> See Also <p>get_checkerboard_black : Retrieves the black vertices in a checkerboard pattern. get_checkerboard_white : Retrieves the white vertices in a checkerboard pattern.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_checker_select_vertex(self, first=[0]):\n    \"\"\"\n    Retrieves the checkerboard selection of vertices.\n\n    This function identifies and returns the indices of vertices in a \n    checkerboard pattern, starting from the specified vertex.\n\n    Parameters\n    ----------\n    first : list, optional (default=[0])\n        The starting vertex index.\n\n    Returns\n    -------\n    indices : list\n        The indices of vertices in the checkerboard pattern.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The checkerboard selection is useful for mesh analysis and processing.\n\n    self.checker_vertex: all vertex...blue ~ 0 ; red ~ 1; left ~ -1\n\n    See Also\n    --------\n    get_checkerboard_black : Retrieves the black vertices in a checkerboard pattern.\n    get_checkerboard_white : Retrieves the white vertices in a checkerboard pattern.\n    \"\"\"\n    vall,vallij=self.vertex_ring_vertices_iterators(sort=True, order=False)\n    #vall,vallij = self._vi,self._vj\n    arr = -np.ones(self.V)\n    left = np.arange(self.V)\n    i0 = first       ## f0\n    arr[i0] = 0      ## blue\n    ind = np.where(vall==i0)[0]\n    ij = vallij[ind] ## fneib\n    left = np.setdiff1d(left,np.r_[i0,ij])\n    a = 0\n    while len(left)!=0:\n        a = a % 2\n        vneib=[]\n        for i in ij:\n            if i !=-1:\n                arr[i]=1-a\n                ind = np.where(vall==i)[0]\n                vneib.extend(list(vallij[ind]))\n        left = np.setdiff1d(left,np.r_[ij,vneib])\n        ij=[]\n        for v in vneib:\n            if v!=-1 and arr[v]==-1:\n                arr[v]=a\n                ij.append(v)\n        a += 1\n    blue = np.where(arr==0)[0]\n    red = np.where(arr==1)[0]\n    self._checker_vertex = [blue,red]\n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_checkerboard_black","title":"<code>get_checkerboard_black(self, is_rr=False, is_ck_n=False, is_GI=False)</code>","text":"<p>Retrieves the black vertices in a checkerboard pattern.</p> <p>This function identifies and returns the black vertices in a checkerboard  pattern, optionally considering regular vertices and normal vectors.</p> <p>Parameters:</p> Name Type Description Default <code>is_rr</code> <code>(bool, optional(default=False))</code> <p>Whether to consider regular vertices.</p> <code>False</code> <code>is_ck_n</code> <code>(bool, optional(default=False))</code> <p>Whether to return normal vectors.</p> <code>False</code> <code>is_GI</code> <code>(bool, optional(default=False))</code> <p>Whether to compute the gradient of the normal vectors.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>black_vertices</code> <code>numpy array</code> <p>The indices of black vertices in the checkerboard pattern.</p> <code>normals</code> <code>numpy array, optional</code> <p>The normal vectors of the black vertices (if is_ck_n=True).</p> <code>gradient</code> <code>numpy array, optional</code> <p>The gradient of the normal vectors (if is_GI=True).</p> Note <p>This function assumes that the mesh is a regular mesh. The black vertices are useful for mesh analysis and processing.</p> See Also <p>get_checker_select_vertex : Retrieves the checkerboard selection of vertices. get_checkerboard_white : Retrieves the white vertices in a checkerboard pattern.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_checkerboard_black(self, is_rr=False, is_ck_n=False, is_GI=False):\n    \"\"\"\n    Retrieves the black vertices in a checkerboard pattern.\n\n    This function identifies and returns the black vertices in a checkerboard \n    pattern, optionally considering regular vertices and normal vectors.\n\n    Parameters\n    ----------\n    is_rr : bool, optional (default=False)\n        Whether to consider regular vertices.\n    is_ck_n : bool, optional (default=False)\n        Whether to return normal vectors.\n    is_GI : bool, optional (default=False)\n        Whether to compute the gradient of the normal vectors.\n\n    Returns\n    -------\n    black_vertices : numpy array\n        The indices of black vertices in the checkerboard pattern.\n    normals : numpy array, optional\n        The normal vectors of the black vertices (if is_ck_n=True).\n    gradient : numpy array, optional\n        The gradient of the normal vectors (if is_GI=True).\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The black vertices are useful for mesh analysis and processing.\n\n    See Also\n    --------\n    get_checker_select_vertex : Retrieves the checkerboard selection of vertices.\n    get_checkerboard_white : Retrieves the white vertices in a checkerboard pattern.\n    \"\"\"\n    if is_rr:\n        \"oriented order of the vertices of quadfaces\"\n        order = self.rr_quadface_order\n        v1,v2,v3,v4 = self.rr_quadface.T # in odrder\n    else:\n        vi = self.quadface\n        v1,v2,v3,v4 = vi[::4],vi[1::4],vi[2::4],vi[3::4]\n        order = self.quadface_order\n\n    V = self.vertices\n\n    if is_ck_n:\n        an = (V[v1]+V[v2]+V[v3]+V[v4])/4.0\n        fn = np.cross(V[v1]-V[v3], V[v2]-V[v4])\n        fn = fn / np.linalg.norm(fn, axis=1)[:,None]\n        return an, fn\n    if is_GI:\n        \"below works the same as self.get_face_normal_GI\"\n        all_fn = self.face_normals()\n\n        fn = np.cross(V[v1]-V[v3], V[v2]-V[v4])\n        fn = fn / np.linalg.norm(fn, axis=1)[:,None]\n\n        order_fn = all_fn[order]\n        dot = np.einsum('ij,ij-&gt;i',order_fn, fn)\n        idd = np.where(dot&lt;0)[0]\n        fn[idd] = -fn[idd]\n\n        all_fn[order] = fn\n\n        GI = get_barycenters_mesh(self,verlist=all_fn)  \n        return GI\n\n    P1 = (V[v1] + V[v2]) * 0.5\n    P2 = (V[v2] + V[v3]) * 0.5\n    P3 = (V[v3] + V[v4]) * 0.5\n    P4 = (V[v4] + V[v1]) * 0.5\n    ck = make_quad_mesh_pieces(P1,P2,P3,P4)\n    return ck\n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_checkerboard_white","title":"<code>get_checkerboard_white(self)</code>","text":"<p>Retrieves the white vertices in a checkerboard pattern.</p> <p>This function identifies and returns the white vertices in a checkerboard  pattern.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>white_vertices</code> <code>numpy array</code> <p>The indices of white vertices in the checkerboard pattern.</p> Note <p>This function assumes that the mesh is a regular mesh. The white vertices are useful for mesh analysis and processing.</p> See Also <p>get_checker_select_vertex : Retrieves the checkerboard selection of vertices. get_checkerboard_black : Retrieves the black vertices in a checkerboard pattern.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_checkerboard_white(self):\n    \"\"\"\n    Retrieves the white vertices in a checkerboard pattern.\n\n    This function identifies and returns the white vertices in a checkerboard \n    pattern.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    white_vertices : numpy array\n        The indices of white vertices in the checkerboard pattern.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The white vertices are useful for mesh analysis and processing.\n\n    See Also\n    --------\n    get_checker_select_vertex : Retrieves the checkerboard selection of vertices.\n    get_checkerboard_black : Retrieves the black vertices in a checkerboard pattern.\n    \"\"\"\n    V = self.vertices\n    v,v1,v2,v3,v4 = self.ver_regular_star.T\n    P1 = (V[v1] + V[v]) * 0.5\n    P2 = (V[v2] + V[v]) * 0.5\n    P3 = (V[v3] + V[v]) * 0.5\n    P4 = (V[v4] + V[v]) * 0.5\n    ck = make_quad_mesh_pieces(P1,P2,P3,P4)\n    return ck\n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_cylinder_annulus_mesh_diagonal_oriented_vertices","title":"<code>get_cylinder_annulus_mesh_diagonal_oriented_vertices(self, direction)</code>","text":"<p>Retrieves diagonal-oriented vertices for a cylinder or annulus mesh.</p> <p>This function identifies vertices oriented along the diagonal direction  for a cylinder or annulus mesh.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>bool</code> <p>The direction of the diagonal (True for one direction, False for the other).</p> required <p>Returns:</p> Name Type Description <code>vertices</code> <code>numpy array</code> <p>The indices of diagonal-oriented vertices.</p> Note <p>This function assumes that the mesh is a cylinder or annulus mesh. The diagonal-oriented vertices are useful for mesh analysis and processing.</p> <p>AG-net: only work for cylinder-annulus-shape</p> <p>return loop boundary quads (Lx1): v and only 1diag v</p> See Also <p>get_a_boundary_L_strip : Retrieves an L-shaped strip of boundary vertices.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_cylinder_annulus_mesh_diagonal_oriented_vertices(self, direction):\n    \"\"\"\n    Retrieves diagonal-oriented vertices for a cylinder or annulus mesh.\n\n    This function identifies vertices oriented along the diagonal direction \n    for a cylinder or annulus mesh.\n\n    Parameters\n    ----------\n    direction : bool\n        The direction of the diagonal (True for one direction, False for the other).\n\n    Returns\n    -------\n    vertices : numpy array\n        The indices of diagonal-oriented vertices.\n\n    Note\n    ----\n    This function assumes that the mesh is a cylinder or annulus mesh.\n    The diagonal-oriented vertices are useful for mesh analysis and processing.\n\n    AG-net: only work for cylinder-annulus-shape\n\n    return loop boundary quads (Lx1): v and only 1diag v\n\n\n    See Also\n    --------\n    get_a_boundary_L_strip : Retrieves an L-shaped strip of boundary vertices.\n    \"\"\"\n    H = self.halfedges\n    vb,_ = self.get_i_boundary_vertex_indices(0)\n    vnext = []\n    for v in vb:\n        if direction:\n            e = np.intersect1d(np.where(H[:,1]==-1)[0],np.where(H[:,0]==v)[0])[0]\n            vdiag = H[H[H[e,4],3],0]\n        else:\n            e = np.intersect1d(np.where(H[:,1]==-1)[0],np.where(H[:,0]==v)[0])[0]\n            e = H[e,3]\n            vdiag = H[H[H[H[e,4],2],2],0]\n        vnext.append(vdiag)\n    return np.c_[vb, vnext]\n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_curvature","title":"<code>get_curvature(self, mesh, order=None)</code>","text":"<p>Computes the curvature properties of the mesh.</p> <p>This function calculates the curvature properties of the mesh, including  principal curvatures, Gaussian curvature, and mean curvature.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh object</code> <p>The input mesh.</p> required <code>order</code> <code>numpy array, optional (default=None)</code> <p>The order of vertices to consider.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ratio</code> <code>list</code> <p>The ratio of principal curvatures.</p> <code>K</code> <code>list</code> <p>The Gaussian curvature values.</p> <code>H</code> <code>list</code> <p>The mean curvature values.</p> <code>D1, D2 : numpy array</code> <p>The principal curvature directions.</p> Note <p>This function assumes that the mesh is a regular mesh. The curvature properties are useful for mesh analysis and processing.</p> <p>(from davide' eigen of shape-operator)</p> See Also <p>get_curvature_libigl : Computes the curvature properties using libigl.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_curvature(self, mesh, order=None):\n    \"\"\"\n    Computes the curvature properties of the mesh.\n\n    This function calculates the curvature properties of the mesh, including \n    principal curvatures, Gaussian curvature, and mean curvature.\n\n    Parameters\n    ----------\n    mesh : Mesh object\n        The input mesh.\n    order : numpy array, optional (default=None)\n        The order of vertices to consider.\n\n    Returns\n    -------\n    ratio : list\n        The ratio of principal curvatures.\n    K : list\n        The Gaussian curvature values.\n    H : list\n        The mean curvature values.\n    D1, D2 : numpy array\n        The principal curvature directions.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The curvature properties are useful for mesh analysis and processing.\n\n    (from davide' eigen of shape-operator)\n\n    See Also\n    --------\n    get_curvature_libigl : Computes the curvature properties using libigl.\n    \"\"\"\n    k1,k2, D1, D2 = mesh.principal_curvatures(True, use_sine=True)\n    K = mesh.gaussian_curvature()\n    H = mesh.mean_curvature()\n    eps = np.finfo(float).eps\n    if order is not None:\n        K,H = K[order],H[order]\n        D1,D2 = D1[order],D2[order]\n        k1,k2 = k1[order],k2[order]\n    ratio = [np.min(k1/(k2+eps)),np.mean(k1/(k2+eps)),np.max(k1/(k2+eps))]\n    return ratio,[np.min(K),np.mean(K),np.max(K)],[np.min(H),np.mean(H),np.max(H)],D1,D2\n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_curvature_libigl","title":"<code>get_curvature_libigl(self, mesh, evalue=False)</code>","text":"<p>Computes the curvature properties of the mesh using libigl.</p> <p>This function calculates the curvature properties of the mesh using libigl,  including principal curvatures, Gaussian curvature, and mean curvature.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh object</code> <p>The input mesh.</p> required <code>evalue</code> <code>(bool, optional(default=False))</code> <p>Whether to return the eigenvalues of the shape operator.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>vertices</code> <code>numpy array</code> <p>The vertex positions.</p> <code>K</code> <code>list</code> <p>The Gaussian curvature values.</p> <code>H</code> <code>list</code> <p>The mean curvature values.</p> <code>D1, D2 : numpy array</code> <p>The principal curvature directions.</p> Note <p>This function assumes that the mesh is a regular mesh. The curvature properties are useful for mesh analysis and processing.</p> <p>(via quadric fitting (Panozzo, 2010))</p> See Also <p>get_curvature : Computes the curvature properties of the mesh.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_curvature_libigl(self, mesh, evalue=False):\n    \"\"\"\n    Computes the curvature properties of the mesh using libigl.\n\n    This function calculates the curvature properties of the mesh using libigl, \n    including principal curvatures, Gaussian curvature, and mean curvature.\n\n    Parameters\n    ----------\n    mesh : Mesh object\n        The input mesh.\n    evalue : bool, optional (default=False)\n        Whether to return the eigenvalues of the shape operator.\n\n    Returns\n    -------\n    vertices : numpy array\n        The vertex positions.\n    K : list\n        The Gaussian curvature values.\n    H : list\n        The mean curvature values.\n    D1, D2 : numpy array\n        The principal curvature directions.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The curvature properties are useful for mesh analysis and processing.\n\n    (via quadric fitting (Panozzo, 2010))\n\n    See Also\n    --------\n    get_curvature : Computes the curvature properties of the mesh.\n    \"\"\" \n    import igl\n    trv = mesh.vertices\n    trf,_ = mesh.face_triangles()\n    D1,D2,k1,k2 = igl.principal_curvature(trv,trf)  \n    if evalue:\n        K,H = k1*k2, (k1+k2)/2\n        return trv,[np.min(K),np.mean(K),np.max(K)],[np.min(H),np.mean(H),np.max(H)],D1,D2\n    return trv, k2, k1, D2, D1 #rearange in [min,max]\n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_diagonal_mesh","title":"<code>get_diagonal_mesh(self, sort=True, blue=False, whole=False)</code>","text":"<p>Creates a diagonal mesh from the current mesh.</p> <p>This function constructs a diagonal mesh by connecting the vertices of the  current mesh in a specific pattern. The resulting mesh can be sorted and  colored based on the specified parameters.</p> <p>Parameters:</p> Name Type Description Default <code>sort</code> <code>(bool, optional(default=True))</code> <p>Whether to sort the vertices.</p> <code>True</code> <code>blue</code> <code>(bool, optional(default=False))</code> <p>Whether to color the vertices blue.</p> <code>False</code> <code>whole</code> <code>(bool, optional(default=False))</code> <p>Whether to include the whole mesh.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>diagonal_mesh</code> <code>Mesh object</code> <p>The constructed diagonal mesh.</p> Note <p>This function assumes that the mesh is a regular mesh. The diagonal mesh is useful for mesh analysis and processing.</p> See Also <p>make_quad_mesh_from_indices : Creates a quad mesh from vertex indices.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_diagonal_mesh(self, sort=True, blue=False, whole=False):\n    \"\"\"\n    Creates a diagonal mesh from the current mesh.\n\n    This function constructs a diagonal mesh by connecting the vertices of the \n    current mesh in a specific pattern. The resulting mesh can be sorted and \n    colored based on the specified parameters.\n\n    Parameters\n    ----------\n    sort : bool, optional (default=True)\n        Whether to sort the vertices.\n    blue : bool, optional (default=False)\n        Whether to color the vertices blue.\n    whole : bool, optional (default=False)\n        Whether to include the whole mesh.\n\n    Returns\n    -------\n    diagonal_mesh : Mesh object\n        The constructed diagonal mesh.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The diagonal mesh is useful for mesh analysis and processing.\n\n    See Also\n    --------\n    make_quad_mesh_from_indices : Creates a quad mesh from vertex indices.\n    \"\"\"\n    V = self.vertices\n    if whole:\n        num = self.V\n        bary = self.face_barycenters()\n        dV = np.vstack((V,bary))\n        H = self.halfedges\n        i1 = np.where(H[:,1] &gt;= 0)[0]\n        i2 = np.where(H[H[:,4],1] &gt;= 0)[0]\n        i = np.intersect1d(i1,i2)\n        e = np.array([i[0]])\n        for j in i[1:]:\n            if H[H[j,4],1] not in H[e,1]:\n                e = np.r_[e,j]\n        v1, v3 = H[e,0], H[H[e,4],0]\n        v2, v4 = num+H[H[e,4],1], num+H[e,1]\n        dallv = np.unique(np.r_[v1,v2,v3,v4])\n        vlist = dV[dallv]\n        iv1 = [np.argwhere(dallv == item)[0][0] for item in v1]\n        iv2 = [np.argwhere(dallv == item)[0][0] for item in v2]\n        iv3 = [np.argwhere(dallv == item)[0][0] for item in v3]\n        iv4 = [np.argwhere(dallv == item)[0][0] for item in v4]\n        flist = (np.array([iv1,iv2,iv3,iv4]).T).tolist()\n        dmesh = Mesh()\n        dmesh.make_mesh(vlist,flist)\n        return dmesh\n    else:\n        v,v1,v2,v3,v4 = self.ver_regular_star.T\n        if sort:\n            def _ind_red_regular_vertex(blue):\n                vblue,vred = self.checker_vertex # depends on all vertex-checker\n                order = self.ver_regular\n                idb,idr = [],[]\n                for i in range(len(order)):\n                    v = order[i]\n                    if v in vblue:\n                        idb.append(i)\n                    elif v in vred:\n                        idr.append(i)\n                if blue:\n                    return np.array(idb)\n                return np.array(idr)\n            order = _ind_red_regular_vertex(blue)\n        else:\n            order = np.arange(self.num_regular)[::2]\n        # V1,V2,V3,V4 = V[v1[order]],V[v2[order]],V[v3[order]],V[v4[order]]\n        # dmesh = make_quad_mesh_pieces(V1,V2,V3,V4)\n        v1,v2,v3,v4 = v1[order],v2[order],v3[order],v4[order]\n        dmesh = self.make_quad_mesh_from_indices(V,v1,v2,v3,v4)\n        return dmesh\n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_i_boundary_vertex_indices","title":"<code>get_i_boundary_vertex_indices(self, i)</code>","text":"<p>Retrieves the indices of boundary vertices for a specified boundary.</p> <p>This function identifies and returns the indices of boundary vertices  for the specified boundary.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int</code> <p>The index of the boundary.</p> required <p>Returns:</p> Name Type Description <code>boundary_vertices</code> <code>numpy array</code> <p>The indices of boundary vertices.</p> <code>boundary_positions</code> <code>numpy array</code> <p>The positions of boundary vertices.</p> Note <p>This function assumes that the mesh has multiple boundaries. The boundary vertices are useful for mesh analysis and processing. (work for rectangular-patch + cylinder-annulus)</p> See Also <p>get_i_boundary_vertices : Retrieves the boundary vertices from a specified edge.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_i_boundary_vertex_indices(self, i):\n    \"\"\"\n    Retrieves the indices of boundary vertices for a specified boundary.\n\n    This function identifies and returns the indices of boundary vertices \n    for the specified boundary.\n\n    Parameters\n    ----------\n    i : int\n        The index of the boundary.\n\n    Returns\n    -------\n    boundary_vertices : numpy array\n        The indices of boundary vertices.\n    boundary_positions : numpy array\n        The positions of boundary vertices.\n\n    Note\n    ----\n    This function assumes that the mesh has multiple boundaries.\n    The boundary vertices are useful for mesh analysis and processing.\n    (work for rectangular-patch + cylinder-annulus)\n\n    See Also\n    --------\n    get_i_boundary_vertices : Retrieves the boundary vertices from a specified edge.\n    \"\"\"\n    #i = self.show_i_boundary\n    _,_,lj = self.vertex_ring_vertices_iterators(sort=True,return_lengths=True)\n    vcorner = np.where(lj==2)[0]\n    H = self.halfedges\n    ec = []\n    if len(vcorner)!=0:\n        for v in vcorner:\n            e = np.intersect1d(np.where(H[:,0]==v)[0],np.where(H[:,1]==-1)[0])[0]\n            ec.append(e)\n        ec = H[np.array(ec,dtype=int),5]\n        v,B = self.get_i_boundary_vertices(ec[i],by_corner2=True) \n    else:\n        \"rotational-case\"\n        i = int(i%2) # i always equal 0 or 1\n        bi = self.boundary_curves(corner_split=True)\n        for b in bi:\n            v = b[0]\n            e = np.intersect1d(np.where(H[:,0]==v)[0],np.where(H[:,1]==-1)[0])[0]\n            ec.append(e)\n        ec = H[np.array(ec,dtype=int),5]     \n        v,B = self.get_i_boundary_vertices(ec[i],by_closed=True)         \n    return v,B\n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_i_boundary_vertices","title":"<code>get_i_boundary_vertices(self, e, by_closed=False, by_corner2=False)</code>","text":"<p>Retrieves the boundary vertices from a specified edge.</p> <p>This function identifies and returns the boundary vertices starting from  the specified edge, optionally considering closed boundaries or corner vertices.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>int</code> <p>The index of the starting edge.</p> required <code>by_closed</code> <code>(bool, optional(default=False))</code> <p>Whether to consider closed boundaries.</p> <code>False</code> <code>by_corner2</code> <code>(bool, optional(default=False))</code> <p>Whether to consider corner vertices.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>boundary_vertices</code> <code>numpy array</code> <p>The indices of boundary vertices.</p> <code>boundary_positions</code> <code>numpy array</code> <p>The positions of boundary vertices.</p> Note <p>This function assumes that the mesh has a boundary. The boundary vertices are useful for mesh analysis and processing.</p> See Also <p>get_i_boundary_vertex_indices : Retrieves the indices of boundary vertices.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_i_boundary_vertices(self, e, by_closed=False, by_corner2=False):\n    \"\"\"\n    Retrieves the boundary vertices from a specified edge.\n\n    This function identifies and returns the boundary vertices starting from \n    the specified edge, optionally considering closed boundaries or corner vertices.\n\n    Parameters\n    ----------\n    e : int\n        The index of the starting edge.\n    by_closed : bool, optional (default=False)\n        Whether to consider closed boundaries.\n    by_corner2 : bool, optional (default=False)\n        Whether to consider corner vertices.\n\n    Returns\n    -------\n    boundary_vertices : numpy array\n        The indices of boundary vertices.\n    boundary_positions : numpy array\n        The positions of boundary vertices.\n\n    Note\n    ----\n    This function assumes that the mesh has a boundary.\n    The boundary vertices are useful for mesh analysis and processing.\n\n    See Also\n    --------\n    get_i_boundary_vertex_indices : Retrieves the indices of boundary vertices.\n    \"\"\"\n    H = self.halfedges\n    il,ir = np.where(H[:,5]==e)[0] # should be two\n    if H[il,1]==-1:\n        e = il\n    else:\n        e = ir\n    if by_closed:\n        \"no corner vertex of valence 2, which forms closed boundry\"\n        eb = []\n        e1=e\n        e2 = H[e,2]\n        while H[e1,0] not in H[np.array(eb,dtype=int),0]:\n            eb.append(e1)\n            e1 = H[e1,3]\n        #eb.append(e1)\n        while H[e2,0] not in H[np.array(eb,dtype=int),0]:\n            eb.append(e2)\n            e2 = H[e2,2]\n        #eb.append(e2)\n        vb = H[np.array(eb,dtype=int),0]\n        \"above should be no duplicate, then below no use\"\n        #u, ind = np.unique(vb, return_index=True)\n        #vb = u[np.argsort(ind)]\n        return vb, self.vertices[vb]\n    elif by_corner2: \n        \"split by corner vertex of valence 2\"\n        eb = []\n        e1=e\n        e2 = H[e,2]\n        _,_,lj = self.vertex_ring_vertices_iterators(sort=True,return_lengths=True)\n        corner = np.where(lj==2)[0]\n        while H[e1,0] not in corner:\n            eb.append(e1)\n            e1 = H[e1,3]\n        eb.append(e1)\n        while H[e2,0] not in corner:\n            eb.append(e2)\n            e2 = H[e2,2]\n        eb.append(e2)\n        vb = H[np.array(eb,dtype=int),0]\n        return vb, self.vertices[vb]\n    else:\n        \"all boundary vertices\"\n        vb = self.boundary_curves()\n        for v in vb:\n            if H[e,0] in v:\n                return v, self.vertices[v]\n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_index_in_polyline","title":"<code>get_index_in_polyline(self, vstartlist, patch_or_annulus=True)</code>","text":"<p>Retrieves the indices of vertices in a polyline.</p> <p>This function identifies and returns the indices of vertices in a polyline  based on the specified start vertices and mesh type.</p> <p>Parameters:</p> Name Type Description Default <code>vstartlist</code> <code>list</code> <p>The list of start vertices.</p> required <code>patch_or_annulus</code> <code>(bool, optional(default=True))</code> <p>Whether the mesh is a patch or an annulus.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>indices</code> <code>numpy array</code> <p>The indices of vertices in the polyline.</p> Note <p>This function assumes that the mesh is a regular mesh. The indices are useful for accessing specific vertices in the mesh.</p> <p>reorder for a continuous but messy order vertex-list;</p> <p>vstartlist in boundary_curves</p> See Also <p>get_polyline_from_an_edge : Retrieves a polyline from an edge.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_index_in_polyline(self, vstartlist, patch_or_annulus=True):\n    \"\"\"\n    Retrieves the indices of vertices in a polyline.\n\n    This function identifies and returns the indices of vertices in a polyline \n    based on the specified start vertices and mesh type.\n\n    Parameters\n    ----------\n    vstartlist : list\n        The list of start vertices.\n    patch_or_annulus : bool, optional (default=True)\n        Whether the mesh is a patch or an annulus.\n\n    Returns\n    -------\n    indices : numpy array\n        The indices of vertices in the polyline.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The indices are useful for accessing specific vertices in the mesh.\n\n    reorder for a continuous but messy order vertex-list;\n\n    vstartlist in boundary_curves\n\n    See Also\n    --------\n    get_polyline_from_an_edge : Retrieves a polyline from an edge.\n    \"\"\"\n    if patch_or_annulus: ##only work for these two cases. should be compatible with self.indM\n        \"also works for inner loops without mesh-bdry-pts in vstartlist\"\n        if len(self.corner)!=0:\n            \"patch shape: [0,1,2,3,4,5]\"\n            M = self.patch_matrix.T ##need check if .T\n            #vlist = np.r_[M[0,:],M[-1,:]]\n        else:\n            \"rotational shape: [0,1,2,3,4,5; 0]\"\n            M = self.rot_patch_matrix ##M[:,-1]==M[:,0]\n            # vlist = np.r_[M[0,:-1],M[-1,:-1]]\n            M = M[:,:-1]\n        for vlist in M:\n            if len(np.intersect1d(vlist, vstartlist))&gt;1:\n                \"vstartlist include mesh-boundary-pts\"\n                order = []\n                for v in vlist:\n                    if v in vstartlist:\n                        order.append(np.where(vstartlist==v)[0][0])\n                break\n\n        for vlist in M.T:\n            if len(np.intersect1d(vlist, vstartlist))&gt;1:\n                \"vstartlist include mesh-boundary-pts\"\n                order = []\n                for v in vlist:\n                    if v in vstartlist:\n                        order.append(np.where(vstartlist==v)[0][0])\n                break\n        return np.array(order)    \n    ### below works bad. no more use now.\n    elif False:\n        ### problem: edge happens at inner bdry, vlist is the whole bdry of the patch\n        H = self.halfedges\n        i = 0\n        edge = None\n        while edge is None:\n            ei = np.where(H[:,0]==vstartlist[i])[0]\n            for e in ei:\n                if H[H[e,4],0] in vstartlist:\n                    edge = e\n                    break\n            i += 1\n\n        vlist,_ = self.get_polyline_from_an_edge(edge,is_bdry=True)##note, Vlist is full-poly, right!\n    elif False:\n        ### same problem as the above\n        vlist = self.boundary_vertices()\n    elif False:\n        ### note, vlist=[1,2,3,4, 4,5,6,7,8, 8,9,10,11, ..., 1]\n        ### all these three ways have the prelimarary that vstartlist in bdry\n        brdies = self.boundary_curves(True)\n        vlist = np.array([],dtype=int)\n        for brr in brdies:\n            vlist = np.r_[vlist,brr] ##has multiple vertices\n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_isoline_vertex_list","title":"<code>get_isoline_vertex_list(self, interval, another_direction=True)</code>","text":"<p>Retrieves the vertices forming isoline curves.</p> <p>This function identifies and returns the vertices forming isoline curves  based on the specified interval and direction.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>int</code> <p>The interval between selected vertices.</p> required <code>another_direction</code> <code>(bool, optional(default=True))</code> <p>Whether to consider another direction.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>all_v0</code> <code>list</code> <p>All vertices forming the isoline curves.</p> <code>all_vs_v0</code> <code>list</code> <p>All neighboring vertices forming the isoline curves.</p> <code>select_v0</code> <code>list</code> <p>Selected vertices forming the isoline curves.</p> <code>select_vs_v0</code> <code>list</code> <p>Selected neighboring vertices forming the isoline curves.</p> Note <p>This function assumes that the mesh is a regular mesh. The isoline vertices are useful for mesh analysis and processing.</p> <p>along one bdry for a patch-shape; two bdry for a star-shape</p> See Also <p>get_both_isopolyline : Retrieves two families of isopolyline curves.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_isoline_vertex_list(self, interval, another_direction=True):\n    \"\"\"\n    Retrieves the vertices forming isoline curves.\n\n    This function identifies and returns the vertices forming isoline curves \n    based on the specified interval and direction.\n\n    Parameters\n    ----------\n    interval : int\n        The interval between selected vertices.\n    another_direction : bool, optional (default=True)\n        Whether to consider another direction.\n\n    Returns\n    -------\n    all_v0 : list\n        All vertices forming the isoline curves.\n    all_vs_v0 : list\n        All neighboring vertices forming the isoline curves.\n    select_v0 : list\n        Selected vertices forming the isoline curves.\n    select_vs_v0 : list\n        Selected neighboring vertices forming the isoline curves.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The isoline vertices are useful for mesh analysis and processing.\n\n    along one bdry for a patch-shape; two bdry for a star-shape\n\n    See Also\n    --------\n    get_both_isopolyline : Retrieves two families of isopolyline curves.\n    \"\"\"\n    v,v1,v2,v3,v4 = self.rrv4f4\n    if another_direction:\n        vl,vr = v2,v4\n    else:\n        vl,vr = v1,v3\n    if False:\n        \"patch-shape\"\n        M = self.patch_matrix\n        if another_direction:\n            M = M.T\n        vb = M[-1,1:-1]\n    else:\n        \"more general, one boundary v\"\n        vb1,_ = self.get_i_boundary_vertex_indices(0) # i=0,1,2,3\n        vb2,_ = self.get_i_boundary_vertex_indices(1) # i=0,1,2,3\n        if len(np.intersect1d(np.r_[vl,vr],vb1))!=0:\n            vb = vb1\n        elif len(np.intersect1d(np.r_[vl,vr],vb2))!=0:\n            vb = vb2\n        else:\n            \"need to check and rewrite\"\n            if len(self.corner)!=0:\n            #try:\n                \"patch-shape\"\n                M = self.patch_matrix\n            else:\n            #except:\n                M = self.rot_patch_matrix\n\n            if another_direction:\n                M = M.T\n            vb = M[-1,:]\n        #vb = vb[1:-1]##[::interval] # Hui comment, may have problem later.\n        if len(np.intersect1d(vr,vb))!=0:\n            \"make sure vl in vb, vr not in vb\"\n            vl,vr = vr,vl    \n\n    alls_v0, alls_vs_v0 = [],[]\n    select_v0,select_vs_v0 = [],[]\n    allplv = get_isoline_between_2bdry(self,vb)\n    for k in range(len(vb)):\n        iv = allplv[k]\n        iv0,jv0 = [],[]\n        for i in iv:\n            if i in v:\n                j = np.where(v==i)[0][0]\n                iv0.append(i)\n                jv0.append(j)  \n        if len(jv0)&gt;1:#!=0:\n            alls_v0.append(iv0)\n            alls_vs_v0.append(jv0)\n            if k % interval ==0:\n                select_v0.append(iv0)\n                select_vs_v0.append(jv0)\n    return alls_v0,alls_vs_v0,select_v0,select_vs_v0  \n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_midline_mesh","title":"<code>get_midline_mesh(self)</code>","text":"<p>Creates a midline mesh from the current mesh.</p> <p>This function constructs a midline mesh by connecting the midpoints of the  edges of the current mesh. The resulting mesh represents the midlines of the  original mesh.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>midline_mesh</code> <code>Mesh object</code> <p>The constructed midline mesh.</p> Note <p>This function assumes that the mesh is a regular mesh. The midline mesh is useful for mesh analysis and processing.</p> <p>(remesh of principal mesh by midline-ortho + planarity; the quadface should be planar)</p> See Also <p>get_diagonal_mesh : Creates a diagonal mesh from the current mesh.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_midline_mesh(self):\n    \"\"\"\n    Creates a midline mesh from the current mesh.\n\n    This function constructs a midline mesh by connecting the midpoints of the \n    edges of the current mesh. The resulting mesh represents the midlines of the \n    original mesh.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    midline_mesh : Mesh object\n        The constructed midline mesh.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The midline mesh is useful for mesh analysis and processing.\n\n    (remesh of principal mesh by midline-ortho + planarity; the quadface should be planar)\n\n    See Also\n    --------\n    get_diagonal_mesh : Creates a diagonal mesh from the current mesh.\n    \"\"\"\n    V = self.vertices\n    vi = self.quadface\n    v1,v2,v3,v4 = vi[::4],vi[1::4],vi[2::4],vi[3::4]\n    bary = (V[v1]+V[v2]+V[v3]+V[v4])/4.0\n    arr = self.V + np.arange(len(v1))\n    vlist = np.vstack((V,bary))\n\n    edges,edge12,edge23,edge34,edge41 = [],[],[],[],[]\n    H = self.halfedges\n    for i in range(len(v1)):\n        e1i = np.where(H[:,0]== v1[i])[0]\n        e1j = np.where(H[H[:,4],0]== v2[i])[0]\n        e = np.intersect1d(e1i,e1j)[0]\n        e12, e23 = H[e,5],H[H[e,2],5]\n        e34, e41 = H[H[H[e,2],2],5], H[H[e,3],5]\n        edge12.append(e12)\n        edge23.append(e23)\n        edge34.append(e34)\n        edge41.append(e41)\n        edges.append(e12)\n        edges.append(e23)\n        edges.append(e34)\n        edges.append(e41)\n\n    edges = np.unique(edges)\n    for j in edges:\n        jl,jr = np.where(H[:,5]==j)[0]\n        Vm = (V[H[jl,0]] + V[H[jr,0]])/2\n        vlist = np.vstack((vlist,Vm))\n\n    i12,i23,i34,i41 = [],[],[],[]\n    for i in range(len(v1)):\n        i12.append(np.where(edges==edge12[i])[0])\n        i23.append(np.where(edges==edge23[i])[0])\n        i34.append(np.where(edges==edge34[i])[0])\n        i41.append(np.where(edges==edge41[i])[0])\n    m1 = np.array(i12)+ self.V + len(v1)\n    m2 = np.array(i23)+ self.V + len(v1)\n    m3 = np.array(i34)+ self.V + len(v1)\n    m4 = np.array(i41)+ self.V + len(v1)\n    f1 = np.tile(arr,4)\n    f2 = np.r_[m4,m1,m2,m3]\n    f3 = np.r_[v1,v2,v3,v4]\n    f4 = np.r_[m1,m2,m3,m4]\n    flist = (np.c_[f1,f2,f3,f4]).tolist()\n    mmesh = Mesh()\n    mmesh.make_mesh(vlist,flist)\n    return mmesh\n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_net_crossing_angle","title":"<code>get_net_crossing_angle(self, ut1, ut2)</code>","text":"<p>Computes the crossing angles between two sets of tangent vectors.</p> <p>This function calculates the crossing angles between two sets of tangent vectors.</p> <p>Parameters:</p> Name Type Description Default <code>ut1</code> <code>numpy array</code> <p>The first set of unit tangent vectors.</p> required <code>ut2</code> <code>numpy array</code> <p>The second set of unit tangent vectors.</p> required <p>Returns:</p> Name Type Description <code>angle</code> <code>numpy array</code> <p>The crossing angles between the tangent vectors.</p> Note <p>This function assumes that the input tangent vectors are unit vectors. The crossing angles are useful for mesh analysis and processing.</p> <p>(for orthogonal / isogonal case)</p> See Also <p>get_v4_unit_tangents : Computes the unit tangent vectors for vertices with valence 4.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_net_crossing_angle(self, ut1, ut2):\n    \"\"\"\n    Computes the crossing angles between two sets of tangent vectors.\n\n    This function calculates the crossing angles between two sets of tangent vectors.\n\n    Parameters\n    ----------\n    ut1 : numpy array\n        The first set of unit tangent vectors.\n    ut2 : numpy array\n        The second set of unit tangent vectors.\n\n    Returns\n    -------\n    angle : numpy array\n        The crossing angles between the tangent vectors.\n\n    Note\n    ----\n    This function assumes that the input tangent vectors are unit vectors.\n    The crossing angles are useful for mesh analysis and processing.\n\n    (for orthogonal / isogonal case)\n\n    See Also\n    --------\n    get_v4_unit_tangents : Computes the unit tangent vectors for vertices with valence 4.\n    \"\"\"\n    cos1 = np.einsum('ij,ij-&gt;i', ut1,ut2)\n    A = np.arccos(cos1)*180/np.pi\n    print('----- net crossing angles : -------')\n    print('max=', '%.2g' % np.max(A))\n    print('mean=', '%.2g' % np.mean(A))\n    print('min=', '%.2g' % np.min(A))\n    print('----------------------------------')\n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_patch_and_rot_matrix_ind","title":"<code>get_patch_and_rot_matrix_ind(self)</code>","text":"<p>Retrieves the indices of vertices in the patch and rotational matrices.</p> <p>This function identifies the vertices in the patch and rotational matrices  and returns their indices.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>indices</code> <code>list</code> <p>A list containing the indices of vertices in the patch and rotational matrices.</p> Note <p>This function assumes that the mesh is a regular patch or rotational mesh. The indices are useful for accessing specific vertices in the mesh.</p> <p>only work for patch/annulus srf from mesh rrvertex, return [v1-v-v3] in column direction of indM                             [v2-v-v4] in row direction of indM indM_inner = [[0,1,2,3,4,5],                 [6,7,8,9,10,11]                 [......]                 []][v,v1,v2,v3,v4] ~ indM_inn [v[indv],v1[indv],v2[indv],v3[indv],v4[indv]] ~ indM_inner indv: indices of M_inn in rrv4f4 [ivf1,ivf2,ivf3,ivf4]: quadfaces indices of M_inn_inn in rrv4f4</p> See Also <p>regular_rectangle_patch : Creates a patch matrix for a rectangular mesh. regular_rotational_patch : Creates a patch matrix for a rotational mesh.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_patch_and_rot_matrix_ind(self):\n    \"\"\"\n    Retrieves the indices of vertices in the patch and rotational matrices.\n\n    This function identifies the vertices in the patch and rotational matrices \n    and returns their indices.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    indices : list\n        A list containing the indices of vertices in the patch and rotational matrices.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular patch or rotational mesh.\n    The indices are useful for accessing specific vertices in the mesh.\n\n    only work for patch/annulus srf\n    from mesh rrvertex, return [v1-v-v3] in column direction of indM\n                                [v2-v-v4] in row direction of indM\n    indM_inner = [[0,1,2,3,4,5],\n                    [6,7,8,9,10,11]\n                    [......]\n                    []]\n    [v,v1,v2,v3,v4] ~ indM_inn\n    [v[indv],v1[indv],v2[indv],v3[indv],v4[indv]] ~ indM_inner\n    indv: indices of M_inn in rrv4f4\n    [ivf1,ivf2,ivf3,ivf4]: quadfaces indices of M_inn_inn in rrv4f4\n\n\n    See Also\n    --------\n    regular_rectangle_patch : Creates a patch matrix for a rectangular mesh.\n    regular_rotational_patch : Creates a patch matrix for a rotational mesh.\n    \"\"\"\n    v,v1,v2,v3,v4 = self.rrv4f4\n\n    is_patch_or_rotation = True\n    \"shared by project self.mesh, pleated, aotu\"\n    if len(self.corner)!=0:\n        \"[0,1,2,3,4,5]\"\n        M = self.patch_matrix\n        M_inn = M[1:-1,1:-1]\n    else:\n        \"[0,1,2,3,4,5; 0]\"\n        M = self.rot_patch_matrix ##M[:,-1]==M[:,0]\n        M_inn = M[1:-1,:]\n        is_patch_or_rotation = False\n\n    self._is_patch_or_rot = is_patch_or_rotation\n\n    i,j = np.where(M==v[0])\n    \"note i,j may equal to [1 1] [ 0 80]\"\n    i,j = i[0], j[0]\n    if M[i-1,j]==v1[0] or M[i-1,j]==v3[0]:\n        \"choose the vertical of M being [v1-v-v3], then horizon is [v2-v-v4]\"\n        pass\n    elif M[i-1,j]==v2[0] or M[i-1,j]==v4[0]:\n        M_inn = M_inn.T\n        M = M.T\n    else:\n        print(\"there is a bug of the corresponding between rrvstar and indM\")\n\n    self._vMatrix = M\n\n    indv = []\n    for iv in M_inn.flatten():\n        j = np.where(v==iv)[0][0]\n        indv.append(j)\n    indv = np.array(indv)\n    #Vc = V[v[indv]] ##note will not update later optimization\n    #V1,V2,V3,V4 = V[v1[indv]],V[v2[indv]],V[v3[indv]],V[v4[indv]]\n\n    indvM = indv.reshape(M_inn.shape) ##~M_inn\n    ivf1 = indvM[:-1,:-1].flatten()\n    ivf2 = indvM[1:,:-1].flatten()\n    ivf3 = indvM[1:,1:].flatten()\n    ivf4 = indvM[:-1,1:].flatten() \n    vf1,vf2,vf3,vf4 = v[ivf1],v[ivf2],v[ivf3],v[ivf4]\n\n    indM = np.arange(M.shape[0]*M.shape[1]).reshape(-1,M.shape[1])\n    indM_inn = np.arange(M_inn.shape[0]*M_inn.shape[1]).reshape(-1,M_inn.shape[1])\n\n    f1 = M[:-1,:-1].flatten()\n    f2 = M[1:,:-1].flatten()\n    f3 = M[1:,1:].flatten()\n    f4 = M[:-1,1:].flatten()  \n    self._v3D_f1234 = [f1,f2,f3,f4]\n\n    if1 = indM_inn[:-1,:-1].flatten()\n    if2 = indM_inn[1:,:-1].flatten()\n    if3 = indM_inn[1:,1:].flatten()\n    if4 = indM_inn[:-1,1:].flatten()  \n    self._vind_f1234 = [len(ivf1),[vf1,vf2,vf3,vf4],[if1,if2,if3,if4]]##~rrv4f4~binormal\n\n    num_row,num_col = M.shape\n    Vnum_2D = num_row * num_col\n    self._Vnum_2D = Vnum_2D\n\n    if len(self.corner)!=0:\n        arr = np.arange(Vnum_2D)\n        M2D = arr.reshape(num_row,-1)\n    else:\n        arr = np.arange(Vnum_2D-num_row)\n        Minn = arr.reshape(num_row,-1)\n        col = Vnum_2D-num_row + np.arange(num_row)\n        M2D = np.insert(Minn,Minn.shape[1],col,axis=1)\n    self._vMatrix2d = M2D\n    f1 = M2D[:-1,:-1].flatten()\n    f2 = M2D[1:,:-1].flatten()\n    f3 = M2D[1:,1:].flatten()\n    f4 = M2D[:-1,1:].flatten() \n    self._v2D_f1234 = [f1,f2,f3,f4]\n\n    return [[v,v1,v2,v3,v4], [v[indv],v1[indv],v2[indv],v3[indv],v4[indv]],\\\n        [M, M_inn], [indM,indM_inn], indv]\n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_polyline_from_an_edge","title":"<code>get_polyline_from_an_edge(self, e, is_bdry=False, is_halfedge=True, is_poly=False)</code>","text":"<p>Retrieves a polyline from a specified edge.</p> <p>This function identifies and returns a polyline based on the specified edge.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>int</code> <p>The index of the edge.</p> required <code>is_bdry</code> <code>(bool, optional(default=False))</code> <p>Whether the edge is on the boundary.</p> <code>False</code> <code>is_halfedge</code> <code>(bool, optional(default=True))</code> <p>Whether to consider half-edges.</p> <code>True</code> <code>is_poly</code> <code>(bool, optional(default=False))</code> <p>Whether to return the result as a polyline.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>iv</code> <code>numpy array</code> <p>The indices of vertices forming the polyline.</p> <code>VV</code> <code>numpy array</code> <p>The coordinates of vertices forming the polyline.</p> <code>poly</code> <code>Polyline object</code> <p>The polyline object (if is_poly=True).</p> Note <p>This function assumes that the mesh is a regular mesh. The polyline is useful for mesh analysis and processing.</p> See Also <p>get_polylines_from_edges : Retrieves polylines from a list of edges.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_polyline_from_an_edge(self, e, is_bdry=False, is_halfedge=True, is_poly=False):\n    \"\"\"\n    Retrieves a polyline from a specified edge.\n\n    This function identifies and returns a polyline based on the specified edge.\n\n    Parameters\n    ----------\n    e : int\n        The index of the edge.\n    is_bdry : bool, optional (default=False)\n        Whether the edge is on the boundary.\n    is_halfedge : bool, optional (default=True)\n        Whether to consider half-edges.\n    is_poly : bool, optional (default=False)\n        Whether to return the result as a polyline.\n\n    Returns\n    -------\n    iv : numpy array\n        The indices of vertices forming the polyline.\n    VV : numpy array\n        The coordinates of vertices forming the polyline.\n    poly : Polyline object\n        The polyline object (if is_poly=True).\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The polyline is useful for mesh analysis and processing.\n\n    See Also\n    --------\n    get_polylines_from_edges : Retrieves polylines from a list of edges.\n    \"\"\"\n    H = self.halfedges\n    vl = vr = np.array([],dtype=int)\n    if H[e,1]==-1:\n        if is_bdry:\n            \"loop case\"\n            while H[e,0] not in vl:\n                vl = np.r_[vl,H[e,0]]\n                e = H[e,2]\n            iv = vl\n        else:\n            e0 = e\n            while H[H[e,4],0] not in self.corner:\n                vr = np.r_[vr, H[H[e,4],0]]\n                e = H[e,2]\n            vr = np.r_[vr, H[H[e,4],0]]\n            e = e0\n            while H[H[e,3],0] not in self.corner:\n                vl = np.r_[vl, H[H[e,3],0]]\n                e = H[e,3]\n            vl = np.r_[vl, H[H[e,3],0]]\n            iv = np.r_[vl[::-1],H[e0,0],vr]\n            #print('H[e,1]==-1',iv)\n        VV = self.vertices[iv]\n    elif H[H[e,4],1]==-1:\n        if is_bdry:\n            \"loop case\"\n            e = H[e,4]\n            while H[e,0] not in vl:\n                vl = np.r_[vl,H[e,0]]\n                e = H[e,2]\n            iv = vl\n        else:\n            e0 = H[e,4]\n            e = e0\n            while H[H[e,4],0] not in self.corner:\n                vr = np.r_[vr, H[H[e,4],0]]\n                e = H[e,2]\n            vr = np.r_[vr, H[H[e,4],0]]\n            e = e0\n            while H[H[e,3],0] not in self.corner:\n                vl = np.r_[vl, H[H[e,3],0]]\n                e = H[e,3]\n            vl = np.r_[vl, H[H[e,3],0]]\n            iv = np.r_[vl[::-1],H[e0,0],vr]\n            #print('H[H[e,4],1]==-1',iv)\n        VV = self.vertices[iv]\n    else:\n        if is_halfedge:\n            il,ir = e,H[e,4]\n        else:\n            ##print(np.where(H[:,5]==e),H[e,0],H[H[e,4],0])\n            il,ir = np.where(H[:,5]==e)[0] # should be two\n        vl = np.r_[vl,H[il,0]]\n        while H[H[H[il,2],4],1]!=-1 and H[H[H[H[H[il,2],4],2],4],1]!=-1:\n            il = H[H[H[il,2],4],2]\n            if H[il,0] in vl:\n                break\n            vl = np.r_[vl, H[il,0]]\n        vl = np.r_[vl,H[H[il,4],0]]\n        while H[H[H[ir,2],4],1]!=-1 and H[H[H[H[H[ir,2],4],2],4],1]!=-1:\n            ir = H[H[H[ir,2],4],2]\n            if  H[H[ir,4],0] in vr:\n                break\n            vr = np.r_[vr, H[H[ir,4],0]]     \n        \"Vl = self.vertices[vl[::-1]]; Vr = self.vertices[vr]\"\n        iv = np.r_[vl[::-1],vr]\n        VV = self.vertices[iv]\n        if is_poly:\n            poly = make_polyline_from_endpoints(VV[:-1,:],VV[1:,:])\n            return iv,VV,poly\n\n        if False:#has problem\n            \"\"\"above shows a problem for the chebyshev-sphere mesh, \n                seem has extra1pt from bdry (in fact the first one), \n                remove such point\n            \"\"\"\n            j = []\n            for i, v in enumerate(iv):\n                if False:\n                    \"work, [v0,vwrong,v1,..]\"\n                    if i&lt;len(iv)-1:\n                        e = None\n                        ei = np.where(H[:,0]==v)[0]\n                        ej = np.where(H[H[:,4],0]==iv[i+1])[0]\n                        e = np.intersect1d(ei,ej)[0]\n                        if e is None:\n                            j.append(i)\n                            #print('1',j)\n                        if H[H[H[e,4],3],0] in iv:\n                            j.append(i+1)\n                            #print('2',j)\n                        if H[H[e,3],0] in iv:\n                            j.append(i+1)\n                            # print('3',j)\n                else:\n                    if i&lt;len(iv)-1 and i&gt;0:\n                        #print(iv[i-1],iv[i],iv[i+1])\n                        e1 = np.where(H[:,0]==iv[i-1])[0]\n                        e2 = np.where(H[:,0]==iv[i])[0]\n                        e3 = np.where(H[:,0]==iv[i+1])[0]\n                        #print(e1,e2,e3)\n                        e12,e23 = None,None\n                        e12 = np.intersect1d(H[e2,4],e1)[0]\n                        e23 = np.intersect1d(H[e2,4],e3)[0]\n                        #print(e12,e23)\n                        if e12 is None or e23 is None:\n                            j.append(i)\n                            print('123',e12,e23,i)\n            j = np.unique(j)\n            #print(iv,j)\n            if len(j) !=0:\n                iv = np.delete(iv,j)\n                VV = self.vertices[iv]   \n            #print(iv)\n    return iv,VV\n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_polylines_fair_index","title":"<code>get_polylines_fair_index(self, es, vvv, vva, vvb)</code>","text":"<p>Retrieves indices of fair polylines.</p> <p>This function identifies and returns the indices of fair polylines based  on the specified edges and vertex lists.</p> <p>Parameters:</p> Name Type Description Default <code>es</code> <code>list</code> <p>The list of edge indices.</p> required <code>vvv</code> <code>list</code> <p>The list of vertex indices.</p> required <code>vva</code> <code>list</code> <p>The list of neighboring vertex indices.</p> required <code>vvb</code> <code>list</code> <p>The list of neighboring vertex indices.</p> required <p>Returns:</p> Name Type Description <code>indices</code> <code>numpy array</code> <p>The indices of fair polylines.</p> Note <p>This function assumes that the mesh is a regular mesh. The indices are useful for accessing specific polylines in the mesh.</p> <p>vvv=[v,v],vva=[v1,v2],vvb=[v3,v4]</p> See Also <p>get_polyline_from_an_edge : Retrieves a polyline from an edge.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_polylines_fair_index(self, es, vvv, vva, vvb):\n    \"\"\"\n    Retrieves indices of fair polylines.\n\n    This function identifies and returns the indices of fair polylines based \n    on the specified edges and vertex lists.\n\n    Parameters\n    ----------\n    es : list\n        The list of edge indices.\n    vvv : list\n        The list of vertex indices.\n    vva : list\n        The list of neighboring vertex indices.\n    vvb : list\n        The list of neighboring vertex indices.\n\n    Returns\n    -------\n    indices : numpy array\n        The indices of fair polylines.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The indices are useful for accessing specific polylines in the mesh.\n\n    vvv=[v,v],vva=[v1,v2],vvb=[v3,v4]\n\n    See Also\n    --------\n    get_polyline_from_an_edge : Retrieves a polyline from an edge.\n    \"\"\"\n    #v,v1,v2,v3,v4 = self.ver_regular_star.T\n    ivs,_,_ = self.get_polylines_from_edges(es)\n    idvl = []\n    for iv in ivs:\n        iia = np.where(vva==iv)[0]\n        if len(iia)!=0:\n            for i in iia:\n                if vvv[i] in ivs and vvb[i] in ivs:\n                    idvl.append(i)\n    return np.array(idvl,dtype=int)    \n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_polylines_from_edges","title":"<code>get_polylines_from_edges(self, es, is_poly=True)</code>","text":"<p>Retrieves polylines from a list of edges.</p> <p>This function identifies and returns polylines based on the specified edges.</p> <p>Parameters:</p> Name Type Description Default <code>es</code> <code>list</code> <p>The list of edge indices.</p> required <code>is_poly</code> <code>(bool, optional(default=True))</code> <p>Whether to return the result as polylines.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>ivs</code> <code>numpy array</code> <p>The indices of vertices forming the polylines.</p> <code>V</code> <code>numpy array</code> <p>The coordinates of vertices forming the polylines.</p> <code>polys</code> <code>list</code> <p>The list of polylines (if is_poly=True).</p> Note <p>This function assumes that the mesh is a regular mesh. The polylines are useful for mesh analysis and processing.</p> See Also <p>get_polyline_from_an_edge : Retrieves a polyline from an edge.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_polylines_from_edges(self, es, is_poly=True):\n    \"\"\"\n    Retrieves polylines from a list of edges.\n\n    This function identifies and returns polylines based on the specified edges.\n\n    Parameters\n    ----------\n    es : list\n        The list of edge indices.\n    is_poly : bool, optional (default=True)\n        Whether to return the result as polylines.\n\n    Returns\n    -------\n    ivs : numpy array\n        The indices of vertices forming the polylines.\n    V : numpy array\n        The coordinates of vertices forming the polylines.\n    polys : list\n        The list of polylines (if is_poly=True).\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The polylines are useful for mesh analysis and processing.\n\n    See Also\n    --------\n    get_polyline_from_an_edge : Retrieves a polyline from an edge.\n    \"\"\"\n    V = self.vertices\n    ivs = np.array([],dtype=int)\n    ns = []\n    for e in es:\n        iv,VV = self.get_polyline_from_an_edge(e,is_halfedge=False)\n        ivs = np.r_[ivs, iv]\n        ns.append(len(VV)-1)\n    ns = np.array(ns) \n\n    if is_poly:\n        polys = make_multiple_polylines_from_endpoints(V[ivs], ns)\n        return ivs, V[ivs], polys\n    return ivs, V[ivs]\n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_quad_diagonal","title":"<code>get_quad_diagonal(self, V, plot=False)</code>","text":"<p>Computes the diagonal vectors of quad faces for a given set of vertices.</p> <p>This function calculates the diagonal vectors of quad faces and returns  their lengths and unit vectors. Optionally, it can plot the diagonals.</p> <p>Parameters:</p> Name Type Description Default <code>V</code> <code>numpy array</code> <p>The vertex positions.</p> required <code>plot</code> <code>(bool, optional(default=False))</code> <p>Whether to plot the diagonal vectors.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>ld1</code> <code>numpy array</code> <p>The lengths of the first diagonal.</p> <code>ld2</code> <code>numpy array</code> <p>The lengths of the second diagonal.</p> <code>ud1</code> <code>numpy array</code> <p>The unit vectors of the first diagonal.</p> <code>ud2</code> <code>numpy array</code> <p>The unit vectors of the second diagonal.</p> <code>anchor</code> <code>numpy array</code> <p>The anchor points for the diagonals.</p> Note <p>This function assumes that the mesh is a regular mesh with quad faces. The diagonal vectors are useful for mesh analysis and processing.</p> <p>isogonal_ck_based: get diagonal edge_length / unit_vector</p> See Also <p>get_quadface_diagonal : Computes the diagonal vectors of quad faces.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_quad_diagonal(self, V, plot=False):\n    \"\"\"\n    Computes the diagonal vectors of quad faces for a given set of vertices.\n\n    This function calculates the diagonal vectors of quad faces and returns \n    their lengths and unit vectors. Optionally, it can plot the diagonals.\n\n    Parameters\n    ----------\n    V : numpy array\n        The vertex positions.\n    plot : bool, optional (default=False)\n        Whether to plot the diagonal vectors.\n\n    Returns\n    -------\n    ld1 : numpy array\n        The lengths of the first diagonal.\n    ld2 : numpy array\n        The lengths of the second diagonal.\n    ud1 : numpy array\n        The unit vectors of the first diagonal.\n    ud2 : numpy array\n        The unit vectors of the second diagonal.\n    anchor : numpy array\n        The anchor points for the diagonals.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh with quad faces.\n    The diagonal vectors are useful for mesh analysis and processing.\n\n    isogonal_ck_based: get diagonal edge_length / unit_vector\n\n    See Also\n    --------\n    get_quadface_diagonal : Computes the diagonal vectors of quad faces.\n    \"\"\"\n    v1,v2,v3,v4 = self.rr_quadface.T # in odrder\n    ld1 = np.linalg.norm(V[v3]-V[v1],axis=1)\n    ld2 = np.linalg.norm(V[v4]-V[v2],axis=1)\n    ud1 = (V[v3]-V[v1]) / ld1[:,None]\n    ud2 = (V[v4]-V[v2]) / ld2[:,None]\n    anchor = (V[v1]+V[v2]+V[v3]+V[v4]) / 4\n    if plot:\n        a,b = ld1/4.0, ld2/4.0\n        Vr,Vl = anchor+ud1*a[:,None], anchor-ud1*a[:,None]\n        pl1 = make_polyline_from_endpoints(Vl,Vr)\n        Vr,Vl = anchor+ud2*b[:,None], anchor-ud2*b[:,None] \n        pl2 = make_polyline_from_endpoints(Vl,Vr)\n        return pl1,pl2          \n    return ld1,ld2,ud1,ud2,anchor\n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_quadface_diagonal","title":"<code>get_quadface_diagonal(self)</code>","text":"<p>Computes the diagonal vectors of quad faces.</p> <p>This function calculates the diagonal vectors of quad faces and returns  their lengths and unit vectors.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>ld1</code> <code>numpy array</code> <p>The lengths of the first diagonal.</p> <code>ld2</code> <code>numpy array</code> <p>The lengths of the second diagonal.</p> <code>ud1</code> <code>numpy array</code> <p>The unit vectors of the first diagonal.</p> <code>ud2</code> <code>numpy array</code> <p>The unit vectors of the second diagonal.</p> Note <p>This function assumes that the mesh is a regular mesh with quad faces. The diagonal vectors are useful for mesh analysis and processing.</p> <p>for isometry_checkerboard</p> See Also <p>get_quad_diagonal : Computes the diagonal vectors for a given set of vertices.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_quadface_diagonal(self):\n    \"\"\"\n    Computes the diagonal vectors of quad faces.\n\n    This function calculates the diagonal vectors of quad faces and returns \n    their lengths and unit vectors.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    ld1 : numpy array\n        The lengths of the first diagonal.\n    ld2 : numpy array\n        The lengths of the second diagonal.\n    ud1 : numpy array\n        The unit vectors of the first diagonal.\n    ud2 : numpy array\n        The unit vectors of the second diagonal.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh with quad faces.\n    The diagonal vectors are useful for mesh analysis and processing.\n\n    for isometry_checkerboard\n\n    See Also\n    --------\n    get_quad_diagonal : Computes the diagonal vectors for a given set of vertices.\n    \"\"\"\n    vi = self.quadface\n    v1,v2,v3,v4 = vi[::4],vi[1::4],vi[2::4],vi[3::4]\n    ld1 = np.linalg.norm(self.vertices[v1]-self.vertices[v3],axis=1)\n    ld2 = np.linalg.norm(self.vertices[v2]-self.vertices[v4],axis=1)\n    ud1 = (self.vertices[v1]-self.vertices[v3]) / ld1[:,None]\n    ud2 = (self.vertices[v2]-self.vertices[v4]) / ld2[:,None]\n    return ld1,ld2,ud1,ud2\n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_quad_mesh_1family_isoline","title":"<code>get_quad_mesh_1family_isoline(self, diagnet=False, direction=True, edge=False)</code>","text":"<p>Retrieves one family of isolines from the quad mesh.</p> <p>This function identifies and returns one family of isolines from the quad mesh,  optionally considering diagonal edges and edge data.</p> <p>Parameters:</p> Name Type Description Default <code>diagnet</code> <code>(bool, optional(default=False))</code> <p>Whether to consider diagonal edges.</p> <code>False</code> <code>direction</code> <code>(bool, optional(default=True))</code> <p>The direction of the isolines.</p> <code>True</code> <code>edge</code> <code>(bool, optional(default=False))</code> <p>Whether to return edge data.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>isolines</code> <code>Polyline object</code> <p>The isolines in the specified direction.</p> <code>edge_data</code> <code>numpy array, optional</code> <p>The edge data (if edge=True).</p> Note <p>This function assumes that the mesh is a quad mesh. The isolines are useful for mesh analysis and visualization.</p> See Also <p>get_quad_mesh_2family_isolines : Retrieves two families of isolines.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_quad_mesh_1family_isoline(self, diagnet=False, direction=True, edge=False):\n    \"\"\"\n    Retrieves one family of isolines from the quad mesh.\n\n    This function identifies and returns one family of isolines from the quad mesh, \n    optionally considering diagonal edges and edge data.\n\n    Parameters\n    ----------\n    diagnet : bool, optional (default=False)\n        Whether to consider diagonal edges.\n    direction : bool, optional (default=True)\n        The direction of the isolines.\n    edge : bool, optional (default=False)\n        Whether to return edge data.\n\n    Returns\n    -------\n    isolines : Polyline object\n        The isolines in the specified direction.\n    edge_data : numpy array, optional\n        The edge data (if edge=True).\n\n    Note\n    ----\n    This function assumes that the mesh is a quad mesh.\n    The isolines are useful for mesh analysis and visualization.\n\n    See Also\n    --------\n    get_quad_mesh_2family_isolines : Retrieves two families of isolines.\n    \"\"\"    \n    V = self.vertices\n    v1,v2 = self.get_1family_oriented_polyline(diagnet,poly2=direction)\n    pl = make_polyline_from_endpoints(V[v1],V[v2])\n    if edge:\n        \"edge_data = np.zeros(self.E)\"\n        H = self.halfedges\n        e,ib,eb = [],[],[]\n        for i in range(len(v1)):\n            a,b = v1[i],v2[i]\n            j = np.where(H[:,0]==a)[0]\n            k = np.where(H[H[:,4],0]==b)[0]\n            m = np.intersect1d(j,k)[0]\n            e.append(H[m,5])\n            if H[m,1]==-1 or H[H[m,4],1]==-1:\n                ib.append(i)\n                eb.append(H[m,5])\n        return pl, np.array(e),[np.array(ib),np.array(eb)]\n    else:\n        an,vec = V[v1], V[v2]-V[v1]\n        return pl,an,vec \n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_quad_midline","title":"<code>get_quad_midline(self)</code>","text":"<p>Computes the midlines of quad faces in the mesh.</p> <p>This function calculates the midlines of quad faces and returns the  corresponding polylines.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>pl1</code> <code>Polyline object</code> <p>The first midline polyline.</p> <code>pl2</code> <code>Polyline object</code> <p>The second midline polyline.</p> Note <p>This function assumes that the mesh is a regular mesh with quad faces. The midlines are useful for mesh analysis and processing.</p> See Also <p>get_quad_diagonal : Computes the diagonal vectors of quad faces.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_quad_midline(self):\n    \"\"\"\n    Computes the midlines of quad faces in the mesh.\n\n    This function calculates the midlines of quad faces and returns the \n    corresponding polylines.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    pl1 : Polyline object\n        The first midline polyline.\n    pl2 : Polyline object\n        The second midline polyline.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh with quad faces.\n    The midlines are useful for mesh analysis and processing.\n\n    See Also\n    --------\n    get_quad_diagonal : Computes the diagonal vectors of quad faces.\n    \"\"\"\n    V = self.vertices\n    v1,v2,v3,v4 = self.rr_quadface.T\n    V12 = (V[v1]+V[v2])/2.0\n    V23 = (V[v2]+V[v3])/2.0\n    V34 = (V[v3]+V[v4])/2.0\n    V41 = (V[v4]+V[v1])/2.0\n    pl1 = make_polyline_from_endpoints(V12,V34)\n    pl2 = make_polyline_from_endpoints(V23,V41)\n    return pl1,pl2   \n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_quad_midpoint_cross_vectors","title":"<code>get_quad_midpoint_cross_vectors(self, plot=False, scale=1 / 3)</code>","text":"<p>Computes the midpoint cross vectors of quad faces.</p> <p>This function calculates the midpoint cross vectors of quad faces and  returns their lengths and unit vectors. Optionally, it can plot the vectors.</p> <p>Parameters:</p> Name Type Description Default <code>plot</code> <code>(bool, optional(default=False))</code> <p>Whether to plot the midpoint cross vectors.</p> <code>False</code> <code>scale</code> <code>(float, optional(default=1 / 3))</code> <p>The scaling factor for the vectors.</p> <code>1 / 3</code> <p>Returns:</p> Name Type Description <code>lp</code> <code>numpy array</code> <p>The lengths of the first cross vector.</p> <code>lq</code> <code>numpy array</code> <p>The lengths of the second cross vector.</p> <code>m13</code> <code>numpy array</code> <p>The unit vectors of the first cross vector.</p> <code>m24</code> <code>numpy array</code> <p>The unit vectors of the second cross vector.</p> <code>anchor</code> <code>numpy array</code> <p>The anchor points for the cross vectors.</p> Note <p>This function assumes that the mesh is a regular mesh with quad faces. The midpoint cross vectors are useful for mesh analysis and processing.</p> <p>isogonal_face_based: get quadface midpoint edge_length / unit_vector</p> See Also <p>get_quad_diagonal : Computes the diagonal vectors of quad faces.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_quad_midpoint_cross_vectors(self, plot=False, scale=1/3):\n    \"\"\"\n    Computes the midpoint cross vectors of quad faces.\n\n    This function calculates the midpoint cross vectors of quad faces and \n    returns their lengths and unit vectors. Optionally, it can plot the vectors.\n\n    Parameters\n    ----------\n    plot : bool, optional (default=False)\n        Whether to plot the midpoint cross vectors.\n    scale : float, optional (default=1/3)\n        The scaling factor for the vectors.\n\n    Returns\n    -------\n    lp : numpy array\n        The lengths of the first cross vector.\n    lq : numpy array\n        The lengths of the second cross vector.\n    m13 : numpy array\n        The unit vectors of the first cross vector.\n    m24 : numpy array\n        The unit vectors of the second cross vector.\n    anchor : numpy array\n        The anchor points for the cross vectors.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh with quad faces.\n    The midpoint cross vectors are useful for mesh analysis and processing.\n\n    isogonal_face_based: get quadface midpoint edge_length / unit_vector\n\n    See Also\n    --------\n    get_quad_diagonal : Computes the diagonal vectors of quad faces.\n    \"\"\"\n    v1,v2,v3,v4 = self.rr_quadface.T # in odrder\n    e1 = self.vertices[v3]+self.vertices[v4]-self.vertices[v1]-self.vertices[v2]\n    e2 = self.vertices[v1]+self.vertices[v4]-self.vertices[v2]-self.vertices[v3]\n    ld1 = np.linalg.norm(e1,axis=1)\n    ld2 = np.linalg.norm(e2,axis=1)\n    ud1 = e1 / ld1[:,None]\n    ud2 = e2 / ld2[:,None]\n    anchor = (self.vertices[v1]+self.vertices[v2]+self.vertices[v3]+self.vertices[v4]) / 4\n    if plot:\n        a,b = ld1*scale, ld2*scale\n        Vr,Vl = anchor+ud1*a[:,None], anchor-ud1*a[:,None]\n        pl1 = make_polyline_from_endpoints(Vl,Vr)\n        Vr,Vl = anchor+ud2*b[:,None], anchor-ud2*b[:,None] \n        pl2 = make_polyline_from_endpoints(Vl,Vr)\n        return pl1,pl2            \n    return ld1,ld2,ud1,ud2,anchor\n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_quad_parallelogram","title":"<code>get_quad_parallelogram(self, is_theta_equal_theta0=False, is_plot=False)</code>","text":"<p>Computes the properties of parallelogram faces in the mesh.</p> <p>This function calculates the properties of parallelogram faces, including  lengths, angles, and similarity metrics. Optionally, it can plot the results.</p> <p>Parameters:</p> Name Type Description Default <code>is_theta_equal_theta0</code> <code>(bool, optional(default=False))</code> <p>Whether to assume equal angles.</p> <code>False</code> <code>is_plot</code> <code>(bool, optional(default=False))</code> <p>Whether to plot the results.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>properties</code> <code>numpy array</code> <p>The computed properties of the parallelogram faces.</p> Note <p>This function assumes that the mesh is a regular mesh with parallelogram faces. The properties are useful for mesh analysis and processing.</p> <p>I-net with similar parallelograms</p> See Also <p>get_quad_parallelogram_similarity : Computes the similarity of parallelogram faces.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_quad_parallelogram(self, is_theta_equal_theta0=False, is_plot=False):\n    \"\"\"\n    Computes the properties of parallelogram faces in the mesh.\n\n    This function calculates the properties of parallelogram faces, including \n    lengths, angles, and similarity metrics. Optionally, it can plot the results.\n\n    Parameters\n    ----------\n    is_theta_equal_theta0 : bool, optional (default=False)\n        Whether to assume equal angles.\n    is_plot : bool, optional (default=False)\n        Whether to plot the results.\n\n    Returns\n    -------\n    properties : numpy array\n        The computed properties of the parallelogram faces.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh with parallelogram faces.\n    The properties are useful for mesh analysis and processing.\n\n    I-net with similar parallelograms\n\n    See Also\n    --------\n    get_quad_parallelogram_similarity : Computes the similarity of parallelogram faces.\n    \"\"\"\n    la,lb,d1,d2,_ = self.get_quad_diagonal(self.vertices)\n    lp,lq,m13,m24,anchor = self.get_quad_midpoint_cross_vectors()\n    La,Lb,Lp,Lq = la**2,lb**2,lp**2,lq**2\n    c1,c2 = Lb/La, Lq/Lp\n    lamda,mu = np.mean(np.sqrt(c1)),np.mean(np.sqrt(c2))\n    delt1 = np.sqrt(mu-1)\n    delt2 = lamda*mu+lamda-mu+1\n    delt3 = -lamda*mu+lamda+mu+1\n    A = np.mean(c1)\n    delt4 = np.sqrt(np.abs(A-np.sqrt(2)+1))\n    delt5 = np.sqrt(np.abs(np.sqrt(2)+1-A))\n\n    if is_plot:\n        v1,v2,_,_ = self.rr_quadface.T\n        an1 = (self.vertices[v1]+self.vertices[v2])*0.5\n        return [an1,d1,d2, anchor, m13,m24] \n\n    if is_theta_equal_theta0:\n        return np.r_[La,Lb,A,delt4,delt5]\n    else:\n        return np.r_[La,Lb,Lp,Lq,c1,c2,lamda,mu,delt1,delt2,delt3]\n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_quad_parallelogram_similarity","title":"<code>get_quad_parallelogram_similarity(self)</code>","text":"<p>Computes the similarity of parallelogram faces in the mesh.</p> <p>This function calculates the similarity metrics of parallelogram faces,  including lambda and mu values.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>lambda</code> <code>numpy array</code> <p>The lambda values for the parallelogram faces.</p> <code>mu</code> <code>numpy array</code> <p>The mu values for the parallelogram faces.</p> Note <p>This function assumes that the mesh is a regular mesh with parallelogram faces. The similarity metrics are useful for mesh analysis and processing.</p> See Also <p>get_quad_parallelogram : Computes the properties of parallelogram faces.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_quad_parallelogram_similarity(self):\n    \"\"\"\n    Computes the similarity of parallelogram faces in the mesh.\n\n    This function calculates the similarity metrics of parallelogram faces, \n    including lambda and mu values.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    lambda : numpy array\n        The lambda values for the parallelogram faces.\n    mu : numpy array\n        The mu values for the parallelogram faces.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh with parallelogram faces.\n    The similarity metrics are useful for mesh analysis and processing.\n\n    See Also\n    --------\n    get_quad_parallelogram : Computes the properties of parallelogram faces.\n    \"\"\"\n    V = self.vertices\n    v1,v2,v3,v4 = self.rr_quadface.T # in odrder\n    la = np.linalg.norm(V[v1]-V[v3],axis=1)\n    lb = np.linalg.norm(V[v2]-V[v4],axis=1)\n    lp = np.linalg.norm(V[v3]+V[v4]-V[v1]-V[v2],axis=1)\n    lq = np.linalg.norm(V[v1]+V[v4]-V[v2]-V[v3],axis=1)\n    lamda,mu = lb/la, lq/lp\n    return lamda, mu\n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_quad_midline","title":"<code>get_quad_midline(self)</code>","text":"<p>Computes the midlines of quad faces in the mesh.</p> <p>This function calculates the midlines of quad faces and returns the  corresponding polylines.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>pl1</code> <code>Polyline object</code> <p>The first midline polyline.</p> <code>pl2</code> <code>Polyline object</code> <p>The second midline polyline.</p> Note <p>This function assumes that the mesh is a regular mesh with quad faces. The midlines are useful for mesh analysis and processing.</p> See Also <p>get_quad_diagonal : Computes the diagonal vectors of quad faces.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_quad_midline(self):\n    \"\"\"\n    Computes the midlines of quad faces in the mesh.\n\n    This function calculates the midlines of quad faces and returns the \n    corresponding polylines.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    pl1 : Polyline object\n        The first midline polyline.\n    pl2 : Polyline object\n        The second midline polyline.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh with quad faces.\n    The midlines are useful for mesh analysis and processing.\n\n    See Also\n    --------\n    get_quad_diagonal : Computes the diagonal vectors of quad faces.\n    \"\"\"\n    V = self.vertices\n    v1,v2,v3,v4 = self.rr_quadface.T\n    V12 = (V[v1]+V[v2])/2.0\n    V23 = (V[v2]+V[v3])/2.0\n    V34 = (V[v3]+V[v4])/2.0\n    V41 = (V[v4]+V[v1])/2.0\n    pl1 = make_polyline_from_endpoints(V12,V34)\n    pl2 = make_polyline_from_endpoints(V23,V41)\n    return pl1,pl2   \n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_rr_quadface_boundaryquad_index","title":"<code>get_rr_quadface_boundaryquad_index(self, vb_quad=True)</code>","text":"<p>Retrieves the indices of boundary quad faces in the regular quad face list.</p> <p>This function identifies the boundary quad faces and returns their indices  in the regular quad face list.</p> <p>Parameters:</p> Name Type Description Default <code>vb_quad</code> <code>(bool, optional(default=True))</code> <p>Whether to include quad faces that have vertices on the boundary.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>inner_indices</code> <code>numpy array</code> <p>The indices of inner quad faces.</p> <code>boundary_indices</code> <code>numpy array</code> <p>The indices of boundary quad faces.</p> Note <p>This function assumes that the mesh is a regular mesh. The indices are useful for accessing specific quad faces in the mesh.</p> See Also <p>regular_vertex_regular_quad : Identifies regular vertices and quad faces.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_rr_quadface_boundaryquad_index(self, vb_quad=True):\n    \"\"\"\n    Retrieves the indices of boundary quad faces in the regular quad face list.\n\n    This function identifies the boundary quad faces and returns their indices \n    in the regular quad face list.\n\n    Parameters\n    ----------\n    vb_quad : bool, optional (default=True)\n        Whether to include quad faces that have vertices on the boundary.\n\n    Returns\n    -------\n    inner_indices : numpy array\n        The indices of inner quad faces.\n    boundary_indices : numpy array\n        The indices of boundary quad faces.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The indices are useful for accessing specific quad faces in the mesh.\n\n    See Also\n    --------\n    regular_vertex_regular_quad : Identifies regular vertices and quad faces.\n    \"\"\"\n    v1,v2,v3,v4  = self.rr_quadface.T\n    forder = self.rr_quadface_order\n    fb = self.boundary_faces()\n    _,out,_ = np.intersect1d(forder,fb, return_indices=True)\n    inn = np.setdiff1d(np.arange(len(v1)), out)\n    if vb_quad:\n        \"also including quad'vertex belong to boundary\"\n        boundary = self.boundary_vertices()\n        vb = []\n        for i in inn:\n            if v1[i] in boundary or v2[i] in boundary:\n                vb.append(i)\n            if v3[i] in boundary or v4[i] in boundary:\n                vb.append(i)\n        inn = np.setdiff1d(inn,np.array(vb))\n        out = np.r_[out,np.array(vb,dtype=int)]\n    return inn, out\n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_rr_vs_4face_centers","title":"<code>get_rr_vs_4face_centers(self)</code>","text":"<p>Computes the centers of regular quad faces in the mesh.</p> <p>This function calculates the geometric centers (barycenters) of regular quad  faces in the mesh. The centers are computed as the average of the vertex  positions of each quad face.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>face_centers</code> <code>numpy array</code> <p>The coordinates of the centers of regular quad faces.</p> Note <p>This function assumes that the mesh is a regular mesh with quad faces. The face centers are useful for mesh analysis, processing, and visualization.</p> Example <p>mesh = Mesh()  # Assuming Mesh is a class that contains the mesh data face_centers = mesh.get_rr_vs_4face_centers() print(face_centers) Array of face center coordinates</p> See Also <p>get_rr_vs_bounary : Separates regular vertices into inner and boundary vertices. get_rr_quadface_boundaryquad_index : Retrieves indices of boundary quad faces.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_rr_vs_4face_centers(self):\n    \"\"\"\n    Computes the centers of regular quad faces in the mesh.\n\n    This function calculates the geometric centers (barycenters) of regular quad \n    faces in the mesh. The centers are computed as the average of the vertex \n    positions of each quad face.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    face_centers : numpy array\n        The coordinates of the centers of regular quad faces.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh with quad faces.\n    The face centers are useful for mesh analysis, processing, and visualization.\n\n    Example\n    -------\n    &gt;&gt;&gt; mesh = Mesh()  # Assuming Mesh is a class that contains the mesh data\n    &gt;&gt;&gt; face_centers = mesh.get_rr_vs_4face_centers()\n    &gt;&gt;&gt; print(face_centers)\n    Array of face center coordinates\n\n    See Also\n    --------\n    get_rr_vs_bounary : Separates regular vertices into inner and boundary vertices.\n    get_rr_quadface_boundaryquad_index : Retrieves indices of boundary quad faces.\n    \"\"\"\n    V = self.vertices\n    f4 = self.rr_4quad_vers\n    f41,f42,f43,f44 = f4[::4],f4[1::4],f4[2::4],f4[3::4]\n    def _face_center(f4i):\n        fic = (V[f4i[::1]]+V[f4i[1::4]]+V[f4i[2::4]]+V[f4i[3::4]]) / 4.0\n        return fic\n    f1c = _face_center(f41)\n    f2c = _face_center(f42)\n    f3c = _face_center(f43)\n    f4c = _face_center(f44)\n    return f1c,f2c,f3c,f4c\n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_rr_vs_4face_corner","title":"<code>get_rr_vs_4face_corner(self)</code>","text":"<p>Retrieves the corner vertices of regular quad faces.</p> <p>This function identifies the corner vertices of regular quad faces and  returns their indices.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>corner_vertices</code> <code>numpy array</code> <p>The indices of corner vertices of regular quad faces.</p> Note <p>This function assumes that the mesh is a regular mesh. The corner vertices are useful for mesh analysis and processing.</p> <p>self.rr_star_corner (should be same with get_vs_diagonal_v) vertex star' 4faces' 4 corner vertex [a,b,c,d]     a   1    d     2   v    4     b   3    c</p> See Also <p>regular_vertex_regular_quad : Identifies regular vertices and quad faces.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_rr_vs_4face_corner(self):\n    \"\"\"\n    Retrieves the corner vertices of regular quad faces.\n\n    This function identifies the corner vertices of regular quad faces and \n    returns their indices.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    corner_vertices : numpy array\n        The indices of corner vertices of regular quad faces.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The corner vertices are useful for mesh analysis and processing.\n\n    self.rr_star_corner (should be same with get_vs_diagonal_v)\n    vertex star' 4faces' 4 corner vertex [a,b,c,d]\n        a   1    d\n        2   v    4\n        b   3    c\n\n    See Also\n    --------\n    regular_vertex_regular_quad : Identifies regular vertices and quad faces.\n    \"\"\"\n    H = self.halfedges\n    v,v1,v2,v3,v4 = self.rrv4f4\n    va,vb,vc,vd = [],[],[],[]\n    for i in range(len(v)):\n        e1=np.intersect1d(np.where(H[:,0]==v[i])[0],np.where(H[H[:,4],0]==v1[i])[0])\n        va.append(H[H[H[e1,2],2],0])\n        e2=np.intersect1d(np.where(H[:,0]==v[i])[0],np.where(H[H[:,4],0]==v2[i])[0])\n        vb.append(H[H[H[e2,2],2],0])            \n        e3=np.intersect1d(np.where(H[:,0]==v[i])[0],np.where(H[H[:,4],0]==v3[i])[0])\n        vc.append(H[H[H[e3,2],2],0])\n        e4=np.intersect1d(np.where(H[:,0]==v[i])[0],np.where(H[H[:,4],0]==v4[i])[0])\n        vd.append(H[H[H[e4,2],2],0])      \n    self._rr_star_corner = np.c_[v,va,vb,vc,vd].T    \n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_rr_vs_bounary","title":"<code>get_rr_vs_bounary(self)</code>","text":"<p>Separates regular vertices into inner and boundary vertices.</p> <p>This function identifies which regular vertices are on the boundary and  which are in the interior of the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>inner_indices</code> <code>numpy array</code> <p>Indices of regular vertices that are in the interior.</p> <code>boundary_indices</code> <code>numpy array</code> <p>Indices of regular vertices that are on the boundary.</p> Note <p>This function assumes that the mesh is a regular mesh. The separation of vertices is useful for mesh analysis and processing.</p> See Also <p>boundary_vertices : Retrieves the indices of boundary vertices.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_rr_vs_bounary(self):\n    \"\"\"\n    Separates regular vertices into inner and boundary vertices.\n\n    This function identifies which regular vertices are on the boundary and \n    which are in the interior of the mesh.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    inner_indices : numpy array\n        Indices of regular vertices that are in the interior.\n    boundary_indices : numpy array\n        Indices of regular vertices that are on the boundary.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The separation of vertices is useful for mesh analysis and processing.\n\n    See Also\n    --------\n    boundary_vertices : Retrieves the indices of boundary vertices.\n    \"\"\"\n    fb = self.boundary_faces()\n    vsb = np.array([],dtype=int)\n    for f in fb:\n        vsb = np.r_[vsb,np.array(self.faces_list()[f])]\n    vsb = np.unique(vsb)\n    rrv = self.ver_rrv4f4\n    inn = np.setdiff1d(rrv,vsb)\n    rrb = np.intersect1d(rrv,vsb)\n    idi,idb = [],[]\n    for i in inn:\n        idi.append(np.where(rrv==i)[0][0])\n    for j in rrb:\n        idb.append(np.where(rrv==j)[0][0])\n    return np.array(idi), np.array(idb)\n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_v4_diag_unit_edge","title":"<code>get_v4_diag_unit_edge(self)</code>","text":"<p>Computes the unit edge vectors for diagonal edges of vertices with valence 4.</p> <p>This function calculates the unit edge vectors for diagonal edges of vertices  with valence 4.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>v</code> <code>numpy array</code> <p>The indices of vertices.</p> <code>l1, l2, l3, l4 : numpy array</code> <p>The lengths of the diagonal edge vectors.</p> <code>e1, e2, e3, e4 : numpy array</code> <p>The unit diagonal edge vectors.</p> Note <p>This function assumes that the mesh is a regular mesh. The unit diagonal edge vectors are useful for mesh analysis and processing.</p> See Also <p>get_v4_unit_edge : Computes the unit edge vectors for vertices with valence 4.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_v4_diag_unit_edge(self):\n    \"\"\"\n    Computes the unit edge vectors for diagonal edges of vertices with valence 4.\n\n    This function calculates the unit edge vectors for diagonal edges of vertices \n    with valence 4.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    v : numpy array\n        The indices of vertices.\n    l1, l2, l3, l4 : numpy array\n        The lengths of the diagonal edge vectors.\n    e1, e2, e3, e4 : numpy array\n        The unit diagonal edge vectors.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The unit diagonal edge vectors are useful for mesh analysis and processing.\n\n    See Also\n    --------\n    get_v4_unit_edge : Computes the unit edge vectors for vertices with valence 4.\n    \"\"\"\n    V = self.vertices\n    v,v1,v2,v3,v4 = self.rr_star_corner\n    E1 = V[v1]-V[v]\n    E2 = V[v2]-V[v]\n    E3 = V[v3]-V[v]\n    E4 = V[v4]-V[v]\n    l1 = np.linalg.norm(E1, axis=1)\n    l2 = np.linalg.norm(E2, axis=1)\n    l3 = np.linalg.norm(E3, axis=1)\n    l4 = np.linalg.norm(E4, axis=1)\n    e1 = E1 / l1[:,None]\n    e2 = E2 / l2[:,None]\n    e3 = E3 / l3[:,None]\n    e4 = E4 / l4[:,None]     \n    return v,l1,l2,l3,l4,e1,e2,e3,e4\n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_v4_diag_unit_tangents","title":"<code>get_v4_diag_unit_tangents(self, plot=False)</code>","text":"<p>Computes the unit tangent vectors for diagonal edges of vertices with valence 4.</p> <p>This function calculates the unit tangent vectors for diagonal edges of vertices  with valence 4, optionally plotting the results.</p> <p>Parameters:</p> Name Type Description Default <code>plot</code> <code>(bool, optional(default=False))</code> <p>Whether to plot the tangent vectors.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>lt1, lt2 : numpy array</code> <p>The lengths of the tangent vectors.</p> <code>ut1, ut2 : numpy array</code> <p>The unit tangent vectors.</p> <code>anchor</code> <code>numpy array</code> <p>The anchor points for the tangent vectors.</p> <code>angle</code> <code>numpy array</code> <p>The angles between the tangent vectors.</p> Note <p>This function assumes that the mesh is a regular mesh. The unit tangent vectors are useful for mesh analysis and processing.</p> <p>(only for valence 4, not depends on X)</p> See Also <p>get_v4_unit_tangents : Computes the unit tangent vectors for vertices with valence 4.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_v4_diag_unit_tangents(self, plot=False):\n    \"\"\"\n    Computes the unit tangent vectors for diagonal edges of vertices with valence 4.\n\n    This function calculates the unit tangent vectors for diagonal edges of vertices \n    with valence 4, optionally plotting the results.\n\n    Parameters\n    ----------\n    plot : bool, optional (default=False)\n        Whether to plot the tangent vectors.\n\n    Returns\n    -------\n    lt1, lt2 : numpy array\n        The lengths of the tangent vectors.\n    ut1, ut2 : numpy array\n        The unit tangent vectors.\n    anchor : numpy array\n        The anchor points for the tangent vectors.\n    angle : numpy array\n        The angles between the tangent vectors.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The unit tangent vectors are useful for mesh analysis and processing.\n\n    (only for valence 4, not depends on X)\n\n    See Also\n    --------\n    get_v4_unit_tangents : Computes the unit tangent vectors for vertices with valence 4.\n    \"\"\"\n    v,l1,l2,l3,l4,e1,e2,e3,e4 = self.get_v4_diag_unit_edge()\n    #v,_,_,_,_ = self.rr_star_corner\n    anchor = self.vertices[v]\n    t1 = (e1-e3)\n    t2 = (e2-e4)\n    lt1 = np.linalg.norm(t1,axis=1)\n    lt2 = np.linalg.norm(t2,axis=1)\n    ut1 = t1 / lt1[:,None]\n    ut2 = t2 / lt2[:,None]\n    angle = np.arccos(np.einsum('ij,ij-&gt;i', ut1, ut2))*180/np.pi\n    if plot:\n        a,b = (l1+l3)/6.0, (l2+l4)/6.0\n        Vl,Vr = anchor+ut1*a[:,None], anchor-ut1*a[:,None]\n        pl1 = make_polyline_from_endpoints(Vl,Vr)\n        Vl,Vr = anchor+ut2*b[:,None], anchor-ut2*b[:,None] \n        pl2 = make_polyline_from_endpoints(Vl,Vr)\n        return pl1,pl2           \n    return lt1,lt2,ut1,ut2,anchor,angle\n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_v4_orient_unit_normal","title":"<code>get_v4_orient_unit_normal(self, diag=False, rregular=True)</code>","text":"<p>Computes the oriented unit normal vectors for vertices with valence 4.</p> <p>This function calculates the oriented unit normal vectors for vertices with  valence 4, optionally considering diagonal edges and regular vertices.</p> <p>Parameters:</p> Name Type Description Default <code>diag</code> <code>(bool, optional(default=False))</code> <p>Whether to consider diagonal edges.</p> <code>False</code> <code>rregular</code> <code>(bool, optional(default=True))</code> <p>Whether to consider regular vertices.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>anchor</code> <code>numpy array</code> <p>The anchor points for the normal vectors.</p> <code>unit_normal</code> <code>numpy array</code> <p>The oriented unit normal vectors.</p> <code>angle</code> <code>numpy array</code> <p>The angles between the normal vectors and the reference direction.</p> Note <p>This function assumes that the mesh is a regular mesh. The oriented unit normal vectors are useful for mesh analysis and processing.</p> <p>(updated for each time, orientn; defined at rrv4f4)</p> See Also <p>get_v4_unit_normal : Computes the unit normal vectors for vertices with valence 4.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_v4_orient_unit_normal(self, diag=False, rregular=True):\n    \"\"\"\n    Computes the oriented unit normal vectors for vertices with valence 4.\n\n    This function calculates the oriented unit normal vectors for vertices with \n    valence 4, optionally considering diagonal edges and regular vertices.\n\n    Parameters\n    ----------\n    diag : bool, optional (default=False)\n        Whether to consider diagonal edges.\n    rregular : bool, optional (default=True)\n        Whether to consider regular vertices.\n\n    Returns\n    -------\n    anchor : numpy array\n        The anchor points for the normal vectors.\n    unit_normal : numpy array\n        The oriented unit normal vectors.\n    angle : numpy array\n        The angles between the normal vectors and the reference direction.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The oriented unit normal vectors are useful for mesh analysis and processing.\n\n    (updated for each time, orientn; defined at rrv4f4)\n\n    See Also\n    --------\n    get_v4_unit_normal : Computes the unit normal vectors for vertices with valence 4.\n    \"\"\"\n    v,an,vN = self.get_v4_unit_normal(diag,rregular)\n    Nv = self.vertex_normals()[v]\n    i = np.where(np.einsum('ij,ij-&gt;i',Nv,vN)&lt;0)[0]\n    vN[i] = -vN[i]\n    a = np.sqrt(np.abs(np.einsum('ij,ij-&gt;i',vN,Nv))) ##vN*Nv=a^2\n    return [an,vN,a]\n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_v4_unit_edge","title":"<code>get_v4_unit_edge(self, rregular=True)</code>","text":"<p>Computes the unit edge vectors for vertices with valence 4.</p> <p>This function calculates the unit edge vectors for vertices with valence 4,  optionally considering regular vertices.</p> <p>Parameters:</p> Name Type Description Default <code>rregular</code> <code>(bool, optional(default=True))</code> <p>Whether to consider regular vertices.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>v</code> <code>numpy array</code> <p>The indices of vertices.</p> <code>l1, l2, l3, l4 : numpy array</code> <p>The lengths of the edge vectors.</p> <code>e1, e2, e3, e4 : numpy array</code> <p>The unit edge vectors.</p> Note <p>This function assumes that the mesh is a regular mesh. The unit edge vectors are useful for mesh analysis and processing.</p> See Also <p>get_v4_unit_tangents : Computes the unit tangent vectors for vertices with valence 4.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_v4_unit_edge(self, rregular=True):\n    \"\"\"\n    Computes the unit edge vectors for vertices with valence 4.\n\n    This function calculates the unit edge vectors for vertices with valence 4, \n    optionally considering regular vertices.\n\n    Parameters\n    ----------\n    rregular : bool, optional (default=True)\n        Whether to consider regular vertices.\n\n    Returns\n    -------\n    v : numpy array\n        The indices of vertices.\n    l1, l2, l3, l4 : numpy array\n        The lengths of the edge vectors.\n    e1, e2, e3, e4 : numpy array\n        The unit edge vectors.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The unit edge vectors are useful for mesh analysis and processing.\n\n    See Also\n    --------\n    get_v4_unit_tangents : Computes the unit tangent vectors for vertices with valence 4.\n    \"\"\"\n    V = self.vertices\n    if rregular:\n        v,v1,v2,v3,v4 = self.rrv4f4\n    else:\n        ## v,v1,v2,v3,v4 = self.ver_regular_star.T\n        v,v1,v2,v3,v4 = self.ver_star_matrix.T\n    E1 = V[v1]-V[v]\n    E2 = V[v2]-V[v]\n    E3 = V[v3]-V[v]\n    E4 = V[v4]-V[v]\n    l1 = np.linalg.norm(E1, axis=1)\n    l2 = np.linalg.norm(E2, axis=1)\n    l3 = np.linalg.norm(E3, axis=1)\n    l4 = np.linalg.norm(E4, axis=1)\n    e1 = E1 / l1[:,None]\n    e2 = E2 / l2[:,None]\n    e3 = E3 / l3[:,None]\n    e4 = E4 / l4[:,None]\n    return v,l1,l2,l3,l4,e1,e2,e3,e4\n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_v4_unit_normal","title":"<code>get_v4_unit_normal(self, diag=False, rregular=True)</code>","text":"<p>Computes the unit normal vectors for vertices with valence 4.</p> <p>This function calculates the unit normal vectors for vertices with valence 4,  optionally considering diagonal edges and regular vertices.</p> <p>Parameters:</p> Name Type Description Default <code>diag</code> <code>(bool, optional(default=False))</code> <p>Whether to consider diagonal edges.</p> <code>False</code> <code>rregular</code> <code>(bool, optional(default=True))</code> <p>Whether to consider regular vertices.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>v</code> <code>numpy array</code> <p>The indices of vertices.</p> <code>anchor</code> <code>numpy array</code> <p>The anchor points for the normal vectors.</p> <code>unit_normal</code> <code>numpy array</code> <p>The unit normal vectors.</p> Note <p>This function assumes that the mesh is a regular mesh. The unit normal vectors are useful for mesh analysis and processing.</p> See Also <p>get_v4_unit_tangents : Computes the unit tangent vectors for vertices with valence 4.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_v4_unit_normal(self, diag=False, rregular=True):\n    \"\"\"\n    Computes the unit normal vectors for vertices with valence 4.\n\n    This function calculates the unit normal vectors for vertices with valence 4, \n    optionally considering diagonal edges and regular vertices.\n\n    Parameters\n    ----------\n    diag : bool, optional (default=False)\n        Whether to consider diagonal edges.\n    rregular : bool, optional (default=True)\n        Whether to consider regular vertices.\n\n    Returns\n    -------\n    v : numpy array\n        The indices of vertices.\n    anchor : numpy array\n        The anchor points for the normal vectors.\n    unit_normal : numpy array\n        The unit normal vectors.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The unit normal vectors are useful for mesh analysis and processing.\n\n    See Also\n    --------\n    get_v4_unit_tangents : Computes the unit tangent vectors for vertices with valence 4.\n    \"\"\"\n    v = self.ver_rrv4f4\n    if diag:\n        _,_,t1,t2,an,_ = self.get_v4_diag_unit_tangents()\n    else:\n        _,_,t1,t2,an,_ = self.get_v4_unit_tangents(rregular=rregular)\n    n = np.cross(t1,t2)\n    un = n / np.linalg.norm(n,axis=1)[:,None]\n    return v,an, un\n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_v4_unit_tangents","title":"<code>get_v4_unit_tangents(self, plot=False, rregular=True)</code>","text":"<p>Computes the unit tangent vectors for vertices with valence 4.</p> <p>This function calculates the unit tangent vectors for vertices with valence 4,  optionally plotting the results and considering regular vertices.</p> <p>Parameters:</p> Name Type Description Default <code>plot</code> <code>(bool, optional(default=False))</code> <p>Whether to plot the tangent vectors.</p> <code>False</code> <code>rregular</code> <code>(bool, optional(default=True))</code> <p>Whether to consider regular vertices.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>lt1, lt2 : numpy array</code> <p>The lengths of the tangent vectors.</p> <code>ut1, ut2 : numpy array</code> <p>The unit tangent vectors.</p> <code>anchor</code> <code>numpy array</code> <p>The anchor points for the tangent vectors.</p> <code>angle</code> <code>numpy array</code> <p>The angles between the tangent vectors.</p> Note <p>This function assumes that the mesh is a regular mesh. The unit tangent vectors are useful for mesh analysis and processing.</p> <p>(only for vertices of valence 4, not depends on X)</p> See Also <p>get_v4_unit_edge : Computes the unit edge vectors for vertices with valence 4.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_v4_unit_tangents(self, plot=False, rregular=True):\n    \"\"\"\n    Computes the unit tangent vectors for vertices with valence 4.\n\n    This function calculates the unit tangent vectors for vertices with valence 4, \n    optionally plotting the results and considering regular vertices.\n\n    Parameters\n    ----------\n    plot : bool, optional (default=False)\n        Whether to plot the tangent vectors.\n    rregular : bool, optional (default=True)\n        Whether to consider regular vertices.\n\n    Returns\n    -------\n    lt1, lt2 : numpy array\n        The lengths of the tangent vectors.\n    ut1, ut2 : numpy array\n        The unit tangent vectors.\n    anchor : numpy array\n        The anchor points for the tangent vectors.\n    angle : numpy array\n        The angles between the tangent vectors.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The unit tangent vectors are useful for mesh analysis and processing.\n\n    (only for vertices of valence 4, not depends on X)\n\n    See Also\n    --------\n    get_v4_unit_edge : Computes the unit edge vectors for vertices with valence 4.\n    \"\"\"\n    v,l1,l2,l3,l4,e1,e2,e3,e4 = self.get_v4_unit_edge(rregular)\n    #v = self.ver_star_matrix[:,0]\n    anchor = self.vertices[v]\n    t1 = (e1-e3)\n    t2 = (e2-e4)\n    lt1 = np.linalg.norm(t1,axis=1)\n    lt2 = np.linalg.norm(t2,axis=1)\n    ut1 = t1 / lt1[:,None]\n    ut2 = t2 / lt2[:,None]\n    angle = np.arccos(np.einsum('ij,ij-&gt;i', ut1, ut2))*180/np.pi\n    if plot:\n        a,b = (l1+l3)/5.0, (l2+l4)/5.0\n        Vl,Vr = anchor+ut1*a[:,None], anchor-ut1*a[:,None]\n        pl1 = make_polyline_from_endpoints(Vl,Vr)\n        Vl,Vr = anchor+ut2*b[:,None], anchor-ut2*b[:,None] \n        pl2 = make_polyline_from_endpoints(Vl,Vr)\n        return pl1,pl2\n    return lt1,lt2,ut1,ut2,anchor,angle\n</code></pre>"},{"location":"functions/quadrings/#quadrings.get_v4_unit_normal","title":"<code>get_v4_unit_normal(self, diag=False, rregular=True)</code>","text":"<p>Computes the unit normal vectors for vertices with valence 4.</p> <p>This function calculates the unit normal vectors for vertices with valence 4,  optionally considering diagonal edges and regular vertices.</p> <p>Parameters:</p> Name Type Description Default <code>diag</code> <code>(bool, optional(default=False))</code> <p>Whether to consider diagonal edges.</p> <code>False</code> <code>rregular</code> <code>(bool, optional(default=True))</code> <p>Whether to consider regular vertices.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>v</code> <code>numpy array</code> <p>The indices of vertices.</p> <code>anchor</code> <code>numpy array</code> <p>The anchor points for the normal vectors.</p> <code>unit_normal</code> <code>numpy array</code> <p>The unit normal vectors.</p> Note <p>This function assumes that the mesh is a regular mesh. The unit normal vectors are useful for mesh analysis and processing.</p> See Also <p>get_v4_unit_tangents : Computes the unit tangent vectors for vertices with valence 4.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def get_v4_unit_normal(self, diag=False, rregular=True):\n    \"\"\"\n    Computes the unit normal vectors for vertices with valence 4.\n\n    This function calculates the unit normal vectors for vertices with valence 4, \n    optionally considering diagonal edges and regular vertices.\n\n    Parameters\n    ----------\n    diag : bool, optional (default=False)\n        Whether to consider diagonal edges.\n    rregular : bool, optional (default=True)\n        Whether to consider regular vertices.\n\n    Returns\n    -------\n    v : numpy array\n        The indices of vertices.\n    anchor : numpy array\n        The anchor points for the normal vectors.\n    unit_normal : numpy array\n        The unit normal vectors.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The unit normal vectors are useful for mesh analysis and processing.\n\n    See Also\n    --------\n    get_v4_unit_tangents : Computes the unit tangent vectors for vertices with valence 4.\n    \"\"\"\n    v = self.ver_rrv4f4\n    if diag:\n        _,_,t1,t2,an,_ = self.get_v4_diag_unit_tangents()\n    else:\n        _,_,t1,t2,an,_ = self.get_v4_unit_tangents(rregular=rregular)\n    n = np.cross(t1,t2)\n    un = n / np.linalg.norm(n,axis=1)[:,None]\n    return v,an, un\n</code></pre>"},{"location":"functions/quadrings/#quadrings.Get_Diagonals_of_Multinets","title":"<code>Get_Diagonals_of_Multinets(self)</code>","text":"<p>Retrieves the diagonals of multinets in the mesh.</p> <p>This function identifies and returns the diagonals of multinets in the mesh.  It computes the diagonals based on the inner twin half-edges.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>pl1</code> <code>Polyline object</code> <p>The first set of diagonal polylines.</p> <code>pl2</code> <code>Polyline object</code> <p>The second set of diagonal polylines.</p> Note <p>This function assumes that the mesh is a regular mesh. The diagonals of multinets are useful for mesh analysis and processing.</p> See Also <p>Get_Inner_TwinsHalfedge_Index : Retrieves the indices of inner twin half-edges.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def Get_Diagonals_of_Multinets(self):\n    \"\"\"\n    Retrieves the diagonals of multinets in the mesh.\n\n    This function identifies and returns the diagonals of multinets in the mesh. \n    It computes the diagonals based on the inner twin half-edges.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    pl1 : Polyline object\n        The first set of diagonal polylines.\n    pl2 : Polyline object\n        The second set of diagonal polylines.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The diagonals of multinets are useful for mesh analysis and processing.\n\n    See Also\n    --------\n    Get_Inner_TwinsHalfedge_Index : Retrieves the indices of inner twin half-edges.\n    \"\"\"\n    H=self.halfedges  \n    number_of_halfedges = len(H[:,0])\n    V=self.vertices\n    Bool_List = self.Bool_SequenceNumber\n    Halfedge_1_NextNext = np.array([[0,0,0]])\n    Halfedge_1_Prev = np.array([[0,0,0]])\n    Halfedge_2_NextNext = np.array([[0,0,0]])\n    Halfedge_2_Prev = np.array([[0,0,0]])\n    # a=V[[H[H[H[1,2],2],0]]]\n    # print(a)\n    for i in range(number_of_halfedges) :\n        if Bool_List[i] == 1:\n            Halfedge_1_NextNext = np.r_[Halfedge_1_NextNext,V[[H[H[H[i,2],2],0]]]]\n            Halfedge_1_Prev = np.r_[Halfedge_1_Prev,V[[H[H[i,3],0]]]]\n            Halfedge_2_NextNext = np.r_[Halfedge_2_NextNext,V[[H[H[H[H[i,4],2],2],0]]]]\n            Halfedge_2_Prev = np.r_[Halfedge_2_Prev,V[[H[H[H[i,4],3],0]]]]\n    Halfedge_1_NextNext = np.delete(Halfedge_1_NextNext,0,axis=0)\n    Halfedge_1_Prev = np.delete(Halfedge_1_Prev,0,axis=0)\n    Halfedge_2_NextNext = np.delete(Halfedge_2_NextNext,0,axis=0)\n    Halfedge_2_Prev = np.delete(Halfedge_2_Prev,0,axis=0)\n    pl1 = make_polyline_from_endpoints(Halfedge_1_NextNext,Halfedge_2_NextNext)\n    pl2 = make_polyline_from_endpoints(Halfedge_1_Prev,Halfedge_2_Prev)\n    return pl1,pl2\n</code></pre>"},{"location":"functions/quadrings/#quadrings.Get_Inner_TwinsHalfedge_Index","title":"<code>Get_Inner_TwinsHalfedge_Index(self)</code>","text":"<p>Retrieves the indices of inner twin half-edges.</p> <p>This function identifies and returns the indices of inner twin half-edges  in the mesh.</p> <p>goal: find the inner twins halfedges indexes (unrepeatable)</p> <p>method:</p> <ol> <li> <p>give the sequence number of all halfedges;</p> </li> <li> <p>delete the boundary twin halfedges;</p> </li> <li> <p>delete the inner repeated sequence number</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>indices</code> <code>numpy array</code> <p>The indices of inner twin half-edges.</p> Note <p>This function assumes that the mesh is a regular mesh. The inner twin half-edges are useful for mesh analysis and processing.</p> See Also <p>Get_Diagonals_of_Multinets : Retrieves the diagonals of multinets.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def Get_Inner_TwinsHalfedge_Index(self):\n    \"\"\"\n    Retrieves the indices of inner twin half-edges.\n\n    This function identifies and returns the indices of inner twin half-edges \n    in the mesh.\n\n    goal: find the inner twins halfedges indexes (unrepeatable)\n\n    method:\n\n    1. give the sequence number of all halfedges;\n\n    2. delete the boundary twin halfedges;\n\n    3. delete the inner repeated sequence number\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    indices : numpy array\n        The indices of inner twin half-edges.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The inner twin half-edges are useful for mesh analysis and processing.\n\n\n    See Also\n    --------\n    Get_Diagonals_of_Multinets : Retrieves the diagonals of multinets.\n    \"\"\"\n    H=self.halfedges  \n    number_of_halfedges = len(H[:,0])\n    Boundary_SequenceNumber = []\n    Boundary_Twin_SequenceNumber = []\n    Inner_Repeated_SequenceNumber =[]\n    Bool_SequenceNumber = np.ones(number_of_halfedges)\n    SequenceNumber = list(range(0,number_of_halfedges))   \n    _,_, valence = self.vertex_ring_vertices_iterators(return_lengths=True)\n\n    for i in SequenceNumber :\n        if H[i,1] == -1:\n            Boundary_SequenceNumber.append(i)\n            Bool_SequenceNumber[i] = 0\n        if H[i,4] &lt; i:\n            Inner_Repeated_SequenceNumber.append(i)\n            Bool_SequenceNumber[i] = 0           \n\n    for i in Boundary_SequenceNumber :\n        n = H[i,4]\n        Boundary_Twin_SequenceNumber.append(n)\n        Bool_SequenceNumber[n] = 0\n\n    for i in SequenceNumber :\n        if H[H[H[i,2],4],1]!=-1 and H[H[H[H[i,2],2],4],1]!=-1 and valence[H[i,0]] != 4 :\n            Bool_SequenceNumber[i] = 0\n        if H[H[H[i,2],4],1]!=-1 and H[H[H[H[i,2],2],4],1]!=-1 and valence[H[H[i,2],0]] != 4 :\n            Bool_SequenceNumber[i] = 0\n        if H[H[H[i,2],4],1]!=-1 and H[H[H[H[i,2],2],4],1]!=-1 and valence[H[H[H[i,2],2],0]] != 4 :\n            Bool_SequenceNumber[i] = 0\n        if H[H[H[i,2],4],1]!=-1 and H[H[H[H[i,2],2],4],1]!=-1 and valence[H[H[i,3],0]] != 4 :\n            Bool_SequenceNumber[i] = 0\n\n    self._Bool_SequenceNumber = Bool_SequenceNumber\n</code></pre>"},{"location":"functions/quadrings/#quadrings.index_of_4quad_face_order_at_regular_vs","title":"<code>index_of_4quad_face_order_at_regular_vs(self)</code>","text":"<p>Retrieves the indices of quad faces adjacent to regular vertices.</p> <p>This function identifies the quad faces adjacent to each regular vertex  and returns their indices in the quad face list.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>indices</code> <code>numpy array</code> <p>Indices of quad faces adjacent to each regular vertex.</p> Note <p>This function assumes that the mesh is a regular mesh. The indices are useful for accessing specific quad faces in the mesh.</p> <p>most strong regular case: regular vertex &amp; regular quads;  star = self.rr_star star = star[self.ind_rr_star_v4f4] if1,if2,if3,if4 = self.ind_rr_quadface_order.T</p> See Also <p>regular_vertex_regular_quad : Identifies regular vertices and quad faces.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def index_of_4quad_face_order_at_regular_vs(self):\n    \"\"\"\n    Retrieves the indices of quad faces adjacent to regular vertices.\n\n    This function identifies the quad faces adjacent to each regular vertex \n    and returns their indices in the quad face list.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    indices : numpy array\n        Indices of quad faces adjacent to each regular vertex.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The indices are useful for accessing specific quad faces in the mesh.\n\n    most strong regular case: regular vertex &amp; regular quads; \n    star = self.rr_star\n    star = star[self.ind_rr_star_v4f4]\n    if1,if2,if3,if4 = self.ind_rr_quadface_order.T\n\n    See Also\n    --------\n    regular_vertex_regular_quad : Identifies regular vertices and quad faces.\n    \"\"\"\n    H = self.halfedges\n    star = self.rr_star#[self.ind_rr_star_v4f4] ##NOTE: NEED TO CHECK IF [self.ind_rr_star_v4f4]\n    forder = self.rr_quadface_order\n    flist = []\n    ind = []\n    for i in range(len(star)):\n        v,v1,v2,v3,v4 = star[i,:]\n        e=np.where(H[:,0]==v)[0]\n        e1=np.where(H[H[:,4],0]==v1)[0]\n        e2=np.where(H[H[:,4],0]==v2)[0]\n        e3=np.where(H[H[:,4],0]==v3)[0]\n        e4=np.where(H[H[:,4],0]==v4)[0]\n        i1 = np.intersect1d(e,e1)\n        i2 = np.intersect1d(e,e2)\n        i3 = np.intersect1d(e,e3)\n        i4 = np.intersect1d(e,e4)\n        f1,f2,f3,f4 = H[i1,1],H[i2,1],H[i3,1],H[i4,1]\n        if f1!=-1 and f2!=-1 and f3!=-1 and f4!=-1:\n            \"for v whose faces are not 4, de-select it\"\n            if1 = np.where(forder==f1)[0]\n            if2 = np.where(forder==f2)[0]\n            if3 = np.where(forder==f3)[0]\n            if4 = np.where(forder==f4)[0]\n            if len(if1)!=0 and len(if2)!=0 and len(if3)!=0 and len(if4)!=0:\n                \"for face who does belong to forder\"\n                ind.append(i)\n                flist.append([if1[0],if2[0],if3[0],if4[0]])\n    self._ind_rr_star_v4f4 = np.array(ind) # ind_rr_star_v4f4\n    self._ind_rr_quadface_order = np.array(flist) \n</code></pre>"},{"location":"functions/quadrings/#quadrings.index_of_rrquad_face_vertex_with_rrv","title":"<code>index_of_rrquad_face_vertex_with_rrv(self)</code>","text":"<p>Retrieves the indices of vertices in regular quad faces that are also regular vertices.</p> <p>This function identifies the vertices in regular quad faces that are also  regular vertices and returns their indices.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>indices</code> <code>numpy array</code> <p>The indices of vertices in regular quad faces that are also regular vertices.</p> Note <p>This function assumes that the mesh is a regular mesh. The indices are useful for accessing specific vertices in the mesh. self.rr_quadface() may include vertices that are not in rr_star; this one works</p> See Also <p>regular_vertex_regular_quad : Identifies regular vertices and quad faces.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def index_of_rrquad_face_vertex_with_rrv(self):\n    \"\"\"\n    Retrieves the indices of vertices in regular quad faces that are also regular vertices.\n\n    This function identifies the vertices in regular quad faces that are also \n    regular vertices and returns their indices.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    indices : numpy array\n        The indices of vertices in regular quad faces that are also regular vertices.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The indices are useful for accessing specific vertices in the mesh.\n    self.rr_quadface() may include vertices that are not in rr_star; this one works\n\n    See Also\n    --------\n    regular_vertex_regular_quad : Identifies regular vertices and quad faces.\n    \"\"\"\n    v1,v2,v3,v4  = self.rr_quadface.T\n    rrv = self.ver_rrv4f4\n    ind = []\n    for i in range(len(v1)):\n        if v1[i] in rrv and v2[i] in rrv and v3[i] in rrv and v4[i] in rrv:\n            ind.append(i)\n    self._ind_rr_quadface_with_rrv = np.array(ind)\n</code></pre>"},{"location":"functions/quadrings/#quadrings.make_quad_mesh_from_indices","title":"<code>make_quad_mesh_from_indices(self, V, v1, v2, v3, v4)</code>","text":"<p>Creates a quad mesh from the given vertex indices.</p> <p>This function constructs a quad mesh using the specified vertex indices and  their corresponding positions.</p> <p>Parameters:</p> Name Type Description Default <code>V</code> <code>numpy array</code> <p>The vertex positions.</p> required <code>v1</code> <code>numpy array</code> <p>The indices of vertices forming the quad faces.</p> required <code>v2</code> <code>numpy array</code> <p>The indices of vertices forming the quad faces.</p> required <code>v3</code> <code>numpy array</code> <p>The indices of vertices forming the quad faces.</p> required <code>v4</code> <code>numpy array</code> <p>The indices of vertices forming the quad faces.</p> required <p>Returns:</p> Name Type Description <code>quad_mesh</code> <code>Mesh object</code> <p>The constructed quad mesh.</p> Note <p>This function assumes that the input indices form valid quad faces. The resulting quad mesh is useful for further analysis and processing.</p> See Also <p>get_diagonal_mesh : Creates a diagonal mesh from the current mesh.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def make_quad_mesh_from_indices(self, V, v1, v2, v3, v4):\n    \"\"\"\n    Creates a quad mesh from the given vertex indices.\n\n    This function constructs a quad mesh using the specified vertex indices and \n    their corresponding positions.\n\n    Parameters\n    ----------\n    V : numpy array\n        The vertex positions.\n    v1, v2, v3, v4 : numpy array\n        The indices of vertices forming the quad faces.\n\n    Returns\n    -------\n    quad_mesh : Mesh object\n        The constructed quad mesh.\n\n    Note\n    ----\n    This function assumes that the input indices form valid quad faces.\n    The resulting quad mesh is useful for further analysis and processing.\n\n    See Also\n    --------\n    get_diagonal_mesh : Creates a diagonal mesh from the current mesh.\n    \"\"\"\n    vrr = np.unique(np.r_[v1,v2,v3,v4])\n    numf = len(v1)\n    vlist = V[vrr]\n    farr = np.array([],dtype=int)\n    for i in range(numf):\n        i1 = np.where(vrr==v1[i])[0]\n        i2 = np.where(vrr==v2[i])[0]\n        i3 = np.where(vrr==v3[i])[0]\n        i4 = np.where(vrr==v4[i])[0]\n        farr = np.r_[farr,i1,i2,i3,i4]\n    flist = farr.reshape(-1,4).tolist()\n    ck = Mesh()\n    ck.make_mesh(vlist,flist)\n    return ck\n</code></pre>"},{"location":"functions/quadrings/#quadrings.nonsingular","title":"<code>nonsingular(self)</code>","text":"<p>Identifies non-singular vertices in the mesh.</p> <p>This function detects vertices with valence 4 (non-singular) and stores  their indices.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The non-singular vertices are stored within the class instance.</p> Note <p>This function assumes that the mesh is a regular mesh. Non-singular vertices are useful for mesh analysis and processing. nonsingular(=regular) vertices v in increased order</p> See Also <p>nonsingular_star_matrix : Creates a star matrix for non-singular vertices.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def nonsingular(self):\n    \"\"\"\n    Identifies non-singular vertices in the mesh.\n\n    This function detects vertices with valence 4 (non-singular) and stores \n    their indices.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    None\n        The non-singular vertices are stored within the class instance.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    Non-singular vertices are useful for mesh analysis and processing.\n    nonsingular(=regular) vertices v in increased order\n\n    See Also\n    --------\n    nonsingular_star_matrix : Creates a star matrix for non-singular vertices.\n    \"\"\"\n    self._vi,self._vj,lj = self.vertex_ring_vertices_iterators(sort=True,return_lengths=True)\n    order = np.where(lj==4)[0]\n    self._ver_regular = order\n    self._num_regular = len(order)\n    self._corner = np.where(lj==2)[0]\n    self._inner = np.setdiff1d(np.arange(self.V),self.boundary_vertices())\n</code></pre>"},{"location":"functions/quadrings/#quadrings.nonsingular_star_matrix","title":"<code>nonsingular_star_matrix(self)</code>","text":"<p>Creates a star matrix for non-singular vertices.</p> <p>This function constructs a matrix representing the connectivity of  non-singular vertices, where each row corresponds to a vertex and its  neighboring vertices.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>star_matrix</code> <code>numpy array</code> <p>The star matrix for non-singular vertices.</p> Note <p>This function assumes that the mesh is a regular mesh. The star matrix is useful for organizing and accessing mesh vertices.</p> See Also <p>nonsingular : Identifies non-singular vertices in the mesh.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def nonsingular_star_matrix(self):\n    \"\"\"\n    Creates a star matrix for non-singular vertices.\n\n    This function constructs a matrix representing the connectivity of \n    non-singular vertices, where each row corresponds to a vertex and its \n    neighboring vertices.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    star_matrix : numpy array\n        The star matrix for non-singular vertices.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The star matrix is useful for organizing and accessing mesh vertices.\n\n    See Also\n    --------\n    nonsingular : Identifies non-singular vertices in the mesh.\n    \"\"\"\n    order = self.ver_regular\n    ring = [[] for i in range(len(order))]\n    for i in range(len(order)):\n        v = order[i]\n        ring[i]= self.ringlist[v]\n    star = np.c_[order.T,ring]\n    return star\n</code></pre>"},{"location":"functions/quadrings/#quadrings.new_vertex_normals","title":"<code>new_vertex_normals(self, is_orient_to_spherecenter=True, is_rrv4f4=True)</code>","text":"<p>Computes the vertex normals of the mesh.</p> <p>This function calculates the vertex normals and optionally orients them  towards the sphere center.</p> <p>Parameters:</p> Name Type Description Default <code>is_orient_to_spherecenter</code> <code>(bool, optional(default=True))</code> <p>Whether to orient the normals towards the sphere center.</p> <code>True</code> <code>is_rrv4f4</code> <code>(bool, optional(default=True))</code> <p>Whether to use the regular vertices and quad faces.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>normals</code> <code>numpy array</code> <p>The vertex normals of the mesh.</p> Note <p>This function assumes that the mesh is a regular mesh. The vertex normals are useful for mesh analysis and processing. It makes vertex_normals orient non-convex direction</p> See Also <p>vertex_normals : Computes the vertex normals of the mesh.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def new_vertex_normals(self, is_orient_to_spherecenter=True, is_rrv4f4=True):\n    \"\"\"\n    Computes the vertex normals of the mesh.\n\n    This function calculates the vertex normals and optionally orients them \n    towards the sphere center.\n\n    Parameters\n    ----------\n    is_orient_to_spherecenter : bool, optional (default=True)\n        Whether to orient the normals towards the sphere center.\n    is_rrv4f4 : bool, optional (default=True)\n        Whether to use the regular vertices and quad faces.\n\n    Returns\n    -------\n    normals : numpy array\n        The vertex normals of the mesh.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The vertex normals are useful for mesh analysis and processing.\n    It makes vertex_normals orient non-convex direction\n\n    See Also\n    --------\n    vertex_normals : Computes the vertex normals of the mesh.\n    \"\"\"\n    v0,v1,v2,v3,v4 = self.rrv4f4 #(self.rr_star).T\n    V = self.vertices\n    VN = np.copy(self.vertex_normals())\n\n    orientrn = self.get_v4_orient_unit_normal(rregular=is_rrv4f4)[1]\n    id0 = np.where(np.einsum('ij,ij-&gt;i', orientrn, VN[v0]) &lt; 0)[0]\n    if len(id0)!=0:\n        orientrn[id0] = -orientrn[id0]\n    VN[v0] = orientrn\n\n    if is_orient_to_spherecenter:\n        S0,S1,S2,S3,S4 = V[v0],V[v1],V[v2],V[v3],V[v4]\n        _,radius,coeff,Nv4 = interpolate_sphere(S0,S1,S2,S3,S4)#Nv4 is from vertex to center\n        id1 = np.where(np.einsum('ij,ij-&gt;i', VN[v0], Nv4) &lt; 0)[0] \n        if len(id1)&gt;int(len(v0)/2-1):\n            orientn = -VN\n        else:\n            orientn = VN\n    else:\n        Ns = self.vertex_normals()[v0]\n        uE1 = (V[v1]-V[v0]) / np.linalg.norm(V[v1]-V[v0],axis=1)[:,None]\n        uE2 = (V[v2]-V[v0]) / np.linalg.norm(V[v2]-V[v0],axis=1)[:,None]\n        uE3 = (V[v3]-V[v0]) / np.linalg.norm(V[v3]-V[v0],axis=1)[:,None]\n        uE4 = (V[v4]-V[v0]) / np.linalg.norm(V[v4]-V[v0],axis=1)[:,None]\n        N1, N2 = uE1 + uE3, uE2 + uE4\n        id1 = np.where(np.einsum('ij,ij-&gt;i', Ns, N1) &lt; 0)[0] # non-convex direction\n        id2 = np.where(np.einsum('ij,ij-&gt;i', Ns, N2) &lt; 0)[0] # non-convex direction\n        number = max(len(id1),len(id2))\n        if number &gt; len(v0)-len(id1)-len(id2):\n            orientn = self.vertex_normals()\n        else:\n            orientn = -self.vertex_normals()\n\n    if is_rrv4f4:\n        return orientn[v0]\n    else:\n        return orientn\n</code></pre>"},{"location":"functions/quadrings/#quadrings.orient","title":"<code>orient(self, S0, A, B, C, D, Nv4)</code>","text":"<p>Orients the mesh based on the given parameters.</p> <p>This function adjusts the orientation of the mesh by modifying the  vertex normals and related parameters.</p> <p>Parameters:</p> Name Type Description Default <code>S0</code> <code>numpy array</code> <p>The center point of the mesh.</p> required <code>A</code> <code>numpy array</code> <p>The first parameter for orientation.</p> required <code>B</code> <code>numpy array</code> <p>The second parameter for orientation.</p> required <code>C</code> <code>numpy array</code> <p>The third parameter for orientation.</p> required <code>D</code> <code>numpy array</code> <p>The fourth parameter for orientation.</p> required <code>Nv4</code> <code>numpy array</code> <p>The normal vectors of the mesh.</p> required <p>Returns:</p> Name Type Description <code>B</code> <code>numpy array</code> <p>The modified second parameter.</p> <code>C</code> <code>numpy array</code> <p>The modified third parameter.</p> <code>D</code> <code>numpy array</code> <p>The modified fourth parameter.</p> <code>Nv4</code> <code>numpy array</code> <p>The modified normal vectors.</p> <code>x_orient</code> <code>numpy array</code> <p>The orientation factor.</p> Note <p>This function assumes that the mesh is a regular mesh. The orientation is useful for mesh analysis and processing.</p> See Also <p>new_vertex_normals : Computes the vertex normals of the mesh.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def orient(self, S0, A, B, C, D, Nv4):\n    \"\"\"\n    Orients the mesh based on the given parameters.\n\n    This function adjusts the orientation of the mesh by modifying the \n    vertex normals and related parameters.\n\n    Parameters\n    ----------\n    S0 : numpy array\n        The center point of the mesh.\n    A : numpy array\n        The first parameter for orientation.\n    B : numpy array\n        The second parameter for orientation.\n    C : numpy array\n        The third parameter for orientation.\n    D : numpy array\n        The fourth parameter for orientation.\n    Nv4 : numpy array\n        The normal vectors of the mesh.\n\n    Returns\n    -------\n    B : numpy array\n        The modified second parameter.\n    C : numpy array\n        The modified third parameter.\n    D : numpy array\n        The modified fourth parameter.\n    Nv4 : numpy array\n        The modified normal vectors.\n    x_orient : numpy array\n        The orientation factor.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The orientation is useful for mesh analysis and processing.\n\n    See Also\n    --------\n    new_vertex_normals : Computes the vertex normals of the mesh.\n    \"\"\"\n    orientrn = self.new_vertex_normals()\n    ##print(Nv4.shape, orientrn.shape)\n\n    ind1 = np.where(np.einsum('ij,ij-&gt;i',orientrn,Nv4) &lt; 0)[0]\n    if len(ind1)!=0:\n        Nv4[ind1] = -Nv4[ind1]\n        \"new_c = v[ind1]+r[ind1]*n[ind1], --&gt; (b,c,d)[ind1] = -2*a*(v+rn)[ind1]\"\n        x,y,z = S0.T\n        bb = -4*A*x-B\n        cc = -4*A*y-C\n        dd = -4*A*z-D\n        B[ind1] = bb[ind1]\n        C[ind1] = cc[ind1]\n        D[ind1] = dd[ind1]\n\n    x_orient = np.sqrt(np.abs(np.einsum('ij,ij-&gt;i',Nv4,orientrn)))        \n    return B,C,D,Nv4,x_orient\n</code></pre>"},{"location":"functions/quadrings/#quadrings.quadfaces","title":"<code>quadfaces(self)</code>","text":"<p>Identifies quad faces in the mesh.</p> <p>This function detects quad faces and stores their indices and connectivity.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The quad faces are stored within the class instance.</p> Note <p>This function assumes that the mesh is a regular mesh. Quad faces are useful for mesh analysis and processing.</p> See Also <p>regular_vertex_regular_quad : Identifies regular vertices and quad faces.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def quadfaces(self):\n    \"\"\"\n    Identifies quad faces in the mesh.\n\n    This function detects quad faces and stores their indices and connectivity.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    None\n        The quad faces are stored within the class instance.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    Quad faces are useful for mesh analysis and processing.\n\n    See Also\n    --------\n    regular_vertex_regular_quad : Identifies regular vertices and quad faces.\n    \"\"\"\n    f, v1, v2 = self.face_edge_vertices_iterators(order=True)\n    f4,vi = [],[]\n    for i in range(self.F):\n        ind = np.where(f==i)[0]\n        if len(ind)==4:\n            f4.extend([i,i,i,i])\n            vi.extend(v1[ind])\n            #vj.extend(v2[ind])\n    self._num_quadface = len(f4) // 4\n    #v1,v2,v3,v4 = vi[::4],vi[1::4],vi[2::4],vi[3::4]\n    self._quadface = np.array(vi,dtype=int)\n    self._quadface_order = np.unique(f4)\n</code></pre>"},{"location":"functions/quadrings/#quadrings.regular_rectangle_patch","title":"<code>regular_rectangle_patch(self)</code>","text":"<p>Creates a patch matrix for a regular rectangular mesh.</p> <p>This function constructs a matrix representing the connectivity of a regular  rectangular mesh, where each entry corresponds to a vertex index.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The patch matrix is stored within the class instance.</p> Note <p>This function assumes that the mesh is a regular rectangular patch. The patch matrix is useful for organizing and accessing mesh vertices.</p> See Also <p>regular_rotational_patch : Creates a patch matrix for a rotational mesh.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def regular_rectangle_patch(self):\n    \"\"\"\n    Creates a patch matrix for a regular rectangular mesh.\n\n    This function constructs a matrix representing the connectivity of a regular \n    rectangular mesh, where each entry corresponds to a vertex index.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    None\n        The patch matrix is stored within the class instance.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular rectangular patch.\n    The patch matrix is useful for organizing and accessing mesh vertices.\n\n    See Also\n    --------\n    regular_rotational_patch : Creates a patch matrix for a rotational mesh.\n    \"\"\"\n    H = self.halfedges\n    b = np.where(H[:,1]==-1)[0]\n    c = np.where(H[H[H[H[b,4],3],4],1]==-1)[0]\n    corner = H[H[b[c],2],0]\n    e0 = b[c[0]] # choose the first corner-edge\n    def row(e): # vertices' index --- up--down\n        row = []\n        while H[e,0] not in corner:\n            row.append(e)\n            e = H[e,3]\n        row.append(e)\n        return row\n\n    def column(e): # vertices' index --- left--right\n        col = H[e,0]\n        ecol = [e]\n        e = H[H[H[e,4],2],2]\n        while H[e,4] not in b:\n            col = np.r_[col,H[e,0]]\n            ecol.append(e)\n            e = H[H[H[e,4],2],2]\n        col = np.r_[col,H[e,0]]\n        ecol.append(e)\n        return col,ecol\n\n    left = row(e0)\n    v1,e1 = column(e0)\n    v0 = H[H[e1,4],0]\n    for e in left:  \n        vi,_ = column(e)\n        v0 = np.c_[v0,vi]\n\n    v,v1,v2,v3,v4 = self.ver_star_matrix[0,:]\n    if np.where(v0==v)[1] != np.where(v0==v1)[1]:\n        self._patch_matrix = v0.T\n    else:\n        \"v1,v,v3 from up to down; v2,v,v4 from left to right\"\n        self._patch_matrix = v0 \n</code></pre>"},{"location":"functions/quadrings/#quadrings.regular_rotational_patch","title":"<code>regular_rotational_patch(self)</code>","text":"<p>Creates a patch matrix for a regular rotational mesh.</p> <p>This function constructs a matrix representing the connectivity of a regular  rotational mesh, where each entry corresponds to a vertex index.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The patch matrix is stored within the class instance.</p> Note <p>This function assumes that the mesh is a regular rotational patch. The patch matrix is useful for organizing and accessing mesh vertices.</p> See Also <p>regular_rectangle_patch : Creates a patch matrix for a rectangular mesh.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def regular_rotational_patch(self):\n    \"\"\"\n    Creates a patch matrix for a regular rotational mesh.\n\n    This function constructs a matrix representing the connectivity of a regular \n    rotational mesh, where each entry corresponds to a vertex index.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    None\n        The patch matrix is stored within the class instance.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular rotational patch.\n    The patch matrix is useful for organizing and accessing mesh vertices.\n\n    See Also\n    --------\n    regular_rectangle_patch : Creates a patch matrix for a rectangular mesh.\n    \"\"\"\n    H = self.halfedges\n    eb1 = np.where(H[:,1]==-1)[0][0]\n    erow1 = [eb1] # index for edges\n    eb = eb1\n    while H[H[eb,2],0] != H[eb1,0]:\n        eb = H[eb,2]\n        erow1.append(eb)\n    erow1.append(H[eb,2]) # last should be equal to the first\n    vm = np.array([],dtype=int)\n    for e in erow1:\n        eci = [e] # index for edge\n        while H[H[e,4],1]!=-1:\n            e = H[H[H[e,4],2],2]\n            eci.append(e)\n        vm = np.r_[vm, H[eci,0]]\n    vM = (vm.reshape(len(erow1),len(eci))).T\n    self._rot_patch_matrix = vM \n</code></pre>"},{"location":"functions/quadrings/#quadrings.regular_vertex_regular_quad","title":"<code>regular_vertex_regular_quad(self, delete_multi=True)</code>","text":"<p>This function processes half-edge data structures to identify and organize  regular vertices and regular quadrilateral faces in a mesh. It returns  structured information about the regular vertices, regular quads, and their  connectivity.</p> <p>The function's main logic involves:</p> <ol> <li> <p>Iterating over each vertex to identify oriented quad faces using the half-edge structure.</p> </li> <li> <p>Handling boundary cases where quad faces may be incomplete or partially defined.</p> </li> <li> <p>Optionally deleting multiple faces that overlap, ensuring a unique representation of quad faces.</p> </li> <li> <p>Returning detailed information about regular vertices, regular quads, and their connectivity.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>halfedges</code> <code>numpy int array</code> <p>The half-edge data structure representing the mesh.  Each row corresponds to a half-edge with columns representing:  [origin vertex, twin half-edge, next half-edge, prev half-edge, face].</p> required <code>ver_star_matrix</code> <code>numpy int array</code> <p>A matrix where each row corresponds to a vertex and contains the indices of its neighboring vertices.</p> required <code>delete_multi</code> <code>bool, optional (default True)</code> <p>whether to deletes multiple overlapping faces to ensure unique quad faces or not.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>num_rrf</code> <code>int</code> <p>The number of regular quad faces.</p> <code>rr_quadface</code> <code>numpy int array</code> <p>The regular quad faces, each defined by four vertices.</p> <code>rr_quadface_order</code> <code>numpy int array</code> <p>The order of the quad faces.</p> <code>num_rrv</code> <code>int</code> <p>The number of regular vertices.</p> <code>rr_star</code> <code>numpy int array</code> <p>The star matrix for regular vertices.</p> <code>rr_4quad_vers</code> <code>list</code> <p>A list of all oriented quad faces, including boundary faces.</p> Note: <p>This function assumes the input mesh is manifold and orientable. It also assumes that the half-edge structure is correctly defined, with each half-edge pointing to its twin, next, and previous half-edges.</p> See Also: <p>quadfaces()</p> <p>Examples:</p> <pre><code>from quadrings import regular_vertex_regular_quad\nnum_rrf, rr_quadface, rr_quadface_order, num_rrv, rr_star, rr_4quad_vers = regular_vertex_regular_quad(halfedges, ver_star_matrix)\n</code></pre> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def regular_vertex_regular_quad(self,delete_multi=True):\n    \"\"\"\n    This function processes half-edge data structures to identify and organize \n    regular vertices and regular quadrilateral faces in a mesh. It returns \n    structured information about the regular vertices, regular quads, and their \n    connectivity.\n\n    The function's main logic involves:\n\n    1. Iterating over each vertex to identify oriented quad faces using the half-edge structure.\n\n    2. Handling boundary cases where quad faces may be incomplete or partially defined.\n\n    3. Optionally deleting multiple faces that overlap, ensuring a unique representation of quad faces.\n\n    4. Returning detailed information about regular vertices, regular quads, and their connectivity.\n\n    Parameters\n    ----------\n    halfedges : numpy int array\n        The half-edge data structure representing the mesh. \n        Each row corresponds to a half-edge with columns representing: \n        [origin vertex, twin half-edge, next half-edge, prev half-edge, face].\n    ver_star_matrix : numpy int array\n        A matrix where each row corresponds to a vertex and contains the indices of its neighboring vertices.\n    delete_multi : bool, optional (default True)\n        whether to deletes multiple overlapping faces to ensure unique quad faces or not.\n\n    Returns\n    -------\n    num_rrf : int\n        The number of regular quad faces.\n    rr_quadface : numpy int array\n        The regular quad faces, each defined by four vertices.\n    rr_quadface_order :  numpy int array\n        The order of the quad faces.\n    num_rrv : int\n        The number of regular vertices.\n    rr_star : numpy int array\n        The star matrix for regular vertices.\n    rr_4quad_vers : list\n        A list of all oriented quad faces, including boundary faces.\n\n\n    Note:\n    --------\n    This function assumes the input mesh is manifold and orientable. It also assumes that the half-edge structure is correctly defined, with each half-edge pointing to its twin, next, and previous half-edges.\n\n\n    See Also: \n    --------\n    quadfaces()\n\n\n    Examples\n    --------\n    ```python\n    from quadrings import regular_vertex_regular_quad\n    num_rrf, rr_quadface, rr_quadface_order, num_rrv, rr_star, rr_4quad_vers = regular_vertex_regular_quad(halfedges, ver_star_matrix)\n    ```\n    \"\"\"\n    H = self.halfedges\n    ##starM = np.array(orient_rings(self))\n    starM = self.ver_star_matrix\n    num = len(starM)\n    f4 = []\n    for i in range(num):\n        \"multiple oriented quad faces\"\n        v,v1,v2,v3,v4 = starM[i,:]\n        ei = np.where(H[:,0]==v)[0]\n        ej = H[H[H[H[ei,2],2],2],2]\n        e1 = ei[np.where(H[H[ei,4],0]==v1)[0]]\n        e2 = ei[np.where(H[H[ei,4],0]==v2)[0]]\n        e3 = ei[np.where(H[H[ei,4],0]==v3)[0]]\n        e4 = ei[np.where(H[H[ei,4],0]==v4)[0]]\n        if any(list(ej-ei)): # whose neighbor include not quad face\n            if H[e1,1]==-1 and H[H[e2,4],1]==-1:\n                f4.append([v2,v,v1,-1])\n                f4.append([H[H[H[e2,2],2],0][0],v3,v,v2])\n                f4.append([v3,H[H[H[e3,2],2],0][0],v4,v])\n                f4.append([v,v4,H[H[H[e4,2],2],0][0],v1])\n            elif H[e2,1]==-1 and H[H[e3,4],1]==-1:\n                f4.append([v2,v,v1,H[H[H[e1,2],2],0][0]])\n                f4.append([-1,v3,v,v2])\n                f4.append([v3,H[H[H[e3,2],2],0][0],v4,v])\n                f4.append([v,v4,H[H[H[e4,2],2],0][0],v1])\n            elif H[e3,1]==-1 and H[H[e4,4],1]==-1:\n                f4.append([v2,v,v1,H[H[H[e1,2],2],0][0]])\n                f4.append([H[H[H[e2,2],2],0][0],v3,v,v2])\n                f4.append([v3,-1,v4,v])\n                f4.append([v,v4,H[H[H[e4,2],2],0][0],v1])\n            elif H[e4,1]==-1 and H[H[e1,4],1]==-1:\n                f4.append([v2,v,v1,H[H[H[e1,2],2],0][0]])\n                f4.append([H[H[H[e2,2],2],0][0],v3,v,v2])\n                f4.append([v3,H[H[H[e3,2],2],0][0],v4,v])\n                f4.append([v,v4,-1,v1])\n        else:\n            if H[H[H[H[e1,2],2],2],0]==v2:\n                \"one quad face [v2,v,v1,x]\"\n                f4.append([v2,v,v1,H[H[H[e1,2],2],0][0]])\n            if H[H[H[H[e2,2],2],2],0]==v3:\n                \"one quad face [x,v3,v,v2]\"\n                f4.append([H[H[H[e2,2],2],0][0],v3,v,v2])\n            if H[H[H[H[e3,2],2],2],0]==v4:\n                \"one quad face [v3,x,v4,v]\"\n                f4.append([v3,H[H[H[e3,2],2],0][0],v4,v])\n            if H[H[H[H[e4,2],2],2],0]==v1:\n                \"one quad face [v,v4,x,v1]\"\n                f4.append([v,v4,H[H[H[e4,2],2],0][0],v1])\n\n\n    farr = np.unique(f4,axis=0)\n    a,b = np.where(farr==-1)\n    farr = np.delete(farr,a,axis=0)\n    forder=np.array([],dtype=int)\n    for f in farr:\n        e1=np.where(H[:,0]==f[0])[0]\n        e2=np.where(H[H[:,4],0]==f[1])[0]\n        e = np.intersect1d(e1,e2)\n        forder = np.r_[forder, H[e,1]]\n\n    f4list = np.array(f4)\n    if delete_multi: # delete multiple-left faces\n        #forder, ind = np.unique(forder,return_index=True) # changed order\n        ind=[]\n        multi=[]\n        for i in range(len(forder)):\n            f = forder[i]\n            if f not in forder[ind]:\n                ind.append(i)\n            else:\n                j = np.where(forder[ind]==f)[0][0]\n                k = forder[ind][j]\n                l = np.setdiff1d(np.where(forder==k)[0], np.array([i]))[0]\n                multi.append(list(farr[l]))\n        forder = forder[ind]\n        farr = farr[ind]\n        for f in multi:\n            index=np.array([],dtype=int)\n            e1,e2,e3,e4 = f\n            a,b,c = [e4,e1,e2,e3],[e3,e4,e1,e2],[e2,e3,e4,e1]\n            if a in f4:\n                ind,_ = np.where(f4list==a)\n                index = np.r_[index,ind]\n            if b in f4:\n                ind,_ = np.where(f4list==b)\n                index = np.r_[index,ind]\n            if c in f4:\n                ind,_ = np.where(f4list==c)\n                index = np.r_[index,ind]\n            f4list[index]=np.array(f)\n\n    self._num_rrf = len(farr)\n    self._rr_quadface = farr\n    self._rr_quadface_order = forder\n    #print(len(farr),len(f4list),num,len(index))\n    self._num_rrv = num # same with num_regular\n    #order = np.setdiff1d(np.arange(num),index//4)\n    self._rr_star = starM # same with starM\n    self._rr_4quad_vers = f4 #rr_4quad_vers\n</code></pre>"},{"location":"functions/quadrings/#quadrings.vertex_corner_neib","title":"<code>vertex_corner_neib(self)</code>","text":"<p>Retrieves the neighbors of corner vertices.</p> <p>This function identifies the neighbors of corner vertices and returns  their indices.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>left_neighbors</code> <code>numpy array</code> <p>Indices of the left neighbors.</p> <code>center_neighbors</code> <code>numpy array</code> <p>Indices of the center neighbors.</p> <code>right_neighbors</code> <code>numpy array</code> <p>Indices of the right neighbors.</p> Note <p>This function assumes that the mesh is a regular mesh. The neighbors are useful for mesh analysis and processing.</p> See Also <p>vertex_valence3_neib : Retrieves neighbors of vertices with valence 3.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def vertex_corner_neib(self):\n    \"\"\"\n    Retrieves the neighbors of corner vertices.\n\n    This function identifies the neighbors of corner vertices and returns \n    their indices.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    left_neighbors : numpy array\n        Indices of the left neighbors.\n    center_neighbors : numpy array\n        Indices of the center neighbors.\n    right_neighbors : numpy array\n        Indices of the right neighbors.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The neighbors are useful for mesh analysis and processing.\n\n    See Also\n    --------\n    vertex_valence3_neib : Retrieves neighbors of vertices with valence 3.\n    \"\"\"\n    H = self.halfedges\n    corner = self.corner\n    el = []\n    for i in range(len(corner)):\n        c = corner[i]\n        e = np.intersect1d(np.where(H[:,0]==c)[0],np.where(H[:,1]==-1)[0])[0]\n        el.append(e)\n    va,vb = H[H[el,2],0],H[H[H[el,2],2],0]\n    v1,v2 = H[H[el,3],0],H[H[H[el,3],3],0]\n    vl,vc,vr = np.r_[corner,corner],np.r_[va,v1],np.r_[vb,v2]\n    self._ver_corner_neib = [vl,vc,vr]\n</code></pre>"},{"location":"functions/quadrings/#quadrings.vertex_corner_valence3_neib","title":"<code>vertex_corner_valence3_neib(self)</code>","text":"<p>Retrieves the neighbors of corner vertices with valence 3.</p> <p>This function identifies the neighbors of corner vertices that have  valence 3 and returns their indices.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>vertices</code> <code>numpy array</code> <p>Indices of corner vertices with valence 3.</p> <code>left_neighbors</code> <code>numpy array</code> <p>Indices of the left neighbors.</p> <code>right_neighbors</code> <code>numpy array</code> <p>Indices of the right neighbors.</p> Note <p>This function assumes that the mesh is a regular mesh. The neighbors are useful for mesh analysis and processing.</p> See Also <p>vertex_valence3_neib : Retrieves neighbors of vertices with valence 3.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def vertex_corner_valence3_neib(self):\n    \"\"\"\n    Retrieves the neighbors of corner vertices with valence 3.\n\n    This function identifies the neighbors of corner vertices that have \n    valence 3 and returns their indices.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    vertices : numpy array\n        Indices of corner vertices with valence 3.\n    left_neighbors : numpy array\n        Indices of the left neighbors.\n    right_neighbors : numpy array\n        Indices of the right neighbors.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The neighbors are useful for mesh analysis and processing.\n\n    See Also\n    --------\n    vertex_valence3_neib : Retrieves neighbors of vertices with valence 3.\n    \"\"\"\n    v,vl,vr = self.ver_bod_valence3_neib\n    c = self.corner\n    ic = []\n    for i in range(len(v)):\n        if vl[i] in c or vr[i] in c:\n            ic.append(i)\n    ic = np.array(ic)\n    return v[ic],vl[ic],vr[ic]   \n</code></pre>"},{"location":"functions/quadrings/#quadrings.vertex_valence3_neib","title":"<code>vertex_valence3_neib(self, boundary_vertex=True, corner=False)</code>","text":"<p>Retrieves the neighbors of vertices with valence 3.</p> <p>This function identifies the neighbors of vertices that have valence 3  and returns their indices.</p> <p>Parameters:</p> Name Type Description Default <code>boundary_vertex</code> <code>(bool, optional(default=True))</code> <p>Whether to consider boundary vertices.</p> <code>True</code> <code>corner</code> <code>(bool, optional(default=False))</code> <p>Whether to consider corner vertices.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>vertices</code> <code>numpy array</code> <p>Indices of vertices with valence 3.</p> <code>neighbors</code> <code>numpy array</code> <p>Indices of the neighbors.</p> Note <p>This function assumes that the mesh is a regular mesh. The neighbors are useful for mesh analysis and processing.</p> See Also <p>boundary_vertex_3neibs : Retrieves neighbors of boundary vertices with valence 3.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def vertex_valence3_neib(self, boundary_vertex=True, corner=False):\n    \"\"\"\n    Retrieves the neighbors of vertices with valence 3.\n\n    This function identifies the neighbors of vertices that have valence 3 \n    and returns their indices.\n\n    Parameters\n    ----------\n    boundary_vertex : bool, optional (default=True)\n        Whether to consider boundary vertices.\n    corner : bool, optional (default=False)\n        Whether to consider corner vertices.\n\n    Returns\n    -------\n    vertices : numpy array\n        Indices of vertices with valence 3.\n    neighbors : numpy array\n        Indices of the neighbors.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The neighbors are useful for mesh analysis and processing.\n\n    See Also\n    --------\n    boundary_vertex_3neibs : Retrieves neighbors of boundary vertices with valence 3.\n    \"\"\"\n    v,vj,lj = self.vertex_ring_vertices_iterators(sort=True,return_lengths=True)\n    ##o2 = np.where(lj==2)[0]\n    o3 = np.where(lj==3)[0]\n    ##o4 = np.where(lj==4)[0]\n    boundary = self.boundary_vertices()\n    ##self.bvalen2 = np.intersect1d(o2, boundary)\n\n    if boundary_vertex:\n        bvalen3 = np.intersect1d(o3, boundary)\n        if len(bvalen3)==0:\n            pass\n        else:\n            H = self.halfedges\n            vl,vr = [],[]\n            for v in bvalen3:\n                \"in order\"\n                ie = np.where(H[:,0]==v)[0]\n                i = np.intersect1d(np.where(H[ie,1]!=-1)[0],np.where(H[H[ie,4],1]!=-1)[0])\n                vl.append(H[H[ie[i],3],0][0])\n                vr.append(H[H[H[H[ie[i],4],2],4],0][0])                    \n            self._ver_bod_valence3_neib = [bvalen3,np.array(vl),np.array(vr)]\n    else:\n        invalen3 = np.setdiff1d(o3,boundary)\n        if len(invalen3)==0:\n            pass\n        neib = []\n        for v in invalen3:\n            neib.append(self.ringlist[v])\n        self._ver_inn_valence3_neib = [invalen3, np.array(neib)]\n</code></pre>"},{"location":"functions/quadrings/#quadrings.vertex_valence4_neib","title":"<code>vertex_valence4_neib(self, corner=True)</code>","text":"<p>Retrieves the neighbors of vertices with valence 4.</p> <p>This function identifies the neighbors of vertices that have valence 4  and returns their indices.</p> <p>Parameters:</p> Name Type Description Default <code>corner</code> <code>(bool, optional(default=True))</code> <p>Whether to consider corner vertices.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>vertices</code> <code>numpy array</code> <p>Indices of vertices with valence 4.</p> <code>neighbors</code> <code>numpy array</code> <p>Indices of the neighbors.</p> Note <p>This function assumes that the mesh is a regular mesh. The neighbors are useful for mesh analysis and processing.</p> <p>v, neib=[v1,v2,v3,v4,va,vb,vc,vd]</p> See Also <p>vertex_valence3_neib : Retrieves neighbors of vertices with valence 3.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def vertex_valence4_neib(self, corner=True):\n    \"\"\"\n    Retrieves the neighbors of vertices with valence 4.\n\n    This function identifies the neighbors of vertices that have valence 4 \n    and returns their indices.\n\n    Parameters\n    ----------\n    corner : bool, optional (default=True)\n        Whether to consider corner vertices.\n\n    Returns\n    -------\n    vertices : numpy array\n        Indices of vertices with valence 4.\n    neighbors : numpy array\n        Indices of the neighbors.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The neighbors are useful for mesh analysis and processing.\n\n    v, neib=[v1,v2,v3,v4,va,vb,vc,vd]\n\n    See Also\n    --------\n    vertex_valence3_neib : Retrieves neighbors of vertices with valence 3.\n    \"\"\"\n    _,_,lj = self.vertex_ring_vertices_iterators(sort=True,return_lengths=True)\n    o4 = np.where(lj==4)[0]\n    boundary = self.boundary_vertices()\n    inv4 = np.setdiff1d(o4, boundary)   \n    if len(inv4)==0:\n        pass\n    else:\n        H = self.halfedges\n        vc4 = []\n        neib = np.array([],dtype=int)\n        for v in inv4:\n            if len(np.intersect1d(self.ringlist[v],boundary))==2:\n                vc4.append(v)\n                ie = np.where(H[:,0]==v)[0]\n                abcd = H[H[H[ie,2],2],0]\n                neib = np.r_[neib,abcd,np.array(self.ringlist[v])]\n        neib = neib.reshape(-1,8)\n        self._ver_corner_valence4_neib = [np.array(vc4), neib]      \n</code></pre>"},{"location":"functions/quadrings/#quadrings.vertex_valence5_neib","title":"<code>vertex_valence5_neib(self)</code>","text":"<p>Retrieves the neighbors of vertices with valence 5.</p> <p>This function identifies the neighbors of vertices that have valence 5  and returns their indices.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>vertices</code> <code>numpy array</code> <p>Indices of vertices with valence 5.</p> <code>neighbors</code> <code>numpy array</code> <p>Indices of the neighbors.</p> Note <p>This function assumes that the mesh is a regular mesh. The neighbors are useful for mesh analysis and processing.</p> See Also <p>vertex_valence3_neib : Retrieves neighbors of vertices with valence 3.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def vertex_valence5_neib(self):\n    \"\"\"\n    Retrieves the neighbors of vertices with valence 5.\n\n    This function identifies the neighbors of vertices that have valence 5 \n    and returns their indices.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    vertices : numpy array\n        Indices of vertices with valence 5.\n    neighbors : numpy array\n        Indices of the neighbors.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The neighbors are useful for mesh analysis and processing.\n\n    See Also\n    --------\n    vertex_valence3_neib : Retrieves neighbors of vertices with valence 3.\n    \"\"\"\n    v,vj,lj = self.vertex_ring_vertices_iterators(sort=True,return_lengths=True)\n    o5 = np.where(lj==5)[0]\n    boundary = self.boundary_vertices()\n    inv5 = np.setdiff1d(o5, boundary)   \n    if len(inv5)==0:\n        pass\n    else:\n        neib = []\n        for v in inv5:\n            neib.append(self.ringlist[v])\n        self._ver_inn_valence5_neib = [inv5, np.array(neib)]\n</code></pre>"},{"location":"functions/quadrings/#quadrings.vertex_valence6_neib","title":"<code>vertex_valence6_neib(self)</code>","text":"<p>Retrieves the neighbors of vertices with valence 6.</p> <p>This function identifies the neighbors of vertices that have valence 6  and returns their indices.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> <p>The function operates on the mesh data within the class instance.</p> required <p>Returns:</p> Name Type Description <code>vertices</code> <code>numpy array</code> <p>Indices of vertices with valence 6.</p> <code>neighbors</code> <code>numpy array</code> <p>Indices of the neighbors.</p> Note <p>This function assumes that the mesh is a regular mesh. The neighbors are useful for mesh analysis and processing.</p> See Also <p>vertex_valence3_neib : Retrieves neighbors of vertices with valence 3.</p> Source code in <code>src/geometry/quadrings.py</code> <pre><code>def vertex_valence6_neib(self):\n    \"\"\"\n    Retrieves the neighbors of vertices with valence 6.\n\n    This function identifies the neighbors of vertices that have valence 6 \n    and returns their indices.\n\n    Parameters\n    ----------\n    None\n        The function operates on the mesh data within the class instance.\n\n    Returns\n    -------\n    vertices : numpy array\n        Indices of vertices with valence 6.\n    neighbors : numpy array\n        Indices of the neighbors.\n\n    Note\n    ----\n    This function assumes that the mesh is a regular mesh.\n    The neighbors are useful for mesh analysis and processing.\n\n    See Also\n    --------\n    vertex_valence3_neib : Retrieves neighbors of vertices with valence 3.\n    \"\"\"\n    v,vj,lj = self.vertex_ring_vertices_iterators(sort=True,return_lengths=True)\n    o6 = np.where(lj==6)[0]\n    boundary = self.boundary_vertices()\n    inv6 = np.setdiff1d(o6, boundary)   \n    if len(inv6)==0:\n        pass\n    else:\n        neib = []\n        for v in inv6:\n            neib.append(self.ringlist[v])\n        self._ver_inn_valence6_neib = [inv6, np.array(neib)]     \n</code></pre>"},{"location":"optimization/","title":"Optimization","text":"<p>ArchGeo provides not only a GUI to visualize the 3D models, including point cloud, curves, surfaces, meshes and vector field, but also an optimization framework to solve geometry processing problems.  ArchGeo is a powerful tool to do interactive design.</p> <p>It utilizes a Gauss-Newton algorithm, so-called Guided Projection Algorithm as dissused in the paper \"Form-finding with polyhedral meshes made simple\", to optimize and generate constrained quadmesh models.</p> Abstract of the paper 'Form-finding with Polyhedral Meshes Made Simple'    We solve the form-finding problem for polyhedral meshes in a way which combines form, function and fabrication; taking care of user-specified constraints like boundary interpolation, planarity of faces, statics, panel size and shape, enclosed volume, and last, but not least, cost. Our main application is the interactive modeling of meshes for architectural and industrial design. Our approach can be described as guided exploration of the constraint space whose algebraic structure is simplified by introducing auxiliary variables and ensuring that constraints are at most quadratic. Computationally, we perform a projection onto the constraint space which is biased towards low values of an energy which expresses desirable \"soft\" properties like fairness. We have created a tool which elegantly handles difficult tasks, such as taking boundary-alignment of polyhedral meshes into account, planarization, fairing under planarity side conditions, handling hybrid meshes, and extending the treatment of static equilibrium to shapes which possess overhanging parts.   <p></p> <p>For the Chinese explaination, please refer to the Section 3.7 in the PhD thesis.</p>"},{"location":"optimization/#guided-projection-algorithm","title":"Guided Projection Algorithm","text":"<p>Guided Projection Algorithm solves the geometry optimization problem by representing all the constraints to be equations with no more than quadratic degrees. If there are \\(N\\) constraints, then there exist symmetric matrices \\(A_i\\), vectors \\(b_i\\) and constants \\(c_i\\) such that all the constraints can be represented in the following form</p> \\[ \\varphi_i(X) = \\frac{1}{2}X^T A_i X + b_i^T X +c_i = 0, i=1,\\cdots,N, \\] <p>where \\(X\\) is the vector of variables to be optimized.  This representation allows the algorithm to efficiently handle a wide range of geometric constraints, making it a powerful tool for geometry processing tasks.</p> <p>\\(X\\) can be extended once more geometry constraints are added.  Additional variables as auxiliary variables may be added into \\(X\\) when lowering higher order (more than quadratic) equations to at-most quadratic equations, which requires geometric understanding. The whole optimization is an iterative process until a satisfied solver \\(X\\) is obtained. </p> <p>Suppose the solver in the last iteration is \\(X_n\\), above equations can be linearized using Taylor expansion</p> \\[ \\varphi_i(X) \\thickapprox \\varphi_i(X_n) + \\nabla \\varphi_i(X_n)^T(X-X_n) = 0, i=1,\\cdots,N, \\] <p>which can be written as \\(H \\cdot X  = r\\), where </p> \\[ H = \\left[\\begin{array}{cc} \\nabla\\varphi_1(X_{n})^T\\\\ \\nabla\\varphi_2(X_{n})^T\\\\ \\vdots \\\\ \\nabla\\varphi_N(X_{n})^T \\end{array}\\right]  = \\left[\\begin{array}{cc} (A_1\\cdot X+b_1)^{T}\\\\ (A_2\\cdot X+b_2)^{T}\\\\ \\vdots \\\\ (A_N\\cdot X+b_N)^{T} \\end{array}\\right], \\] \\[ r = \\left[\\begin{array}{cc} -\\varphi_1(X_n) + \\nabla\\varphi_1(X_n)^TX_n\\\\ -\\varphi_2(X_n) + \\nabla\\varphi_2(X_n)^TX_n\\\\ \\vdots \\\\ -\\varphi_N(X_n) + \\nabla\\varphi_N(X_n)^TX_n \\end{array}\\right] = \\left[\\begin{array}{cc} \\frac{1}{2}\\cdot X^T\\cdot A_1\\cdot X - c_1\\\\ \\frac{1}{2}\\cdot X^T\\cdot A_2\\cdot X - c_2\\\\ \\vdots \\\\ \\frac{1}{2}\\cdot X^T\\cdot A_{N}\\cdot X -c_N \\end{array}\\right]. \\] <p>We do not solve \\(H \\cdot X  = r\\) directly, since this linear system is typically underdetermined. Usually there is enough solution space, and we add fairness term (explained later) and  a controlled solver distance from the previous value \\(X_n\\) as regularizers. Then we solve </p> \\[ \\|HX - r\\|^2 + \\|KX - s\\|^2 + \\epsilon^2\\|X - X_n\\|^2 \\to min , \\] <p>where \\(\\|KX - s\\|\\) and \\(\\|X - X_n\\|\\) are regularizers, and \\(\\epsilon=0.001\\) for almost all the optimization cases.</p> <p>Furthermore, we only solve the linear system</p> \\[ (H^T H +  K^T K + \\epsilon^2 I)X = H^T r +  K^T s + \\epsilon^2 X_N, \\] <p>which can be solved fast by the SciPy sparse matrix solver. In this codebase, we use PyPardiso to increase the computing.</p>"},{"location":"optimization/#fairness-term","title":"Fairness term","text":"<p>The fairness term \\(\\|KX - s\\|\\) is a simple and efficient soft constraint that plays a crucial role in smoothing out polylines in visual appearance. Soft constraints typically have smaller and controllable weights compared to hard constraints. </p> <p>While the smoothness of vertices in triangular mesh is achieved using Laplacian fairness, the focus here is on the smoothness of polylines.</p> <p>For each vertex \\(v\\) of valence 4 in a quad mesh, we consider 4 neighbouring connected vertices be \\(v_i(i=1,\\cdots,4)\\) in clockwise order and use vanishing second order differences to represent the smoothness of any three consecutive vertices</p> \\[ v_1 -2 v + v_3=0, v_2 -2 v + v_4=0. \\]"},{"location":"optimization/#hard-constraints","title":"Hard constraints","text":"<p>In the paper \"Discrete Orthogonal Structures\", the basic hard constraint is orthogonality of quad meshes, which is defined as equal diagonal lengths of each quad face.</p> <p>For each quad face with four vertices \\(v_i(i=1,\\cdots,4)\\) in clockwise order, two diagonal lengths \\(\\|v_1 - v_3\\|\\) and \\(\\|v_2 - v_4\\|\\) are equal, i.e.</p> \\[ (v_1 - v_3)^2 - (v_2 - v_4)^2 = 0 \\Longleftrightarrow v_1^2 - v_2^2 + v_3^2 - v_4^2 - 2 v_1 v_3 + 2 v_2 v_4 = 0 \\] <p>Suppose the number of all vertices is \\(|V|\\) and the number of all quad faces is \\(|F|\\), then the number of all variables is \\(|X| = 3|V|\\) and the number of hard constraints is \\(N = |F|\\).</p> Variable Symbol Number <code>vertices</code> \\(v\\in R^3\\) \\(3\\vert V \\vert\\) <p>There is enough degree of freedom left for any orthogonal network. Later, we will incorporate additional properties on the orthogonal net to create specialized curve networks. For instance, the minimum net is an orthogonal asymptotic net, also known as an orthogonal A-net, which requires the addition of vertex normals to the variable \\(X\\) and an increased number \\(N\\) of hard constraints.</p>"},{"location":"optimization/#sparse-matrix-construction","title":"Sparse matrix construction","text":"<p>In the codebase framework, we only need to fill the sparse matrix \\(H\\) elements and vector \\(r\\) of each constraint.</p> <p>For the orthogonality constraint, </p> \\(H \\cdot X  = r\\) Representation <code>H: shape</code> \\((N,3\\vert V \\vert)\\) <code>H: row</code> np.tile(np.arange(\\(N\\)),12) <code>H: col</code> \\([col_1,col_2,col_3,col_4]\\) <code>H: data</code> \\(2[X_n[col_1]-X_n[col_3],X_n[col_4]-X_n[col_2],X_n[col_3]-X_n[col_1],X_n[col_2]-X_n[col_4]]\\) <code>r</code> \\((X_n[col_1] - X_n[col_3])^2 - (X_n[col_2] - X_n[col_4])^2\\) <p>This orthogonality constraint can be found in the function <code>DOS/archgeolab/constraints/constraints_basic.py/con_equal_length()</code>.</p> <p>More constraints representation can refer to the folder <code>DOS/archgeolab/constraints/</code>.</p>"},{"location":"optimization/Anet/","title":"A-net","text":"<p>Chinese explaination refers to the Section 3.6 in the PhD thesis.</p>"},{"location":"optimization/Anet/#definition","title":"Definition","text":"<p>A-net is a curve network formed by two families of asymptotic curves. Its discretization [1] is defined by a quad mesh with all planar vertex starts, i.e. each vertex \\(v\\) and its 4 neighbouring connected vertices \\(v_i(i=1,\\cdots,4)\\) are planar.</p>"},{"location":"optimization/Anet/#constraint","title":"Constraint","text":"<p>To represent the planar vertex stars, additional vertex normals \\(v_n\\) are used as auxiliary variables. \\(v_n\\) should be unit normals that are orthogonal to vectors \\(v_i-v (i=1,\\cdots,4)\\):</p> \\[ v_n ^2 = 1, v_n \\cdot (v_i-v) = 0, i=1,\\cdots,4. \\] <p>Suppose the number of vertex star of valence 4 is \\(|V_4|\\), then the number of all variables is \\(|X| = 3|V| + 3|V_4|\\) and the number of hard constraints is \\(N = |F| + 5|V_4|\\).</p> Variable Symbol Number <code>vertices</code> \\(v  \\in R^3\\) \\(3\\vert V \\vert\\) <code>normals</code> \\(v_n\\in R^3\\) \\(3\\vert V_4 \\vert\\) <p>The function for the quad mesh being A-net is <code>DOS/archgeolab/constraints/constraints_net.py/con_anet()</code>, while the function <code>./con_anet_diagnet()</code> is used for the mesh diagonal net being A-net.</p>"},{"location":"optimization/Anet/#minimal-net","title":"Minimal net","text":"<p>Orthogonal A-net is a parametrization of minimal surface [1].  The corresponding discretization can be defined by planar vertex stars and equal-diagonal-length quad faces.</p> <p>Let the sparse matrix and the array of A-net are \\(H_A\\) and \\(r_A\\), respectively. For minimal net optimization, one just stacks the sparse matrix \\(H\\) and \\(H_A\\), and concatenate the array \\(r\\) and \\(r_A\\) to the final solver.</p> <p>[1] Alexander Bobenko, Suris Yuri. 2008. Discrete differential geometry: Integrable structure. Vol. 98. American Mathematical Soc.</p>"},{"location":"optimization/PCnet/","title":"Principal curvature net","text":"<p>Chinese explaination refers to the Section 3.5 in the PhD thesis.</p>"},{"location":"optimization/PCnet/#definition","title":"Definition","text":"<p>Principal curvature net is a curve network formed by principal curvature lines, whose directions at each point follow the maximum and minimum curvature of the surface. Any net that is conjugate and orthogonal is a principal curvature net [1].  The corresponding discretization is orthogonal planar quad mesh, i.e. orthogonal PQ mesh.</p> <p>Other discretizations include circular mesh [1] and conical mesh [2].</p>"},{"location":"optimization/PCnet/#constraint-of-pq-mesh","title":"Constraint of PQ mesh","text":"<p>The representation of planar quad faces is similar to the planar vertex stars, but adding additional quad face normals \\(f_n\\) as auxiliary variables. \\(f_n\\) are unit normals orthogonal to vectors \\(v_{i+1}-v_i (i=1,2,3)\\):</p> \\[ f_n ^2 = 1, f_n \\cdot (v_{i+1}-v_i) = 0, i=1,2,3. \\] <p>The number of all variables is \\(|X| = 3|V| + 3|F|\\) and the number of hard constraints is \\(N = |F| + 4|F|\\).</p> Variable Symbol Number <code>vertices</code> \\(v  \\in R^3\\) \\(3\\vert V \\vert\\) <code>normals</code> \\(f_n\\in R^3\\) \\(3\\vert F \\vert\\) <p>The function for PQ mesh is <code>DOS/archgeolab/constraints/constraints_basic.py/con_planarity_constraints()</code>.</p> <p>[1] Alexander Bobenko, Suris Yuri. 2008. Discrete differential geometry: Integrable structure. Vol. 98. American Mathematical Soc.</p> <p>[2] Yang Liu, Helmut Pottmann, Johannes Wallner, Yongliang Yang, Wenping Wang. 2006. Geometric modeling with conical meshes and developable surfaces. ACM Trans. Graphics 25, 3, 681--689.</p>"},{"location":"optimization/Principalstress/","title":"Principal stress net","text":""},{"location":"optimization/Principalstress/#definition","title":"Definition","text":"<p>A mesh is in equilibrium if the sum of the forces at each vertex is zero, which means no bending forces appear in physical realization. If an orthogonal quad mesh is in equilibrium, it is a discrete version of the net of principal stress lines in the surface, i.e. Principal stress net [1].</p>"},{"location":"optimization/Principalstress/#constraint","title":"Constraint","text":"<p>If a vertical load \\(p_i\\) is applied in an unsupported vertex \\(v_i\\), the equilibrium condition in \\(v_i\\) reads</p> \\[ \\sum_{j=1}^4 w_{ij}(v_i-v_{ij}) - (0,0,p_i) = (0,0,0), \\] <p>where the sum is over 4 neighbouring connected vertices \\(v_{ij}\\) of \\(v_i\\), and \\(w_{ij}\\) denotes the force density in the edge from \\(v_i\\) to \\(v_j\\). </p> <p>The force densities \\(w_{ij}\\) are introduced as auxiliary variables and meet \\(w_{ij} = -w_{ji}\\).  The vertical load \\(p_i\\) can depend on the mesh in which case we update it after every iteration. </p> <p>The equilibrium function refers to <code>DOS/archgeolab/constraints/constraints_equilibrium.py/equilibrium_constraints()</code>.</p> <p>[1] Martin Kilian, Davide Pellis, Johannes Wallner, Helmut Pottmann. Material-minimizing forms and structures. ACM Trans. Graphics 36,  6 (2017): 1-12.</p>"},{"location":"optimization/Snet/","title":"S-net","text":"<p>Chinese explaination refers to the Section 3.2 in the PhD thesis.</p>"},{"location":"optimization/Snet/#definition","title":"Definition","text":"<p>S-net refers to principal symmetric net [1-3], whose net tangent directions at each point are symmetric with respect to the principal curvature directions of the surface. It is a generalization of A-net and well studied in great detail in [1]. </p> <p>The discretization of S-net is a quad mesh with spherical vertex stars for all vertices of valence 4, i.e. each vertex  \\(v\\) and its 4 neighbouring connected vertices \\(v_{i},(i=1,\\cdots,4)\\) lie on a common sphere.  Then the 5 vertices satisfy the quadratic equations:</p> \\[ (v-o)^2-r^2 = 0,  (v_i - o)^2-r^2 = 0, i=1,\\cdots,4 \\] <p>where the sphere center \\(o\\) and the radius \\(r\\) are introduced as auxiliary variables.</p>"},{"location":"optimization/Snet/#constraint-of-s-net","title":"Constraint of S-net","text":"<p>Let the number of vertex star of valence 4 is \\(|V_4|\\), then the number of all variables is \\(|X| = 3|V| + 4|V_4|\\) and the number of hard constraints is \\(N = |F| + 5|V_4|\\).</p> Variable Symbol Number <code>vertices</code> \\(v \\in R^3\\) \\(3\\vert V   \\vert\\) <code>centers</code> \\(o \\in R^3\\) \\(3\\vert V_4 \\vert\\) <code>radii</code> \\(r \\in R\\) \\(\\vert V_4 \\vert\\)"},{"location":"optimization/Snet/#cmc-net","title":"CMC-net","text":"<p>CMC surface refers to surfaces of constant mean curvature, i.e. at each point the average of two extreme curvature is constant  \\((k_1 + k_2)/2=const.\\)</p> <p>When a S-net is an orthogonal net and the spheres at the vertex stars have constant radius \\(r=const.\\), the net is a CMC-net.</p> <p>The function of quad mesh being S-net or CMC-net is <code>DOS/archgeolab/constraints/constraints_net.py/con_snet()</code>, while the function <code>./con_snet_diagnet()</code> is used for the diagonal net being S-net or CMC-net.</p> <p>[1] Davide Pellis\\(^1\\), Hui Wang\\(^1\\), Florian Rist, Martin Kilian, Helmut Pottmann, Christian M\u00fcller. ACM Trans. Graphics 39, 4 (2020): 127-1. </p> <p>[2] Martin Kilian, Hui Wang, Eike Schling, Jonas Schikore, Helmut Pottmann. Curved Support Structures and Meshes with Spherical Vertex Stars. ACM SIGGRAPH 2018 Posters. </p> <p>[3] Eike Schling, Martin Kilian, Hui Wang, Jonas Schikore, Helmut Pottmann. Design and Construction of Curved Support Structures with Repetitive Parameters. Proc. Advances in Architectural Geometry 2018 (AAG2018), Lars Hesselgren et al., Springer, 2018: 140-165. </p>"},{"location":"tutorial/","title":"Tutorial","text":""},{"location":"tutorial/#layout","title":"Layout","text":""},{"location":"tutorial/#principal-net","title":"Principal net","text":""},{"location":"tutorial/#minimal-net","title":"Minimal net","text":""},{"location":"tutorial/#cmc-net","title":"CMC net","text":""},{"location":"tutorial/#principal-stress-net","title":"Principal stress net","text":""},{"location":"tutorial/Anet/","title":"A-net","text":"<p>Definitation and constraints are here.</p>"},{"location":"tutorial/Anet/#minimal-net","title":"Minimal net","text":""},{"location":"tutorial/PCnet/","title":"Principal curvature net","text":"<p>Definitation and constraints are here.</p>"},{"location":"tutorial/PCnet/#principal-net","title":"Principal net","text":""},{"location":"tutorial/Principalstress/","title":"Principal stress net","text":"<p>Definitation and constraints are here.</p> <p></p>"},{"location":"tutorial/Snet/","title":"S-net","text":"<p>Definitation and constraints are here.</p>"},{"location":"tutorial/Snet/#cmc-net","title":"CMC net","text":""},{"location":"visualization/","title":"Visualization","text":"<p>ArchGeo provides an interactive design GUI environment, which is based on the Mayavi library, to visualize the 3D models, including point cloud, curves, surfaces, meshes and vector field.</p> <p></p>"},{"location":"visualization/#mayavi","title":"Mayavi","text":"<p>Mayavi is an interactive scientific data visualization and 3D plotting in Python.  Its development is base on TraitsUI and vtk. Mayavi library provides Python code and example gallery of visulazation of points, curves, surfaces, meshes, vector field and animations.</p>"},{"location":"visualization/#read-data","title":"Read data","text":""},{"location":"visualization/#open-an-obj-file","title":"Open an obj file","text":"<pre><code>## Instantiate the sample component\nfrom opt_gui_orthonet import OrthoNet\ncomponent = OrthoNet()\n\n## Instantiate the main geolab application\nfrom archgeolab.archgeometry.gui_basic import GeolabGUI\nGUI = GeolabGUI()\n\n## Add the component to geolab\nGUI.add_component(component)\n\n## Open an obj file e.g. file_path=path+r'\\heart.obj'\nGUI.open_obj_file(file_path)\n\n## Open another obj file\n#GUI.open_obj_file(reffile)\n\n## Start geolab main loop\nGUI.start()\n</code></pre>"},{"location":"visualization/#plot-data","title":"Plot data","text":""},{"location":"visualization/#plot-mesh","title":"Plot mesh","text":"<pre><code>from geometrylab.vtkplot.edgesource import Edges\nfrom geometrylab.vtkplot.facesource import Faces\ndef plot_mesh(self, mesh, name):\n    showe = Edges(mesh,color ='black',tube_radius=0.5*self.meshmanager.r,name=name+'e')\n    showf = Faces(mesh,color = (77,77,77),opacity=0.1,name=name+'f')\n    self.meshmanager.add([showe, showf])\n</code></pre>"},{"location":"visualization/#plot-meshedges","title":"Plot meshedges","text":"<pre><code>def plot_mesh_edges(self):\n    self.meshmanager.plot_edges(color=(157,157,157),tube_radius=0.4*self.meshmanager.r)\n</code></pre>"},{"location":"visualization/#hide-meshedges","title":"Hide meshedges","text":"<pre><code>def hide_mesh_edges(self):\n    self.meshmanager.hide_edges()\n</code></pre>"},{"location":"visualization/#plot-colored-edges","title":"Plot colored edges","text":"<pre><code>def plot_colored_edges(self, poly, data, name):\n    val = np.max(data)*1.2\n    self.meshmanager.plot_polyline(polyline=poly,edge_data=data,color='Blues',lut_range=[0,val],tube_radius=1.2*self.meshmanager.r,name=name)       \n</code></pre>"},{"location":"visualization/#plot-meshfaces","title":"Plot meshfaces","text":"<pre><code>def plot_mesh_faces(self):\n    self.meshmanager.plot_faces(color='white',glossy=1,opacity=1)\n</code></pre>"},{"location":"visualization/#hide-meshfaces","title":"Hide meshfaces","text":"<pre><code>def hide_mesh_faces(self):\n    self.meshmanager.hide_faces()\n</code></pre>"},{"location":"visualization/#plot-colored-faces","title":"Plot colored faces","text":"<pre><code>def plot_colored_faces(self, i_faces, name):\n    ## chosen indices of mesh faces are plotted differently from the left\n    data = np.zeros(self.mesh.F)\n    data[i_faces] = 1\n    self.meshmanager.plot_faces(face_data=data,color=[(8,45,130), (198,110,203)],opacity=[0,0.5],name=name)       \n</code></pre>"},{"location":"visualization/#plot-colored-points","title":"Plot colored points","text":"<pre><code>def plot_points(self, Points, name):\n    self.meshmanager.plot_glyph(points=Points,color='brg',lut_range='-:0:+',radius=2*self.meshmanager.r,name=name)   \n</code></pre>"},{"location":"visualization/#plot-polyline","title":"Plot polyline","text":"<pre><code>from geometrylab.geometry import Polyline\ndef plot_polyline(self, Points, name):\n    poly = Polyline(Points,closed=False)  \n    self.meshmanager.plot_polyline(poly,color=(138,43,226),glossy=1,tube_radius=0.5*self.meshmanager.r,name=name)\n</code></pre>"},{"location":"visualization/#plot-vectors","title":"Plot vectors","text":"<pre><code>def plot_vectors(self, an, vn, name):\n    self.meshmanager.plot_vectors(anchor=an,vectors=vn,position='tail',color = (255,0,255),name=name)  \n</code></pre>"},{"location":"visualization/#save-data","title":"Save data","text":""},{"location":"visualization/#save-obj","title":"Save obj","text":"<pre><code>def save_obj(new_mesh, new_mesh_name, save_path):\n    name = ('{}').format(new_mesh_name)  \n    completeName = os.path.join(save_path, name)   \n    new_mesh.make_obj_file(completeName)\n    print('\\n\\n NOTE: &lt;'+new_mesh_name+'&gt; mesh has been saved in &lt;'+completeName+'&gt;\\n')\n</code></pre>"},{"location":"visualization/#save-csv","title":"Save csv","text":"<pre><code>def save_csv(vertices, name):\n    ## save x, y, z list of the vertices list\n    import csv\n    x, y, z = np.transpose(vertices)\n    with open(name+'_x.csv', 'w', encoding='UTF8', newline='') as f:\n        writer = csv.writer(f)\n        writer.writerows(x)\n    with open(name+'_y.csv', 'w', encoding='UTF8', newline='') as f:\n        writer = csv.writer(f)\n        writer.writerows(y)\n    with open(name+'_z.csv', 'w', encoding='UTF8', newline='') as f:\n        writer = csv.writer(f)\n        writer.writerows(z)\n    print('NOTE: .csv files has been saved!')\n</code></pre>"},{"location":"visualization/Curve/","title":"Plot Curve","text":"<p>Bezier curves and B-spline curvess are the core representation of curves in Computer Aided Design area, where Bezier curves are the most simply one.  A very nice introduction refers here. And here is a very neat and intuitive introduction with interactive parameter changes. </p>"},{"location":"visualization/Curve/#polyline","title":"Polyline","text":"<p>Polylines are discrete curves. They are represented by straight segments connecting a series of points.</p> <pre><code>from geometrylab.geometry import Polyline\ndef plot_polyline(self, Points, name):\n    poly = Polyline(Points,closed=False)  \n    self.meshmanager.plot_polyline(poly,color=(162,20,47),glossy=0.8,tube_radius=1*self.meshmanager.r,name=name)\n</code></pre> <p> </p> Polylines <p> </p> Edges represented by axial forces"},{"location":"visualization/Curve/#bezier-curve","title":"Bezier Curve","text":"<p>Plot Bezier curve of degree 3 with given 4 control points.</p> <p>As seen in the file <code>./geometrylab/geometry/bspline.py</code>.</p> <pre><code>## plot Bezier curve, control points and control polygon:\nfrom geometrylab import vtkplot\nfrom geometrylab.bspline import BSpline\n\nP = np.array([[3,0,0], [0,10,0], [10,-10,0], [10,10,0]])\nsp = BSpline(control_points=P, degree=3)\n\ncrv = sp.curve_polyline()\nctrl = sp.control_polyline()\n\npl_crv = vtkplot.Polyline(polyline=crv, tube_radius=0.1, color='r',sampling=500)\npl_ctrl = vtkplot.Polyline(polyline=ctrl, color='black')\npl_pts = vtkplot.Points(P, radius=0.5, color='black')\n\nvtkplot.view([pl_pts, pl_crv, pl_ctrl])\n</code></pre> <p> </p> Bezier curve"},{"location":"visualization/Curve/#b-spline-curve","title":"B-spline Curve","text":"<p>Plot B-spline curve of degree 3 with given 5 control points. Two endpoints are interpolated.</p> <p>As seen in the file <code>./geometrylab/geometry/bspline.py</code>.</p> <pre><code>## plot B-spline curve, control points and control polygon:\nP = np.array([[3,0,0], [0,10,0], [10,-10,0], [10,10,0], [-10,-10,0]])\nsp = BSpline(control_points=P, degree=3,closed=False)\n\ncrv = sp.curve_polyline()\nctrl = sp.control_polyline()\n\npl_crv = vtkplot.Polyline(polyline=crv, tube_radius=0.1, color='r',sampling=500)\npl_ctrl = vtkplot.Polyline(polyline=ctrl, color='black')\npl_pts = vtkplot.Points(P, radius=0.5, color='black')\n\nvtkplot.view([pl_pts, pl_crv, pl_ctrl])\n</code></pre> <p> </p> B-spline curve <p>As seen in the file <code>./geometrylab/fitting/bspline.py</code>.</p> <pre><code>P = np.array([[0,0,0], [0,10,0], [10,-10,0], [10,10,10], [-10,-10,0]])\nsp = BSpline(control_points=P, degree=3)\n#t = np.array([0.0001, 0.2, 0.4, 0.6, 0.8, 0.9, 0.99999])\nt = np.random.random(200)\n\nPt = sp.points(t)\n\nT, N = sp.frame(t)\npl_v = vtkplot.Vectors(T,anchor=Pt)\n\npl_p = vtkplot.Points(P, radius=0.3, color='black')\n\nctrl = Polyline(P)\npl_ctrl = vtkplot.Polyline(polyline=ctrl, color='black')\n\nvtkplot.view([pl_p, pl_v, pl_ctrl])\n</code></pre> <p> </p> Tangent vectors of a B-spline curve"},{"location":"visualization/Mesh/","title":"Plot Mesh","text":"<p>Curves, surfaces, polyhedra are basic topics in geometry. Here shows some interesting geometry models with visual and algebraic representaions. Mathcurve is a very helpful curve and surface library.</p> <p>Mesh are discretized surfaces. They are represented by straight edges connecting ranges of points as vertices.</p> <pre><code>from geometrylab.vtkplot.edgesource import Edges\nfrom geometrylab.vtkplot.facesource import Faces\ndef plot_mesh(self, mesh, name):\n    showe = Edges(mesh,color='black',tube_radius=1*self.meshmanager.r,name=name+'e')\n    showf = Faces(mesh,color=(160,197,194),glossy=1,name=name+'f')\n    self.meshmanager.add([showe, showf])\n</code></pre> <p> </p> Quad mesh"},{"location":"visualization/Mesh/#quad-planarity","title":"Quad Planarity","text":"<pre><code>def plot_planarity(self, mesh, name):\n    data = mesh.face_planarity()\n    val = np.max(data)\n    print('max. planarity =','%.2g' % val)\n    showe = Edges(mesh,color='black',name=name+'e')\n    showf = Faces(mesh,face_data=data,glossy=1,opacity=1,color='coolwarm',lut_range=[0,val],name=name+'f')\n    self.meshmanager.add([showe, showf])\n</code></pre> Planarity of a quad mesh"},{"location":"visualization/Mesh/#gaussian-curvature","title":"Gaussian Curvature","text":"<pre><code>def plot_gaussian_curvature(self, mesh, name):\n    vertex_data = mesh.gaussian_curvature()\n    vertex_data = mesh.smooth_vertex_data(vertex_data)\n    showe = Edges(mesh,color='black',name=name+'e')\n    showf = Faces(mesh,vertex_data=vertex_data,color='coolwarm',lut_range='-:0:+',name=name+'f')\n    self.meshmanager.add([showe, showf])\n</code></pre> Gaussian curvature of a quad mesh"},{"location":"visualization/Mesh/#mean-curvature","title":"Mean Curvature","text":"<pre><code>def plot_mean_curvature(self, mesh, name):\n    vertex_data = mesh.mean_curvature()\n    vertex_data = mesh.smooth_vertex_data(vertex_data)\n    showe = Edges(mesh,color='black',name=name+'e')\n    showf = Faces(mesh,vertex_data=vertex_data,color='coolwarm',lut_range='-:0:+',name=name+'f')\n    self.meshmanager.add([showe, showf])\n</code></pre> Mean curvature of a quad mesh"},{"location":"visualization/Mesh/#curve-network","title":"Curve network","text":"<pre><code>def plot_curvenet(self, mesh, name):\n    poly1 = mesh.get_both_isopolyline(True)\n    poly2 = mesh.get_both_isopolyline(False)\n    self.meshmanager.plot_polyline(polyline=poly1,color='black',name=name+'1')\n    self.meshmanager.plot_polyline(polyline=poly2,color=(240,114,114),name=name+'2')\n</code></pre> Curve network of a quad mesh"},{"location":"visualization/Mesh/#isolines","title":"Isolines","text":"<pre><code>def plot_isolines(self, mesh, name, w_smooth_vertex=0.1,num_contour=20):\n    ## plot the isoline of Gaussian curvature K (red) and Mean curvature H (blue)\n    mesh,k1,k2,K,H = mesh.get_curvature_disk_polylines(is_quad=True,is_sub=True)\n\n    showf = Faces(mesh,color='white',opacity=0.99,name=name)\n    self.meshmanager.add(showf) \n\n    if w_smooth_vertex!=0:\n        K = mesh.smooth_vertex_data(K,smoothing=w_smooth_vertex)\n        H = mesh.smooth_vertex_data(H,smoothing=w_smooth_vertex)\n\n    showK = Faces(mesh,vertex_data=K,iso_surface=True,\n                    color=(162,20,47),glossy=0.8,\n                    tube_radius=3,number_of_contours=num_contour,\n                    name = name+'K')\n\n    showH = Faces(mesh,vertex_data=H,iso_surface=True,\n                    color=(2,52,118),glossy=0.8,\n                    tube_radius=3,number_of_contours=num_contour,\n                    name = name+'H')\n\n    self.meshmanager.add([showK, showH])\n</code></pre> Isolines of a quad mesh"},{"location":"visualization/Mesh/#support-structures","title":"Support Structures","text":"<pre><code>def plot_support_structures(self, mesh, name):\n    sm = mesh.get_both_support_structures_from_edges(\n                    dist=self.scale_dist_offset,\n                    is_central=self.is_middle_ss,\n                    diagnet=self.switch_diagnet,\n                    ss1=False,ss2=False) \n    data = sm.face_planarity()\n    showe = Edges(sm,color='black',name=name+'e')\n    showf = Faces(sm,face_data=data,color='coolwarm',lut_range='-:0:+',name=name+'f')\n    self.meshmanager.add([showe, showf])\n</code></pre> Support structures of a quad mesh"},{"location":"visualization/Point%20cloud/","title":"Plot Point Cloud","text":""},{"location":"visualization/Point%20cloud/#plot-colored-points","title":"Plot colored points","text":"<pre><code>def plot_points(self, Points, name):\n    self.meshmanager.plot_glyph(points=Points,color='brg',lut_range='-:0:+',radius=2*self.meshmanager.r,name=name)   \n</code></pre> Colored point cloud <p>K-means cluster of point cloud as seen in the file <code>./geometrylab/fitting/cluster.py</code>.</p> <pre><code>from geometrylab.vtkplot import Points, view\nfrom geometrylab.fitting import kmeans\nA = (np.random.random((500,3)) - np.random.random((500,3))) * 2\nc = kmeans(A, 20)\n\npl = Points(A, vertex_data=c, color='Vega20', lut_range='-:+')\nview([pl])\n</code></pre> <p> </p> Cluster of point cloud"},{"location":"visualization/Vector%20Field/","title":"Plot Vector Field","text":""},{"location":"visualization/Vector%20Field/#plot-vectors","title":"Plot vectors","text":"<pre><code>def plot_vectors(self, an, vn, name):\n    self.meshmanager.plot_vectors(anchor=an,vectors=vn,position='tail',color=(162,20,47),name=name)  \n</code></pre> Vector field"}]}